module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/YouMeVideo.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/YMLogUtils.ts":
/*!***************************!*\
  !*** ./app/YMLogUtils.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 日志级别
 *
 * @export
 * @enum {number}
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DISABLED"] = 0] = "DISABLED";
    LogLevel[LogLevel["FATAL"] = 1] = "FATAL";
    LogLevel[LogLevel["ERROR"] = 10] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 20] = "WARNING";
    LogLevel[LogLevel["INFO"] = 40] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 50] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 60] = "VERBOSE";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * 日志工具
 *
 * @export
 * @class YMLogUtils
 */
var YMLogUtils = /** @class */ (function () {
    function YMLogUtils() {
        YMLogUtils._logLevel = LogLevel.INFO;
    }
    YMLogUtils.setLogLevel = function (level) {
        this._logLevel = level;
    };
    YMLogUtils.getLogLevel = function () {
        return this._logLevel;
    };
    /**
     * 格式化时间
     *
     * @private
     * @static
     * @returns {string}
     * @memberof YMLogUtils
     */
    YMLogUtils.getNowFormatDate = function () {
        var date = new Date();
        var seperator1 = "-";
        var seperator2 = ":";
        var month = date.getMonth() + 1;
        var monthStr = "";
        var numDate = date.getDate();
        var strDate = "";
        if (month >= 1 && month <= 9) {
            monthStr = "0" + month;
        }
        else {
            monthStr = "" + month;
        }
        if (numDate >= 0 && numDate <= 9) {
            strDate = "0" + numDate;
        }
        else {
            strDate = "" + numDate;
        }
        var currentdate = date.getFullYear() + seperator1 + monthStr + seperator1 + strDate
            + " " + date.getHours() + seperator2 + date.getMinutes()
            + seperator2 + date.getSeconds() + seperator2 + date.getMilliseconds();
        return currentdate;
    };
    ;
    /**
     * INFO级别日志
     *
     * @static
     * @param {...any[]} logParams
     * @returns
     * @memberof YMLogUtils
     */
    YMLogUtils.LOGI = function () {
        var logParams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            logParams[_i] = arguments[_i];
        }
        if (YMLogUtils._logLevel < LogLevel.INFO)
            return;
        if (navigator.appName == "Microsoft Internet Explorer" && parseInt(navigator.appVersion.split(";")[1].replace(/[ ]/g, "").replace("MSIE", "")) < 11) {
            console.log("YouMeVideo -INFO- " + this.getNowFormatDate() + logParams);
        }
        else {
            console.log.apply(console, ["YouMeVideo -INFO- ", this.getNowFormatDate()].concat(logParams));
        }
    };
    /**
     * WARN级别的日志
     *
     * @static
     * @param {...any[]} logParams
     * @returns
     * @memberof YMLogUtils
     */
    YMLogUtils.LOGW = function () {
        var logParams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            logParams[_i] = arguments[_i];
        }
        if (YMLogUtils._logLevel < LogLevel.WARNING)
            return;
        if (navigator.appName == "Microsoft Internet Explorer" && parseInt(navigator.appVersion.split(";")[1].replace(/[ ]/g, "").replace("MSIE", "")) < 11) {
            console.warn("YouMeVideo -WARNING- " + this.getNowFormatDate() + logParams);
        }
        else {
            console.warn.apply(console, ["YouMeVideo -WARNING- ", this.getNowFormatDate()].concat(logParams));
        }
    };
    /**
     * ERROR级别的日志
     *
     * @static
     * @param {...any[]} logParams
     * @returns
     * @memberof YMLogUtils
     */
    YMLogUtils.LOGE = function () {
        var logParams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            logParams[_i] = arguments[_i];
        }
        if (YMLogUtils._logLevel < LogLevel.ERROR)
            return;
        if (navigator.appName == "Microsoft Internet Explorer" && parseInt(navigator.appVersion.split(";")[1].replace(/[ ]/g, "").replace("MSIE", "")) < 11) {
            console.error("YouMeVideo -ERROR- " + this.getNowFormatDate() + logParams);
        }
        else {
            console.error.apply(console, ["YouMeVideo -ERROR- ", this.getNowFormatDate()].concat(logParams));
        }
    };
    YMLogUtils._logLevel = LogLevel.INFO;
    return YMLogUtils;
}());
exports.YMLogUtils = YMLogUtils;


/***/ }),

/***/ "./app/YouMeSDK.js":
/*!*************************!*\
  !*** ./app/YouMeSDK.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//启用严格模式，ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。

const ffi = __webpack_require__(/*! ffi */ "ffi")
const ref = __webpack_require__(/*! ref */ "ref")
const os = __webpack_require__(/*! os */ "os");
var plat = os.platform();
var arch = os.arch();
var path = __webpack_require__(/*! path */ "path");

const EventEmitter = __webpack_require__(/*! events */ "events");
const emitter = new EventEmitter();

var BGRAWebGLCanvas = __webpack_require__(/*! ./canvas/BGRAWebGLCanvas */ "./app/canvas/BGRAWebGLCanvas.js");
var WebGLCanvas = __webpack_require__(/*! ./canvas/WebGLCanvas */ "./app/canvas/WebGLCanvas.js");
var YUVWebGLCanvas = __webpack_require__(/*! ./canvas/YUVWebGLCanvas */ "./app/canvas/YUVWebGLCanvas.js");
var Size = __webpack_require__(/*! ./utils/Size */ "./app/utils/Size.js");

let libPath = path.join(__dirname, 'youme_voice_engine', 'macos', 'youme_voice_engine_macd');
if (plat !== "darwin") {
    var kernel32 = ffi.Library("kernel32", {
        'SetDllDirectoryA': ["bool", ["string"]]
    });
    if (arch === 'x64') {
        kernel32.SetDllDirectoryA(path.join(__dirname, 'youme_voice_engine', 'x86-64'));
    } else {
        kernel32.SetDllDirectoryA(path.join(__dirname, 'youme_voice_engine', 'x86'));
    }
    libPath = 'youme_voice_engine';
}

//从c库中导出js接口
var cDefines = {
    "youme_init": ['int', ['string', 'string', 'int', 'string']],
    "youme_setExternalInputMode": ["void", ['bool']],
    "youme_setAVStatisticInterval": ["void", ['int']],
    "youme_setVideoNetResolution": ['int', ['int', 'int']],
    "youme_setVideoLocalResolution": ['int', ['int', 'int']],
    "youme_getCbMessage2": ['char *', []],
    "youme_freeCbMessage2": ['void', ['string']],
    "youme_joinChannelSingleMode": ['int', ['string', 'string', 'int']],
    "youme_getSDKVersion": ['int', []],
    "youme_leaveChannelAll": ['int', []],
    "youme_setToken": ['void', ['string']],
    "youme_setAudioQuality": ['void', ['int']],
    "youme_unInit": ['int', []],
    "youme_setVolume": ['void', ['int']],
    "youme_getVolume": ['uint', []],
    "youme_setMicrophoneMute": ['void', ['bool']],
    "youme_getMicrophoneMute": ['bool', []],
    "youme_getSpeakerMute": ['bool', []],
    "youme_setSpeakerMute": ['void', ['bool']],
    "youme_setOtherSpeakerMute": ['int', ['string', 'bool']],
    "youme_setOtherMicMute": ['int', ['string', 'bool']],
    "youme_setListenOtherVoice": ['int', ['string', 'bool']],
    "youme_setLogLevel": ['int', ['int', 'int']],
    "youme_setServerRegion": ['void', ['int', 'string', 'bool']],
    "youme_startCapture": ['int', []],
    "youme_stopCapture": ['int', []],
    "youme_setTestConfig": ['void', ['int']],
    "youme_setOutputToSpeaker": ['int', ['bool']],
    "youme_setAutoSendStatus": ['void', ['bool']],
    "youme_getUseMobileNetworkEnabled": ['bool', []],
    "youme_setUseMobileNetworkEnabled": ['void', ['bool']],
    "youme_setUserLogPath": ['int', ['string']],
    "youme_playBackgroundMusic": ['int', ['string', 'bool']],
    "youme_pauseBackgroundMusic": ['int', []],
    "youme_resumeBackgroundMusic": ['int', []],
    "youme_stopBackgroundMusic": ['int', []],
    "youme_setBackgroundMusicVolume": ['int', ['int']],
    "youme_setHeadsetMonitorOn": ['int', ['bool', 'bool']],
    "youme_setReverbEnabled": ['int', ['bool']],
    "youme_setVadCallbackEnabled": ['int', ['bool']],
    "youme_setMicLevelCallback": ['int', ['int']],
    "youme_setFarendVoiceLevelCallback": ['int', ['int']],
    "youme_setReleaseMicWhenMute": ['int', ['bool']],
    "youme_pauseChannel": ['int', []],
    "youme_resumeChannel": ['int', []],
    "youme_setRecordingTimeMs": ['void', ['uint']],
    "youme_setPlayingTimeMs": ['void', ['uint']],
    "youme_setServerMode": ['void', ['int']],
    "youme_requestRestApi": ['int', ['string', 'string', ref.refType('int')]],
    "youme_getChannelUserList": ['int', ['string', 'int', 'bool']],
    "youme_setUserRole": ['int', ['int']],
    "youme_getUserRole": ['int', []],
    "youme_isBackgroundMusicPlaying": ['bool', []],
    "youme_isInited": ['bool', []],
    "youme_isInChannel": ['bool', ['string']],
    "youme_sendMessage": ['int', ['string', 'string', ref.refType('int')]],
    "youme_kickOtherFromChannel": ['int', ['string', 'string', 'int']],
    "youme_openVideoEncoder": ['int', ['string']],
    "youme_inputAudioFrame": ['int', [ref.refType('pointer'), 'int', 'uint64']],
    "youme_inputVideoFrame": ['int', [ref.refType('pointer'), 'int', 'int', 'int', 'int', 'int', 'int', 'uint64']],
    "youme_stopInputVideoFrame": ['int', []],
    "youme_getVideoFrame": ['char *', ['string', ref.refType('int'), ref.refType('int'), ref.refType('int')]],
    "youme_setVideoCallback": ['int', ['string']],
    "youme_setVideoFps": ['int', ['int']],
    "youme_switchCamera": ['int', []],
    "youme_resetCamera": ['int', []],
    "youme_setCaptureFrontCameraEnable": ['int', ['bool']],
    "youme_maskVideoByUserId": ['int', ['string', 'bool']],
    "youme_setExternalInputSampleRate": ['int', ['int', 'int']],
    "youme_setVideoNetResolutionForSecond": ['int', ['int', 'int']],
    "youme_setVideoCodeBitrateForSecond": ['void', ['uint', 'uint']],
    "youme_getCurrentVideoCodeBitrate": ['uint', []],
    "youme_setVideoHardwareCodeEnable": ['void', ['bool']],
    "youme_getVideoHardwareCodeEnable": ['bool', []],
    "youme_setVideoNoFrameTimeout": ['void', ['int']],
    "youme_queryUsersVideoInfo": ['int', ['string']],
    "youme_setUsersVideoInfo": ['int', ['string']],
    "youme_openBeautify": ['int', ['bool']],
    "youme_beautifyChanged": ['int', ['double']],
    "youme_stretchFace": ['int', ['bool']],
    "youme_releaseMicSync": ['bool', []],
    "youme_resumeMicSync": ['bool', []],
    "youme_setMixVideoSize": ['void', ['int', 'int']],
    "youme_getCameraCount": ['int', []],
    "youme_getCameraName": ['int', ['int', ref.refType(ref.types.char)]],
    "youme_setOpenCameraId": ['int', ['int']],
    "youme_getVideoFrameNew": ['char *', ['string', ref.refType('int'), ref.refType('int'), ref.refType('int'), ref.refType('int')]],
    "youme_videoEngineModelEnabled": ['void', ['bool']],
}

var youme = ffi.Library(libPath, cDefines);

//获取引擎回调

function GetMsg() {
    var msg = youme.youme_getCbMessage2();

    while (msg != null && msg != "" && msg != undefined) {
        var str = ref.readCString(msg);
        var json = JSON.parse(str);
        var result_obj = new Object();

        var type = json.type;
        var memchange;
        if (type === 0) {
            var event = json.event;
            result_obj.errorcode = json.error;
            result_obj.channelid = json.channelid;
            result_obj.param = json.param;
            switch (event) {

                //YOUME_EVENT_INIT_OK 初始化成功
                case 0:
                    emitter.emit('YOUME_EVENT_INIT_OK', result_obj);
                    break;

                //YOUME_EVENT_INIT_FAILED  SDK初始化失败
                case 1:
                    emitter.emit('YOUME_EVENT_INIT_FAILED', result_obj);
                    break;

                //YOUME_EVENT_JOIN_OK   进入语音频道成功
                case 2:
                    emitter.emit('YOUME_EVENT_JOIN_OK', result_obj);
                    break;

                //YOUME_EVENT_JOIN_FAILED   进入语音频道失败
                case 3:
                    emitter.emit('YOUME_EVENT_JOIN_FAILED', result_obj);
                    break;

                //YOUME_EVENT_LEAVED_ALL   退出所有语音频道完成
                case 5:
                    emitter.emit('YOUME_EVENT_LEAVED_ALL', result_obj);
                    break;

                //YOUME_EVENT_PAUSED   暂停语音频道完成
                case 6:
                    emitter.emit('YOUME_EVENT_PAUSED', result_obj);
                    break;

                //YOUME_EVENT_RESUMED   恢复语音频道完成
                case 7:
                    emitter.emit('YOUME_EVENT_RESUMED', result_obj);
                    break;

                //YOUME_EVENT_RECONNECTING   断网了，正在重连
                case 10:
                    emitter.emit('YOUME_EVENT_RECONNECTING', result_obj);
                    break;

                //YOUME_EVENT_RECONNECTED   断网重连成功
                case 11:
                    emitter.emit('YOUME_EVENT_RECONNECTED', result_obj);
                    break;

                //YOUME_EVENT_REC_PERMISSION_STATUS
                //通知录音权限状态，成功获取权限时错误码为YOUME_SUCCESS，获取失败为YOUME_ERROR_REC_NO_PERMISSION（此时不管麦克风mute状态如何，都没有声音输出）
                case 12:
                    emitter.emit('YOUME_EVENT_REC_PERMISSION_STATUS', result_obj);
                    break;

                //YOUME_EVENT_BGM_STOPPED  通知背景音乐播放结束
                case 13:
                    emitter.emit('YOUME_EVENT_BGM_STOPPED', result_obj);
                    break;

                //YOUME_EVENT_BGM_FAILED  通知背景音乐播放失败
                case 14:
                    emitter.emit('YOUME_EVENT_BGM_FAILED', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_MIC_ON  其他用户麦克风打开
                case 16:
                    emitter.emit('YOUME_EVENT_OTHERS_MIC_ON', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_MIC_OFF  其他用户麦克风关闭
                case 17:
                    emitter.emit('YOUME_EVENT_OTHERS_MIC_OFF', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_SPEAKER_ON  其他用户扬声器打开
                case 18:
                    emitter.emit('YOUME_EVENT_OTHERS_SPEAKER_ON', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_SPEAKER_OFF  其他用户扬声器关闭
                case 19:
                    emitter.emit('YOUME_EVENT_OTHERS_SPEAKER_OFF', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VOICE_ON  其他用户进入讲话状态
                case 20:
                    emitter.emit('YOUME_EVENT_OTHERS_VOICE_ON', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VOICE_OFF  其他用户进入静默状态
                case 21:
                    emitter.emit('YOUME_EVENT_OTHERS_VOICE_OFF', result_obj);
                    break;

                //YOUME_EVENT_MY_MIC_LEVEL  麦克风的语音级别
                case 22:
                    emitter.emit('YOUME_EVENT_MY_MIC_LEVEL', result_obj);
                    break;

                //YOUME_EVENT_MIC_CTR_ON  麦克风被其他用户打开
                case 23:
                    emitter.emit('YOUME_EVENT_MIC_CTR_ON', result_obj);
                    break;

                //YOUME_EVENT_MIC_CTR_OFF  麦克风被其他用户关闭
                case 24:
                    emitter.emit('YOUME_EVENT_MIC_CTR_OFF', result_obj);
                    break;

                //YOUME_EVENT_SPEAKER_CTR_ON  扬声器被其他用户打开
                case 25:
                    emitter.emit('YOUME_EVENT_SPEAKER_CTR_ON', result_obj);
                    break;

                //YOUME_EVENT_SPEAKER_CTR_OFF  扬声器被其他用户关闭
                case 26:
                    emitter.emit('YOUME_EVENT_SPEAKER_CTR_OFF', result_obj);
                    break;

                //YOUME_EVENT_LISTEN_OTHER_ON  取消屏蔽某人语音
                case 27:
                    emitter.emit('YOUME_EVENT_LISTEN_OTHER_ON', result_obj);
                    break;

                //YOUME_EVENT_LISTEN_OTHER_OFF  屏蔽某人语音
                case 28:
                    emitter.emit('YOUME_EVENT_LISTEN_OTHER_OFF', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_MIC_ON  自己的麦克风打开
                case 29:
                    emitter.emit('YOUME_EVENT_LOCAL_MIC_ON', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_MIC_OFF  自己的麦克风关闭
                case 30:
                    emitter.emit('YOUME_EVENT_LOCAL_MIC_OFF', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_SPEAKER_ON  自己的扬声器打开
                case 31:
                    emitter.emit('YOUME_EVENT_LOCAL_SPEAKER_ON', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_SPEAKER_OFF  自己的扬声器关闭
                case 32:
                    emitter.emit('YOUME_EVENT_LOCAL_SPEAKER_OFF', result_obj);
                    break;

                //YOUME_EVENT_SEND_MESSAGE_RESULT  sendMessage成功与否的通知，param为回传的requestID
                case 60:
                    emitter.emit('YOUME_EVENT_SEND_MESSAGE_RESULT', result_obj);
                    break;

                //YOUME_EVENT_MESSAGE_NOTIFY  收到Message, param为message内容
                case 61:
                    emitter.emit('YOUME_EVENT_MESSAGE_NOTIFY', result_obj);
                    break;

                //YOUME_EVENT_KICK_RESULT  踢人的应答
                case 64:
                    emitter.emit('YOUME_EVENT_KICK_RESULT', result_obj);
                    break;

                //YOUME_EVENT_KICK_NOTIFY  被踢通知   ,param: （踢人者ID，被踢原因，被禁时间）
                case 65:
                    emitter.emit('YOUME_EVENT_KICK_NOTIFY', result_obj);
                    break;

                //YOUME_EVENT_FAREND_VOICE_LEVEL  远端说话人音量大小
                case 66:
                    emitter.emit('YOUME_EVENT_FAREND_VOICE_LEVEL', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_BE_KICKED  房间里其他人被踢出房间
                case 67:
                    emitter.emit('YOUME_EVENT_OTHERS_BE_KICKED', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VIDEO_ON  其他用户视频流打开
                case 200:
                    emitter.emit('YOUME_EVENT_OTHERS_VIDEO_ON', result_obj);
                    break;

                //YOUME_EVENT_MASK_VIDEO_BY_OTHER_USER  视频被其他用户屏蔽
                case 204:
                    emitter.emit('YOUME_EVENT_MASK_VIDEO_BY_OTHER_USER', result_obj);
                    break;

                //YOUME_EVENT_RESUME_VIDEO_BY_OTHER_USER  视频被其他用户恢复
                case 205:
                    emitter.emit('YOUME_EVENT_RESUME_VIDEO_BY_OTHER_USER', result_obj);
                    break;

                //YOUME_EVENT_MASK_VIDEO_FOR_USER  屏蔽了谁的视频
                case 206:
                    emitter.emit('YOUME_EVENT_MASK_VIDEO_FOR_USER', result_obj);
                    break;

                //YOUME_EVENT_RESUME_VIDEO_FOR_USER  恢复了谁的视频
                case 207:
                    emitter.emit('YOUME_EVENT_RESUME_VIDEO_FOR_USER', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VIDEO_SHUT_DOWN  视频断开
                case 208:
                    emitter.emit('YOUME_EVENT_OTHERS_VIDEO_SHUT_DOWN', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VIDEO_INPUT_START  其他用户视频输入开始
                case 209:
                    emitter.emit('YOUME_EVENT_OTHERS_VIDEO_INPUT_START', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_VIDEO_INPUT_STOP  其他用户视频输入结束
                case 210:
                    emitter.emit('YOUME_EVENT_OTHERS_VIDEO_INPUT_STOP', result_obj);
                    break;

                //YOUME_EVENT_MEDIA_DATA_ROAD_PASS  音视频数据通路连通，定时检测，一开始收到数据会收到PASS事件，之后变化的时候会发送
                case 211:
                    emitter.emit('YOUME_EVENT_MEDIA_DATA_ROAD_PASS', result_obj);
                    break;

                //YOUME_EVENT_MEDIA_DATA_ROAD_BLOCK  音视频数据通路不通
                case 212:
                    emitter.emit('YOUME_EVENT_MEDIA_DATA_ROAD_BLOCK', result_obj);
                    break;

                //YOUME_EVENT_QUERY_USERS_VIDEO_INFO  查询用户视频信息返回
                case 213:
                    emitter.emit('YOUME_EVENT_QUERY_USERS_VIDEO_INFO', result_obj);
                    break;

                //YOUME_EVENT_SET_USERS_VIDEO_INFO  设置用户接收视频信息返回
                case 214:
                    emitter.emit('YOUME_EVENT_SET_USERS_VIDEO_INFO', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_VIDEO_INPUT_START  本地视频输入开始（内部采集下开始摄像头/外部输入下开始input）
                case 215:
                    emitter.emit('YOUME_EVENT_LOCAL_VIDEO_INPUT_START', result_obj);
                    break;

                //YOUME_EVENT_LOCAL_VIDEO_INPUT_STOP  本地视频输入停止（内部采集下停止摄像头/外部输入下停止input）
                case 216:
                    emitter.emit('YOUME_EVENT_LOCAL_VIDEO_INPUT_STOP', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_DATA_ERROR  数据错误
                case 300:
                    emitter.emit('YOUME_EVENT_OTHERS_DATA_ERROR', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_NETWORK_BAD  网络不好
                case 301:
                    emitter.emit('YOUME_EVENT_OTHERS_NETWORK_BAD', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_BLACK_FULL  黑屏
                case 302:
                    emitter.emit('YOUME_EVENT_OTHERS_BLACK_FULL', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_GREEN_FULL  绿屏
                case 303:
                    emitter.emit('YOUME_EVENT_OTHERS_GREEN_FULL', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_BLACK_BORDER  黑边
                case 304:
                    emitter.emit('YOUME_EVENT_OTHERS_BLACK_BORDER', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_GREEN_BORDER  绿边
                case 305:
                    emitter.emit('YOUME_EVENT_OTHERS_GREEN_BORDER', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_BLURRED_SCREEN  花屏
                case 306:
                    emitter.emit('YOUME_EVENT_OTHERS_BLURRED_SCREEN', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_ENCODER_ERROR  编码错误
                case 307:
                    emitter.emit('YOUME_EVENT_OTHERS_ENCODER_ERROR', result_obj);
                    break;

                //YOUME_EVENT_OTHERS_DECODER_ERROR  解码错误
                case 308:
                    emitter.emit('YOUME_EVENT_OTHERS_DECODER_ERROR', result_obj);
                    break;

                //YOUME_EVENT_CAMERA_DEVICE_CONNECT  摄像头设备插入，移动端无效
                case 400:
                    emitter.emit('YOUME_EVENT_CAMERA_DEVICE_CONNECT', result_obj);
                    break;

                //YOUME_EVENT_CAMERA_DEVICE_DISCONNECT  摄像头设备拔出，移动端无效
                case 401:
                    emitter.emit('YOUME_EVENT_CAMERA_DEVICE_DISCONNECT', result_obj);
                    break;
            }
        }
        else if (type === 1) {
            result_obj.requestid = json.requestid;
            result_obj.errorcode = json.error;
            result_obj.query = json.query;
            result_obj.result = json.result;
            emitter.emit("onRequestRestAPI", result_obj);
        }
        else if (type === 2) {
            result_obj.channelid = json.channelid;
            result_obj.isUpdate = json.isUpdate;
            result_obj.memchange = json.memchange;
            emitter.emit("onMemberChange", result_obj);
        }
        else if (type === 3) {
            result_obj.bc = json.bc;
            result_obj.channelid = json.channelid;
            result_obj.param1 = json.param1;
            result_obj.param2 = json.param2;
            result_obj.content = json.content;
            emitter.emit("onBroadcast", result_obj);
        }
        else if (type === 4) {
            result_obj.avtype = json.avtype;
            result_obj.userid = json.userid;
            result_obj.value = json.value;
            emitter.emit("onAVStatistic", result_obj);
        }

        msg = youme.youme_freeCbMessage2(msg);
    }
};

//开始周期性拉取回调信息
var interval = 20 * 1; // 
var pollingTask = null;


function startGetMsg() {
    if (pollingTask) {
        clearInterval(pollingTask);
    }
    pollingTask = setInterval(GetMsg, interval);
}

let glcanvasMap = {};
var MyWebGLCanvas;


function updateCanvas(userid, canvasid) {

    var canvas = document.getElementById(canvasid);

    if (canvas === undefined || canvas === null) {
        return;
    }

    var len = ref.alloc('int', 0);
    var width = ref.alloc('int', 12);
    var height = ref.alloc('int', 12);
    var fmt = ref.alloc('int', 1);

    //获取视频帧数据，bgra/yuv格式
    var value = youme.youme_getVideoFrameNew(userid, len, width, height, fmt);

    var size = len.deref();

    if (size !== 0) {
        width = ref.deref(width);
        height = ref.deref(height);
        var data = ref.reinterpret(value, size);

        fmt = ref.deref(fmt);

        var datas = new Uint8Array(data);

        var glcanvas = glcanvasMap[canvas.id];
        if (glcanvas !== undefined) {
            if (glcanvas.fmt === fmt) {
                glcanvas.decode(datas, width, height);
            }
            else {
                createWebGLCanvas(canvas, fmt);
            }
        }
        else {
            createWebGLCanvas(canvas, fmt);
        }
        datas = null;
    }
}

function createWebGLCanvas(canvas, fmt) {
    if (fmt === 0) {
        MyWebGLCanvas = new YUVWebGLCanvas(canvas, new Size(canvas.width, canvas.height));
        glcanvasMap[canvas.id] = MyWebGLCanvas;
    }
    else if (fmt === 1) {
        MyWebGLCanvas = new BGRAWebGLCanvas(canvas, new Size(canvas.width, canvas.height));
        glcanvasMap[canvas.id] = MyWebGLCanvas;
    }
    else {

    }
}



/**
 * 功能描述:初始化引擎
 * 这是一个异步调用接口，如果函数返回 YOUME_SUCCESS， 则需要等待以下事件回调达到才表明初始化完成
 * YOUME_EVENT_INIT_OK - 表明初始化成功
 * YOUME_EVENT_INIT_FAILED - 表明初始化失败，最常见的失败原因是网络错误或者 AppKey/AppSecret 错误
 *
 * @param strAPPKey - 从游密申请到的 app key, 这个你们应用程序的唯一标识
 * @param strAPPSecret - 对应 strAPPKey 的私钥, 这个需要妥善保存，不要暴露给其他人
 * @param serverRegionId -
 *        设置首选连接服务器的区域码
 *        如果在初始化时不能确定区域，可以填RTC_DEFAULT_SERVER，后面确定时通过 SetServerRegion 设置。
 *        如果YOUME_RTC_SERVER_REGION定义的区域码不能满足要求，可以把这个参数设为 RTC_EXT_SERVER，然后
 *        通过后面的参数 strExtServerRegionName 设置一个自定的区域值（如中国用 "cn" 或者 “ch"表示），然后把这个自定义的区域值同步给游密。
 *        我们将通过后台配置映射到最佳区域的服务器。
 * @pExtServerRegionName - 扩展的服务器区域简称
 *
 * @return - YOUME_SUCCESS
 *           其他返回值表明发生了错误，详见YouMeConstDefine.h定义
 */
function init(strAPPKey, strAPPSecret, serverRegionId, pExtServerRegionName) {
    return youme.youme_init(strAPPKey, strAPPSecret, serverRegionId, pExtServerRegionName);
}

/**
 *  功能描述：加入语音频道
 *
 *  @param strUserID: 用户ID，要保证全局唯一
 *  @param strChannelID: 频道ID，要保证全局唯一
 *  @param eUserRole: 用户角色，用于决定讲话/播放背景音乐等权限
 *
 *  @return 错误码，详见YouMeConstDefine.h定义
 */
function joinChannelSingleMode(strUserID, strChannelID, eUserRole) {
    return youme.youme_joinChannelSingleMode(strUserID, strChannelID, eUserRole);
}

/**
 * 功能描述:   设置是否由外部输入音视频
 * @param bInputModeEnabled: true:外部输入模式，false:SDK内部采集模式
 */
function setExternalInputMode(bInputModeEnabled) {
    youme.youme_setExternalInputMode(bInputModeEnabled);
}

/**
 *  功能描述: 设置音视频统计数据时间间隔
 *  @param interval:时间间隔
 */
function setAVStatisticInterval(interval) {
    youme.youme_setAVStatisticInterval(interval);
}

/**
 *  功能描述: 设置视频网络传输过程的分辨率,高分辨率
 *  @param width:宽
 *  @param height:高
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setVideoNetResolution(width, height) {
    return youme.youme_setVideoNetResolution(width, height);
}

/**
 *  功能描述: 设置本地视频渲染回调的分辨率,高分辨率
 *  @param width:宽
 *  @param height:高
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setVideoLocalResolution(width, height) {
    return youme.youme_setVideoLocalResolution(width, height);
}

//获取版本号
function getSDKVersion() {
    return youme.youme_getSDKVersion();
}

/**
 *  功能描述:退出所有语音频道
 *
 *  @return 错误码，详见YouMeConstDefine.h定义
 */
function leaveChannelAll() {
    glcanvasMap = {};
    return youme.youme_leaveChannelAll();
}

/**
 *  功能描述:设置身份验证的token
 *  @param strToken: 身份验证用token，设置为NULL或者空字符串，清空token值。
 *  @return 无
 */
function setToken(strToken) {
    youme.youme_setToken(strToken);
}

/**
 *  功能描述: 设置Audio的传输质量
 *  @param quality: 0: low 1: high
 *
 *  @return None
 */
function setAudioQuality(quality) {
    youme.youme_setAudioQuality(quality);
}

/**
 * 功能描述:反初始化引擎，在应用退出之前需要调用这个接口释放资源。
 *        这是一个同步调用接口，函数返回时表明操作已经完成。
 *
 * @return - YOUME_SUCCESS
 *           其他返回值表明发生了错误，详见YouMeConstDefine.h定义
 */
function unInit() {
    if (pollingTask) {
        clearInterval(pollingTask);
    }
    return youme.youme_unInit();
}

/**
 *  功能描述:设置音量，取值范围是[0-100] 100表示最大音量， 默认音量是100
 *  @param uiVolume: 音量
 *  @return 无
 */
function setVolume(uiVolume) {
    youme.youme_setVolume(uiVolume);
}

/**
 *  功能描述:获取音量大小,此音量值为程序内部的音量，与系统音量相乘得到程序使用的实际音量
 *
 *  @return 音量值[0,100]
 */
function getVolume() {
    return youme.youme_getVolume();
}

/**
 *  功能描述:麦克风 静音 打开/关闭
 *
 *  @param bOn:true——关闭麦克风，false——开启麦克风
 *  @return 无
 */
function setMicrophoneMute(bOn) {
    youme.youme_setMicrophoneMute(bOn);
}

/**
 *  功能描述:获取麦克风 静音 状态
 *
 *  @return true——关闭，false——打开
 */
function getMicrophoneMute() {
    return youme.youme_getMicrophoneMute();
}

/**
 *  功能描述:获取扬声器 静音 状态
 *
 *  @return true——关闭扬声器，false——开启扬声器
 */
function getSpeakerMute() {
    return youme.youme_getSpeakerMute();
}

/**
 *  功能描述:扬声器 静音 打开/关闭
 *
 *  @param bOn:true——关闭扬声器，false——开启扬声器
 *  @return 无
 */
function setSpeakerMute(bOn) {
    youme.youme_setSpeakerMute(bOn);
}

//设置他人麦克风状态
function setOtherMicMute(userid, mute) {
    return youme.youme_setOtherMicMute(userid, mute);
}

//设置他人扬声器状态
function setOtherSpeakerMute(userid, mute) {
    return youme.youme_setOtherSpeakerMute(userid, mute);
}

//设置是否听某人的语音。
function setListenOtherVoice(userid, ison) {
    return youme.youme_setListenOtherVoice(userid, ison);
}

/**
 *  功能描述: 设置日志等级
 *  @param consoleLevel: 控制台日志等级
 *  @param fileLevel: 文件日志等级
 */
function setLogLevel(consoleLevel, fileLevel) {
    return youme.youme_setLogLevel(consoleLevel, fileLevel);
}

//设置服务器区域
function setServerRegion(serverRegionId, strExtRegionName) {
    youme.youme_setServerRegion(serverRegionId, strExtRegionName);
}

// 停止捕获本机摄像头数据
function stopCapture() {
    return youme.youme_stopCapture();
}

// 开始捕获本机摄像头数据
function startCapture() {
    return youme.youme_startCapture();
}

//是否是测试模式,测试模式使用测试服
function setTestConfig(bTest) {
    youme.youme_setTestConfig(bTest);
}

/**
 *  功能描述:切换语音输出设备
 *  默认输出到扬声器，在加入房间成功后设置，如无听筒输出的需求尽量不要调用该接口。
 *
 *  @param bOutputToSpeaker:true——使用扬声器，false——使用听筒
 *  @return 错误码，详见YouMeConstDefine.h定义
 */
function setOutputToSpeaker(bOutputToSpeaker) {
    return youme.youme_setOutputToSpeaker(bOutputToSpeaker);
}

/**
 *  功能描述:设置是否通知其他人自己的开关麦克风和扬声器的状态
 *
 *  @param bAutoSend:true——通知，false——不通知
 *  @return 无
 */
function setAutoSendStatus(bAutoSend) {
    youme.youme_setAutoSendStatus(bAutoSend);
}

/**
 *  功能描述:启用/禁用移动网络
 *
 *  @param bEnabled:true-可以启用，false-禁用，默认禁用
 *
 *  @return 无
 */
function setUseMobileNetworkEnabled(bEnabled) {
    youme.youme_setUseMobileNetworkEnabled(bEnabled);
}

/**
 *  功能描述:是否可使用移动网络
 *
 *  @return true-可以使用，false-禁用
 */
function getUseMobileNetworkEnabled() {
    return youme.youme_getUseMobileNetworkEnabled();
}

/**
 *  功能描述: 设置用户自定义Log路径
 *  @param strFilePath Log文件的路径
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setUserLogPath(strFilePath) {
    return youme.youme_setUserLogPath(strFilePath);
}

// 播放背景音乐
function playBackgroundMusic(strFilePath, bRepeat) {
    return youme.youme_playBackgroundMusic(strFilePath, bRepeat);
}

// 暂停背景音乐
function pauseBackgroundMusic() {
    return youme.youme_pauseBackgroundMusic();
}

// 恢复背景音乐
function resumeBackgroundMusic() {
    return youme.youme_resumeBackgroundMusic();
}

// 停止背景音乐
function stopBackgroundMusic() {
    return youme.youme_stopBackgroundMusic();
}

// 设置背景音乐音量
function setBackgroundMusicVolume(vol) {
    return youme.youme_setBackgroundMusicVolume(vol);
}

// 设置是否将通过耳机监听自己的声音
function setHeadsetMonitorOn(micEnabled, bgmEnabled) {
    return youme.youme_setHeadsetMonitorOn(micEnabled, bgmEnabled);
}

// 设置是否设置主播混响模式
function setReverbEnabled(bEnabled) {
    return youme.youme_setReverbEnabled(bEnabled);
}

// 设置是否启动语音检测回调
function setVadCallbackEnabled(enabled) {
    return youme.youme_setVadCallbackEnabled(enabled);
}

// 设置是否启动讲话音量回调
function setMicLevelCallback(maxLevel) {
    return youme.youme_setMicLevelCallback(maxLevel);
}

// 设置是否启动远端语音音量回调
function setFarendVoiceLevelCallback(maxLevel) {
    return youme.youme_setFarendVoiceLevelCallback(maxLevel);
}

// 设置当麦克风静音时，是否释放麦克风设备，在初始化之后、加入房间之前调用
function setReleaseMicWhenMute(enabled) {
    return youme.youme_setReleaseMicWhenMute(enabled);
}

// 暂停通话，释放对麦克风等设备资源的占用
function pauseChannel() {
    return youme.youme_pauseChannel();
}

// 恢复通话
function resumeChannel() {
    return youme.youme_resumeChannel();
}

// 设置当前录音的时间戳
function setRecordingTimeMs(timeMs) {
    youme.youme_setRecordingTimeMs(timeMs);
}

// 设置当前播放的时间戳
function setPlayingTimeMs(timeMs) {
    youme.youme_setPlayingTimeMs(timeMs);
}

// 设置服务器模式
function setServerMode(mode) {
    youme.youme_setServerMode(mode);
}

//RestApi——支持主播相关信息查询
function requestRestApi(strCommand, strQueryBody, requestID) {
    return youme.youme_requestRestApi(strCommand, strQueryBody, requestID);
}

//查询频道当前的用户列表，maxCount表明最多获取多少，-1表示获取所有
function getChannelUserList(strChannelID, maxCount, notifyMemChange) {
    return youme.youme_getChannelUserList(strChannelID, maxCount, notifyMemChange);
}

// 进入房间后，切换身份
function setUserRole(userRole) {
    return youme.youme_setUserRole(userRole);
}

// 获取身份
function getUserRole() {
    return youme.youme_getUserRole();
}

// 背景音乐是否在播放
function isBackgroundMusicPlaying() {
    return youme.youme_isBackgroundMusicPlaying();
}

// 是否初始化成功
function isInited() {
    return youme.youme_isInited();
}

// 是否在某个语音房间内
function isInChannel(pChannelID) {
    return youme.youme_isInChannel(pChannelID);
}

/**
 * 功能描述:   向房间广播消息
 * @param pChannelID: 广播房间
 * @param pContent: 广播内容-文本串
 * @param requestID:返回消息标识，回调的时候会回传该值
 * @return   YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function sendMessage(pChannelID, pContent, requestID) {
    return youme.youme_sendMessage(pChannelID, pContent, requestID);
}

/**
 *  功能描述: 把某人踢出房间
 *  @param  pUserID: 被踢的用户ID
 *  @param  pChannelID: 从哪个房间踢出
 *  @param  lastTime: 踢出后，多长时间内不允许再次进入
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function kickOtherFromChannel(pUserID, pChannelID, lastTime) {
    return youme.youme_kickOtherFromChannel(pUserID, pChannelID, lastTime);
}

// 设置是否开启视频编码器
function openVideoEncoder(pFilePath) {
    return youme.youme_openVideoEncoder(pFilePath);
}

/**
*  功能描述: (七牛接口)将提供的音频数据混合到麦克风或者扬声器的音轨里面。
*  @param data 指向PCM数据的缓冲区
*  @param len  音频数据的大小
*  @param timestamp 时间戳
*  @return YOUME_SUCCESS - 成功
*          其他 - 具体错误码
*/
function inputAudioFrame(data, len, timestamp) {
    return youme.youme_inputAudioFrame(data, len, timestamp);
}

/**
*  功能描述: (七牛接口)将提供的视频数据到producer。
*  @param data 指向视频数据的缓冲区
*  @param len  视频数据的大小
* @param width  视频宽
* @param height  视频高
* @param fmt  视频格式
* @param rotation  视频角度
* @param mirror  镜像
*  @param timestamp 时间戳
*  @return YOUME_SUCCESS - 成功
*          其他 - 具体错误码
*/
function inputVideoFrame(data, len, width, height, fmt, rotation, mirror, timestamp) {
    return youme.youme_inputVideoFrame(data, len, width, height, fmt, rotation, mirror, timestamp);
}

/**
 * 功能描述: 停止视频数据输入(七牛接口，在youme_inputVideoFrame之后调用，房间内其它用户会收到YOUME_EVENT_OTHERS_VIDEO_INPUT_STOP事件)
 * @return YOUME_SUCCESS - 成功
 *         其他 - 具体错误码
 */
function stopInputVideoFrame() {
    return youme.youme_stopInputVideoFrame();
}

// 获取视频数据
function getVideoFrame(userId, len, width, height) {
    return youme.youme_getVideoFrame(userId, len, width, height);
}

// 设置视频回调
function setVideoCallback() {
    return youme.youme_setVideoCallback("");
}

/**
 *  功能描述: 设置帧率
 *  @param  fps:帧率（1-30），默认15帧，必须在设置分辨率之前调用
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setVideoFps(fps) {
    return youme.youme_setVideoFps(fps);
}

// 切换前后摄像头
function switchCamera() {
    return youme.youme_switchCamera();
}

/**
 *  功能描述: 权限检测结束后重置摄像头
 *  @param
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function resetCamera() {
    return youme.youme_resetCamera();
}

// 设置是否前置摄像头
function setCaptureFrontCameraEnable(enable) {
    return youme.youme_setCaptureFrontCameraEnable(enable);
}

// 屏蔽/恢复某个UserId的视频流
function maskVideoByUserId(userid, mask) {
    return youme.youme_maskVideoByUserId(userid, mask);
}

/**
 *  功能描述: 设置外部输入模式的语音采样率
 *  @param inputSampleRate: 输入语音采样率
 *  @param mixedCallbackSampleRate: mix后输出语音采样率
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setExternalInputSampleRate(inputSampleRate, mixedCallbackSampleRate) {
    return youme.youme_setExternalInputSampleRate(inputSampleRate, mixedCallbackSampleRate);
}

/**
 *  功能描述: 设置视频网络传输过程的分辨率，低分辨率
 *  @param width:宽
 *  @param height:高
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setVideoNetResolutionForSecond(width, height) {
    return youme.youme_setVideoNetResolutionForSecond(width, height);
}

/**
 *  功能描述: 设置视频数据上行的码率的上下限,第二路(默认不传)
 *  @param maxBitrate: 最大码率，单位kbit/s.  0无效
 *  @param minBitrate: 最小码率，单位kbit/s.  0无效
 
 *  @return None
 *
 *  @warning:需要在进房间之前设置
 */
function setVideoCodeBitrateForSecond(maxBitrate, minBitrate) {
    youme.youme_setVideoCodeBitrateForSecond(maxBitrate, minBitrate);
}

/**
 *  功能描述: 获取视频数据上行的当前码率。
 *
 *  @return 视频数据上行的当前码率
 */
function getCurrentVideoCodeBitrate() {
    return youme.youme_getCurrentVideoCodeBitrate();
}

/**
 *  功能描述: 设置视频数据是否同意开启硬编硬解
 *  @param bEnable: true:开启，false:不开启
 *
 *  @return None
 *
 *  @note: 实际是否开启硬解，还跟服务器配置及硬件是否支持有关，要全部支持开启才会使用硬解。并且如果硬编硬解失败，也会切换回软解。
 *  @warning:需要在进房间之前设置
 */
function setVideoHardwareCodeEnable(bEnable) {
    youme.youme_setVideoHardwareCodeEnable(bEnable);
}

/**
 *  功能描述: 获取视频数据是否同意开启硬编硬解
 *  @return true:开启，false:不开启， 默认为true;
 *
 *  @note: 实际是否开启硬解，还跟服务器配置及硬件是否支持有关，要全部支持开启才会使用硬解。并且如果硬编硬解失败，也会切换回软解。
 */
function getVideoHardwareCodeEnable() {
    return youme.youme_getVideoHardwareCodeEnable();
}

/**
 *  功能描述: 设置视频无帧渲染的等待超时时间，超过这个时间会给上层回调
 *  @param timeout: 超时时间，单位为毫秒
*/
function setVideoNoFrameTimeout(timeout) {
    return youme.youme_setVideoNoFrameTimeout(timeout);
}

/**
 *  功能描述: 查询多个用户视频信息（支持分辨率）
 *  @param userList: 用户ID列表的json数组
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function queryUsersVideoInfo(userList) {
    return youme.youme_queryUsersVideoInfo(userList);
}

/**
 *  功能描述: 设置多个用户视频信息（支持分辨率）
 *  @param videoinfoList: 用户对应分辨率列表的json数组
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function setUsersVideoInfo(videoinfoList) {
    return youme.youme_setUsersVideoInfo(videoinfoList);
}

/**
 *  功能描述: 美颜开关，默认是关闭美颜
 *  @param open: true表示开启美颜，false表示关闭美颜
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function openBeautify(open) {
    return youme.youme_openBeautify(open);
}

/**
 *  功能描述: 美颜强度参数设置
 *  @param param: 美颜参数，0.0 - 1.0 ，默认为0，几乎没有美颜效果，0.5左右效果明显
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function beautifyChanged(param) {
    return youme.youme_beautifyChanged(param);
}

/**
 *  功能描述: 瘦脸开关
 *  @param param: true 开启瘦脸，false关闭，默认 false
 *  @return YOUME_SUCCESS - 成功
 *          其他 - 具体错误码
 */
function stretchFace(stretch) {
    return youme.youme_stretchFace(stretch);
}

/**
 *  功能描述: 调用后同步完成麦克风释放，只是为了方便使用 IM 的录音接口时切换麦克风使用权。
 *  @return bool - 成功
 */
function releaseMicSync() {
    return youme.youme_releaseMicSync();
}

/**
 *  功能描述: 调用后恢复麦克风到释放前的状态，只是为了方便使用 IM 的录音接口时切换麦克风使用权。
 *  @return bool - true 成功
 */
function resumeMicSync() {
    return youme.youme_resumeMicSync();
}

// 设置和流画布大小（不设置则默认为采集视频分辨率）
function setMixVideoSize(width, height) {
    youme.youme_setMixVideoSize(width, height);
}

//  获取摄像头个数。
function getCameraCount() {
    return youme.youme_getCameraCount();
}

//  获取cameraid 对应名称。
function getCameraName(cameraid) {
    var buf = new Buffer(100);
    buf.type = ref.types.CString;
    var len = youme.youme_getCameraName(cameraid, buf);
    var name = buf.slice(0, len).toString();

    return name;
}

// 设置打开摄像头id。
function setOpenCameraId(cameraid) {
    return youme.youme_setOpenCameraId(cameraid);
}

// 获取视频数据 带视频格式枚举 yuv/bgra/rgb24
function getVideoFrameNew(userId, len, width, height, fmt) {
    return youme.youme_getVideoFrameNew(userId, len, width, height, fmt);
}

function videoEngineModelEnabled(enabeld) {
    youme.youme_videoEngineModelEnabled(enabeld);
}



module.exports =
    {
        startGetMsg,
        emitter,
        init,
        joinChannelSingleMode,
        setExternalInputMode,
        setAVStatisticInterval,
        setVideoNetResolution,
        setVideoLocalResolution,
        getSDKVersion,
        unInit,
        setVolume,
        getVolume,
        setMicrophoneMute,
        getMicrophoneMute,
        getSpeakerMute,
        setSpeakerMute,
        setOtherMicMute,
        setOtherSpeakerMute,
        setListenOtherVoice,
        setLogLevel,
        setServerRegion,
        stopCapture,
        startCapture,
        setTestConfig,
        setOutputToSpeaker,
        setUseMobileNetworkEnabled,
        getUseMobileNetworkEnabled,
        setUserLogPath,
        playBackgroundMusic,
        pauseBackgroundMusic,
        resumeBackgroundMusic,
        stopBackgroundMusic,
        setBackgroundMusicVolume,
        setHeadsetMonitorOn,
        setReverbEnabled,
        setVadCallbackEnabled,
        setMicLevelCallback,
        setFarendVoiceLevelCallback,
        setReleaseMicWhenMute,
        pauseChannel,
        resumeChannel,
        setRecordingTimeMs,
        setPlayingTimeMs,
        requestRestApi,
        getChannelUserList,
        setUserRole,
        getUserRole,
        isBackgroundMusicPlaying,
        isInited,
        isInChannel,
        sendMessage,
        inputAudioFrame,
        inputVideoFrame,
        getVideoFrame,
        setVideoCallback,
        setVideoFps,
        switchCamera,
        setExternalInputSampleRate,
        setVideoNetResolutionForSecond,
        setVideoCodeBitrateForSecond,
        getCurrentVideoCodeBitrate,
        setVideoHardwareCodeEnable,
        getVideoHardwareCodeEnable,
        setVideoNoFrameTimeout,
        queryUsersVideoInfo,
        setUsersVideoInfo,
        openBeautify,
        beautifyChanged,
        stretchFace,
        releaseMicSync,
        resumeMicSync,
        setToken,
        setAudioQuality,
        stopInputVideoFrame,
        leaveChannelAll,
        setAutoSendStatus,
        setServerMode,
        kickOtherFromChannel,
        openVideoEncoder,
        resetCamera,
        setCaptureFrontCameraEnable,
        maskVideoByUserId,
        setMixVideoSize,
        getCameraCount,
        getCameraName,
        setOpenCameraId,
        getVideoFrameNew,
        videoEngineModelEnabled,
        updateCanvas
    }


/***/ }),

/***/ "./app/YouMeVideo.ts":
/*!***************************!*\
  !*** ./app/YouMeVideo.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var youme = __webpack_require__(/*! ./YouMeSDK */ "./app/YouMeSDK.js");
var ref = __webpack_require__(/*! ref */ "ref");
var YMLogUtils_1 = __webpack_require__(/*! ./YMLogUtils */ "./app/YMLogUtils.ts");
// 回调函数暂存
var loginCallback = null;
var joinRoomCallback = null;
var leaveRoomCallback = null;
var openMicroPhoneCallback = null;
var closeMicroPhoneCallback = null;
var openSpeakerCallback = null;
var closeSpeakerCallback = null;
var openCameraCallback = null;
var closeCameraCallback = null;
var pauseChannelCallback = null;
var resumeChannelCallback = null;
var maskVideoForUserCallback = {};
var resumeVideoForUserCallback = {};
var requestRestApiCallback = {};
var sendMessageCallback = {};
/**
 *判断是否为函数
 *
 * @param {*} fun
 * @returns
 */
function isFunction(fun) {
    return fun && typeof fun === 'function';
}
/**
 *
 * @export
 * @class YouMeVideo
 */
var YouMeVideo = /** @class */ (function () {
    function YouMeVideo() {
    }
    /**
     * 获取实例
     *
     * @static
     * @returns {YouMeVideo}
     */
    YouMeVideo.getInstance = function () {
        if (!this._instance) {
            // 事件循环
            youme.startGetMsg();
        }
        ;
        return this._instance || (this._instance = new YouMeVideo());
    };
    /**
     * 设置日志等级(JS层日志)
     *
     * @static
     * @param {number} level
     */
    YouMeVideo.setJSLogLevel = function (level) {
        YMLogUtils_1.YMLogUtils.setLogLevel(level);
    };
    /**
     * 获取日志等级(JS层日志)
     *
     * @static
     * @returns {number}
     */
    YouMeVideo.getJSLogLevel = function () {
        return YMLogUtils_1.YMLogUtils.getLogLevel();
    };
    /**
     * 初始化
     *
     * @param {string} strAppKey
     * @param {string} strAPPSecret
     * @param {number} serverRegionId
     * @param {string} pExtServerRegionName
     * @returns {void}
     */
    YouMeVideo.prototype.init = function (strAppKey, strAPPSecret, serverRegionId, pExtServerRegionName, callback) {
        if (isFunction(callback)) {
            loginCallback = callback;
        }
        var code = youme.init(strAppKey, strAPPSecret, serverRegionId, pExtServerRegionName);
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    /**
     * 功能描述:反初始化引擎，在应用退出之前需要调用这个接口释放资源。
     *         这是一个同步调用接口，函数返回时表明操作已经完成。
     *
     * @returns  {number}
     *         其他返回值表明发生了错误，详见YouMeConstDefine.h定义
     */
    YouMeVideo.prototype.uninit = function () {
        return youme.uninit();
    };
    /**
     *  功能描述：加入语音频道
     *
     *  @param {string} strUserID: 用户ID，要保证全局唯一
     *  @param {string} strChannelID: 频道ID，要保证全局唯一
     *  @param {number} eUserRole: 用户角色，用于决定讲话/播放背景音乐等权限
     *
     *  @return 错误码，详见YouMeConstDefine.h定义
     */
    YouMeVideo.prototype.joinChannelSingleMode = function (strUserID, strChannelID, eUserRole, callback) {
        if (isFunction(callback)) {
            joinRoomCallback = callback;
        }
        var code = youme.joinChannelSingleMode(strUserID, strChannelID, eUserRole);
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    /**
     *  功能描述:退出所有语音频道
     *
     *  @return 错误码，详见YouMeConstDefine.h定义
     */
    YouMeVideo.prototype.leaveChannelAll = function (callback) {
        if (callback) {
            leaveRoomCallback = callback;
        }
        var code = youme.leaveChannelAll();
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    /**
     *  功能描述:麦克风 静音 打开/关闭
     *
     *  @param bOn:true——关闭麦克风，false——开启麦克风
     *  @return 无
     */
    YouMeVideo.prototype.setMicrophoneMute = function (bOn, callback) {
        if (callback) {
            if (bOn) {
                closeMicroPhoneCallback = callback;
            }
            else {
                openMicroPhoneCallback = callback;
            }
        }
        youme.setMicrophoneMute(bOn);
    };
    /**
     *  功能描述:获取麦克风 静音 状态
     *
     *  @return true——关闭，false——打开
     */
    YouMeVideo.prototype.getMicrophoneMute = function () {
        return youme.getMicrophoneMute();
    };
    /**
     *  功能描述:获取扬声器 静音 状态
     *
     *  @return true——关闭扬声器，false——开启扬声器
     */
    YouMeVideo.prototype.getSpeakerMute = function () {
        return youme.getSpeakerMute();
    };
    /**
     *  功能描述:扬声器 静音 打开/关闭
     *
     *  @param bOn:true——关闭扬声器，false——开启扬声器
     *  @return 无
     */
    YouMeVideo.prototype.setSpeakerMute = function (bOn, callback) {
        if (callback) {
            if (bOn) {
                closeSpeakerCallback = callback;
            }
            else {
                openSpeakerCallback = callback;
            }
        }
        youme.setSpeakerMute(bOn);
    };
    // 停止捕获本机摄像头数据
    YouMeVideo.prototype.stopCapture = function (callback) {
        if (isFunction(callback)) {
            closeCameraCallback = callback;
        }
        var code = youme.stopCapture();
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    // 开始捕获本机摄像头数据
    YouMeVideo.prototype.startCapture = function (callback) {
        if (isFunction(callback)) {
            openCameraCallback = callback;
        }
        var code = youme.startCapture();
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    /**
     * 功能描述:   设置是否由外部输入音视频
     * @param {boolean} bInputModeEnabled: true:外部输入模式，false:SDK内部采集模式 默认为false
     */
    YouMeVideo.prototype.setExternalInputMode = function (bInputModeEnabled) {
        youme.setExternalInputMode(bInputModeEnabled);
    };
    /**
     *  功能描述: 设置音视频统计数据时间间隔
     *  @param {number} interval:时间间隔 最低为500ms
     */
    YouMeVideo.prototype.setAVStatisticInterval = function (interval) {
        youme.setAVStatisticInterval(interval);
    };
    /**
     *  功能描述: 设置本地视频渲染回调的分辨率,高分辨率
     *  @param {number} width:宽
     *  @param {number} height:高
     *  @return {number}YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setVideoLocalResolution = function (width, height) {
        return youme.setVideoLocalResolution(width, height);
    };
    /**
     *  功能描述: 设置视频网络传输过程的分辨率,高分辨率
     *  @param {number} width:宽
     *  @param {number} height:高
     *  @return {number}YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setVideoNetResolution = function (width, height) {
        return youme.setVideoNetResolution(width, height);
    };
    // 设置和流画布大小（不设置则默认为采集视频分辨率）
    YouMeVideo.prototype.setMixVideoSize = function (width, height) {
        youme.setMixVideoSize(width, height);
    };
    //设为true返回bgr格式数据 设为false返回bgra/yuv格式 默认为true
    YouMeVideo.prototype.videoEngineModelEnabled = function (enabeld) {
        youme.videoEngineModelEnabled(enabeld);
    };
    //  获取摄像头个数。
    YouMeVideo.prototype.getCameraCount = function () {
        return youme.getCameraCount();
    };
    //  获取cameraid 对应名称。
    YouMeVideo.prototype.getCameraName = function (cameraid) {
        return youme.getCameraName(cameraid);
    };
    // 设置打开摄像头id。
    YouMeVideo.prototype.setOpenCameraId = function (cameraid) {
        return youme.setOpenCameraId(cameraid);
    };
    // 设置视频回调
    YouMeVideo.prototype.setVideoCallback = function () {
        return youme.setVideoCallback();
    };
    /**
     *  功能描述:设置是否通知其他人自己的开关麦克风和扬声器的状态
     *
     *  @param bAutoSend:true——通知，false——不通知
     *  @return 无
     */
    YouMeVideo.prototype.setAutoSendStatus = function (bAutoSend) {
        youme.setAutoSendStatus(bAutoSend);
    };
    /**
     *  功能描述:设置音量，取值范围是[0-100] 100表示最大音量， 默认音量是100
     *  @param uiVolume: 音量
     *  @return 无
     */
    YouMeVideo.prototype.setVolume = function (uiVolume) {
        youme.setVolume(uiVolume);
    };
    /**
     *  功能描述:获取音量大小,此音量值为程序内部的音量，与系统音量相乘得到程序使用的实际音量
     *
     *  @return 音量值[0,100]
     */
    YouMeVideo.prototype.getVolume = function () {
        return youme.getVolume();
    };
    // 获取视频数据
    YouMeVideo.prototype.getVideoFrame = function (userId, len, width, height) {
        return youme.getVideoFrame(userId, len, width, height);
    };
    // 获取视频数据 带视频格式枚举 yuv/bgra/rgb24
    YouMeVideo.prototype.getVideoFrameNew = function (userId, len, width, height, fmt) {
        return youme.getVideoFrameNew(userId, len, width, height, fmt);
    };
    // 暂停通话，释放对麦克风等设备资源的占用
    YouMeVideo.prototype.pauseChannel = function (callback) {
        if (isFunction(callback)) {
            pauseChannelCallback = callback;
        }
        var code = youme.pauseChannel();
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    // 恢复通话
    YouMeVideo.prototype.resumeChannel = function (callback) {
        if (isFunction(callback)) {
            resumeChannelCallback = callback;
        }
        var code = youme.resumeChannel();
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
        }
        return code;
    };
    // 屏蔽/恢复某个UserId的视频流
    YouMeVideo.prototype.maskVideoByUserId = function (userid, mask, callback) {
        var code = youme.maskVideoByUserId(userid, mask, function (err, obj) {
            if (code !== 0) {
                if (isFunction(callback)) {
                    callback(code);
                }
                return;
            }
            if (callback) {
                if (mask) {
                    maskVideoForUserCallback[userid] = callback;
                }
                else {
                    resumeVideoForUserCallback[userid] = callback;
                }
            }
        });
        return code;
    };
    //获取版本号
    YouMeVideo.prototype.getSDKVersion = function () {
        return youme.getSDKVersion();
    };
    /**
     *  功能描述:设置身份验证的token
     *  @param {string} strToken: 身份验证用token，设置为NULL或者空字符串，清空token值。
     *  @return 无
     */
    YouMeVideo.prototype.setToken = function (strToken) {
        youme.setToken(strToken);
    };
    /**
     *  功能描述: 设置Audio的传输质量
     *  @param quality: 0: low 1: high
     *
     *  @return None
     */
    YouMeVideo.prototype.setAudioQuality = function (quality) {
        youme.setAudioQuality(quality);
    };
    //设置他人麦克风状态
    YouMeVideo.prototype.setOtherMicMute = function (userid, mute) {
        return youme.setOtherMicMute(userid, mute);
    };
    //设置他人扬声器状态
    YouMeVideo.prototype.setOtherSpeakerMute = function (userid, mute) {
        return youme.setOtherSpeakerMute(userid, mute);
    };
    //设置是否听某人的语音。
    YouMeVideo.prototype.setListenOtherVoice = function (userid, ison) {
        return youme.setListenOtherVoice(userid, ison);
    };
    /**
     *  功能描述: 设置日志等级
     *  @param consoleLevel: 控制台日志等级
     *  @param fileLevel: 文件日志等级
     */
    YouMeVideo.prototype.setLogLevel = function (consoleLevel, fileLevel) {
        return youme.setLogLevel(consoleLevel, fileLevel);
    };
    //设置服务器区域
    YouMeVideo.prototype.setServerRegion = function (serverRegionId, strExtRegionName) {
        youme.setServerRegion(serverRegionId, strExtRegionName);
    };
    //是否是测试模式,测试模式使用测试服
    YouMeVideo.prototype.setTestConfig = function (bTest) {
        youme.setTestConfig(bTest);
    };
    /**
     *  功能描述:切换语音输出设备
     *  默认输出到扬声器，在加入房间成功后设置，如无听筒输出的需求尽量不要调用该接口。
     *
     *  @param bOutputToSpeaker:true——使用扬声器，false——使用听筒
     *  @return 错误码，详见YouMeConstDefine.h定义
     */
    YouMeVideo.prototype.setOutputToSpeaker = function (bOutputToSpeaker) {
        return youme.setOutputToSpeaker(bOutputToSpeaker);
    };
    /**
     *  功能描述:启用/禁用移动网络
     *
     *  @param bEnabled:true-可以启用，false-禁用，默认禁用
     *
     *  @return 无
     */
    YouMeVideo.prototype.setUseMobileNetworkEnabled = function (bEnabled) {
        youme.setUseMobileNetworkEnabled(bEnabled);
    };
    /**
     *  功能描述:是否可使用移动网络
     *
     *  @return true-可以使用，false-禁用
     */
    YouMeVideo.prototype.getUseMobileNetworkEnabled = function () {
        return youme.getUseMobileNetworkEnabled();
    };
    /**
     *  功能描述: 设置用户自定义Log路径
     *  @param strFilePath Log文件的路径
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setUserLogPath = function (strFilePath) {
        return youme.setUserLogPath(strFilePath);
    };
    // 播放背景音乐
    YouMeVideo.prototype.playBackgroundMusic = function (strFilePath, bRepeat) {
        return youme.playBackgroundMusic(strFilePath, bRepeat);
    };
    // 暂停背景音乐
    YouMeVideo.prototype.pauseBackgroundMusic = function () {
        return youme.pauseBackgroundMusic();
    };
    // 恢复背景音乐
    YouMeVideo.prototype.resumeBackgroundMusic = function () {
        return youme.resumeBackgroundMusic();
    };
    // 停止背景音乐
    YouMeVideo.prototype.stopBackgroundMusic = function () {
        return youme.stopBackgroundMusic();
    };
    // 设置背景音乐音量
    YouMeVideo.prototype.setBackgroundMusicVolume = function (vol) {
        return youme.setBackgroundMusicVolume(vol);
    };
    // 设置是否将通过耳机监听自己的声音
    YouMeVideo.prototype.setHeadsetMonitorOn = function (micEnabled, bgmEnabled) {
        return youme.setHeadsetMonitorOn(micEnabled, bgmEnabled);
    };
    // 设置是否设置主播混响模式
    YouMeVideo.prototype.setReverbEnabled = function (bEnabled) {
        return youme.setReverbEnabled(bEnabled);
    };
    // 设置是否启动语音检测回调
    YouMeVideo.prototype.setVadCallbackEnabled = function (enabled) {
        return youme.setVadCallbackEnabled(enabled);
    };
    // 设置是否启动讲话音量回调
    YouMeVideo.prototype.setMicLevelCallback = function (maxLevel) {
        return youme.setMicLevelCallback(maxLevel);
    };
    // 设置是否启动远端语音音量回调
    YouMeVideo.prototype.setFarendVoiceLevelCallback = function (maxLevel) {
        return youme.setFarendVoiceLevelCallback(maxLevel);
    };
    // 设置当麦克风静音时，是否释放麦克风设备，在初始化之后、加入房间之前调用
    YouMeVideo.prototype.setReleaseMicWhenMute = function (enabled) {
        return youme.setReleaseMicWhenMute(enabled);
    };
    // 设置当前录音的时间戳
    YouMeVideo.prototype.setRecordingTimeMs = function (timeMs) {
        youme.setRecordingTimeMs(timeMs);
    };
    // 设置当前播放的时间戳
    YouMeVideo.prototype.setPlayingTimeMs = function (timeMs) {
        youme.setPlayingTimeMs(timeMs);
    };
    // 设置服务器模式
    YouMeVideo.prototype.setServerMode = function (mode) {
        youme.setServerMode(mode);
    };
    //RestApi——支持主播相关信息查询
    YouMeVideo.prototype.requestRestApi = function (strCommand, strQueryBody, callback) {
        var iRequestId = ref.alloc(ref.types.ulonglong);
        var code = youme.requestRestApi(strCommand, strQueryBody, iRequestId);
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
            return -1;
        }
        if (isFunction(callback)) {
            requestRestApiCallback[ref.deref(iRequestId)] = callback;
        }
        return ref.deref(iRequestId);
    };
    //查询频道当前的用户列表，maxCount表明最多获取多少，-1表示获取所有
    YouMeVideo.prototype.getChannelUserList = function (strChannelID, maxCount, notifyMemChange) {
        return youme.getChannelUserList(strChannelID, maxCount, notifyMemChange);
    };
    // 进入房间后，切换身份
    YouMeVideo.prototype.setUserRole = function (userRole) {
        return youme.setUserRole(userRole);
    };
    // 获取身份
    YouMeVideo.prototype.getUserRole = function () {
        return youme.getUserRole();
    };
    // 背景音乐是否在播放
    YouMeVideo.prototype.isBackgroundMusicPlaying = function () {
        return youme.isBackgroundMusicPlaying();
    };
    // 是否初始化成功
    YouMeVideo.prototype.isInited = function () {
        return youme.isInited();
    };
    // 是否在某个语音房间内
    YouMeVideo.prototype.isInChannel = function (pChannelID) {
        return youme.isInChannel(pChannelID);
    };
    /**
     * 功能描述:   向房间广播消息
     * @param pChannelID: 广播房间
     * @param pContent: 广播内容-文本串
     * @param requestID:返回消息标识，回调的时候会回传该值
     * @return   YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.sendMessage = function (pChannelID, pContent, callback) {
        var iRequestId = ref.alloc(ref.types.ulonglong);
        var code = youme.sendMessage(pChannelID, pContent, iRequestId);
        if (code !== 0) {
            if (isFunction(callback)) {
                callback(code);
            }
            return -1;
        }
        if (isFunction(callback)) {
            sendMessageCallback[ref.deref(iRequestId)] = callback;
        }
        return ref.deref(iRequestId);
    };
    /**
     *  功能描述: 把某人踢出房间
     *  @param  pUserID: 被踢的用户ID
     *  @param  pChannelID: 从哪个房间踢出
     *  @param  lastTime: 踢出后，多长时间内不允许再次进入
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.kickOtherFromChannel = function (pUserID, pChannelID, lastTime) {
        return youme.kickOtherFromChannel(pUserID, pChannelID, lastTime);
    };
    // 设置开启视频编码器
    YouMeVideo.prototype.openVideoEncoder = function (pFilePath) {
        return youme.openVideoEncoder(pFilePath);
    };
    /**
    *  功能描述: (七牛接口)将提供的音频数据混合到麦克风或者扬声器的音轨里面。
    *  @param data 指向PCM数据的缓冲区
    *  @param len  音频数据的大小
    *  @param timestamp 时间戳
    *  @return YOUME_SUCCESS - 成功
    *          其他 - 具体错误码
    */
    YouMeVideo.prototype.inputAudioFrame = function (data, len, timestamp) {
        return youme.inputAudioFrame(data, len, timestamp);
    };
    /**
    *  功能描述: (七牛接口)将提供的视频数据到producer。
    *  @param data 指向视频数据的缓冲区
    *  @param len  视频数据的大小
    * @param width  视频宽
    * @param height  视频高
    * @param fmt  视频格式
    * @param rotation  视频角度
    * @param mirror  镜像
    *  @param timestamp 时间戳
    *  @return YOUME_SUCCESS - 成功
    *          其他 - 具体错误码
    */
    YouMeVideo.prototype.inputVideoFrame = function (data, len, width, height, fmt, rotation, mirror, timestamp) {
        return youme.inputVideoFrame(data, len, width, height, fmt, rotation, mirror, timestamp);
    };
    /**
     * 功能描述: 停止视频数据输入(七牛接口，在inputVideoFrame之后调用，房间内其它用户会收到YOUME_EVENT_OTHERS_VIDEO_INPUT_STOP事件)
     * @return YOUME_SUCCESS - 成功
     *         其他 - 具体错误码
     */
    YouMeVideo.prototype.stopInputVideoFrame = function () {
        return youme.stopInputVideoFrame();
    };
    /**
     *  功能描述: 设置帧率
     *  @param  fps:帧率（1-30），默认15帧，必须在设置分辨率之前调用
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setVideoFps = function (fps) {
        return youme.setVideoFps(fps);
    };
    // 切换前后摄像头
    YouMeVideo.prototype.switchCamera = function () {
        return youme.switchCamera();
    };
    /**
     *  功能描述: 权限检测结束后重置摄像头
     *  @param
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.resetCamera = function () {
        return youme.resetCamera();
    };
    // 设置是否前置摄像头
    YouMeVideo.prototype.setCaptureFrontCameraEnable = function (enable) {
        return youme.setCaptureFrontCameraEnable(enable);
    };
    /**
     *  功能描述: 设置外部输入模式的语音采样率
     *  @param inputSampleRate: 输入语音采样率
     *  @param mixedCallbackSampleRate: mix后输出语音采样率
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setExternalInputSampleRate = function (inputSampleRate, mixedCallbackSampleRate) {
        return youme.setExternalInputSampleRate(inputSampleRate, mixedCallbackSampleRate);
    };
    /**
     *  功能描述: 设置视频数据上行的码率的上下限,第二路(默认不传)
     *  @param maxBitrate: 最大码率，单位kbit/s.  0无效
     *  @param minBitrate: 最小码率，单位kbit/s.  0无效
     
     *  @return None
     *
     *  @warning:需要在进房间之前设置
     */
    YouMeVideo.prototype.setVideoCodeBitrateForSecond = function (maxBitrate, minBitrate) {
        youme.setVideoCodeBitrateForSecond(maxBitrate, minBitrate);
    };
    /**
     *  功能描述: 获取视频数据上行的当前码率。
     *
     *  @return 视频数据上行的当前码率
     */
    YouMeVideo.prototype.getCurrentVideoCodeBitrate = function () {
        return youme.getCurrentVideoCodeBitrate();
    };
    /**
     *  功能描述: 设置视频数据是否同意开启硬编硬解
     *  @param bEnable: true:开启，false:不开启
     *
     *  @return None
     *
     *  @note: 实际是否开启硬解，还跟服务器配置及硬件是否支持有关，要全部支持开启才会使用硬解。并且如果硬编硬解失败，也会切换回软解。
     *  @warning:需要在进房间之前设置
     */
    YouMeVideo.prototype.setVideoHardwareCodeEnable = function (bEnable) {
        youme.setVideoHardwareCodeEnable(bEnable);
    };
    /**
     *  功能描述: 获取视频数据是否同意开启硬编硬解
     *  @return true:开启，false:不开启， 默认为true;
     *
     *  @note: 实际是否开启硬解，还跟服务器配置及硬件是否支持有关，要全部支持开启才会使用硬解。并且如果硬编硬解失败，也会切换回软解。
     */
    YouMeVideo.prototype.getVideoHardwareCodeEnable = function () {
        return youme.getVideoHardwareCodeEnable();
    };
    /**
     *  功能描述: 设置视频无帧渲染的等待超时时间，超过这个时间会给上层回调
     *  @param timeout: 超时时间，单位为毫秒
    */
    YouMeVideo.prototype.setVideoNoFrameTimeout = function (timeout) {
        return youme.setVideoNoFrameTimeout(timeout);
    };
    /**
     *  功能描述: 查询多个用户视频信息（支持分辨率）
     *  @param userList: 用户ID列表的json数组
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.queryUsersVideoInfo = function (userList) {
        return youme.queryUsersVideoInfo(userList);
    };
    /**
     *  功能描述: 设置多个用户视频信息（支持分辨率）
     *  @param videoinfoList: 用户对应分辨率列表的json数组
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.setUsersVideoInfo = function (videoinfoList) {
        return youme.setUsersVideoInfo(videoinfoList);
    };
    /**
     *  功能描述: 美颜开关，默认是关闭美颜
     *  @param open: true表示开启美颜，false表示关闭美颜
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.openBeautify = function (open) {
        return youme.openBeautify(open);
    };
    /**
     *  功能描述: 美颜强度参数设置
     *  @param param: 美颜参数，0.0 - 1.0 ，默认为0，几乎没有美颜效果，0.5左右效果明显
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.beautifyChanged = function (param) {
        return youme.beautifyChanged(param);
    };
    /**
     *  功能描述: 瘦脸开关
     *  @param param: true 开启瘦脸，false关闭，默认 false
     *  @return YOUME_SUCCESS - 成功
     *          其他 - 具体错误码
     */
    YouMeVideo.prototype.stretchFace = function (stretch) {
        return youme.stretchFace(stretch);
    };
    /**
     *  功能描述: 调用后同步完成麦克风释放，只是为了方便使用 IM 的录音接口时切换麦克风使用权。
     *  @return bool - 成功
     */
    YouMeVideo.prototype.releaseMicSync = function () {
        return youme.releaseMicSync();
    };
    /**
     *  功能描述: 调用后恢复麦克风到释放前的状态，只是为了方便使用 IM 的录音接口时切换麦克风使用权。
     *  @return bool - true 成功
     */
    YouMeVideo.prototype.resumeMicSync = function () {
        return youme.resumeMicSync();
    };
    YouMeVideo.prototype.updateCanvas = function (userid, canvasid) {
        youme.updateCanvas(userid, canvasid);
    };
    /////////////////////////////////////////////// 需要对外暴露的事件
    YouMeVideo.prototype.on = function (event, callback) {
        if (!isFunction(callback)) {
            YMLogUtils_1.YMLogUtils.LOGE('param error! sencond param should be a function!, please check your code');
            return;
        }
        youme.emitter.on(event, callback);
        /*
                switch (event) {
                    case 'YOUME_EVENT_RECONNECTING':  // 断网了，正在重连
                    case 'YOUME_EVENT_RECONNECTED': // 断网重连成功
                    case 'YOUME_EVENT_REC_PERMISSION_STATUS': // 通知录音权限状态，成功获取权限时错误码为YOUME_SUCCESS，获取失败为YOUME_ERROR_REC_NO_PERMISSION（此时不管麦克风mute状态如何，都没有声音输出）
                    case 'YOUME_EVENT_BGM_STOPPED': // 通知背景音乐播放结束
                    case 'YOUME_EVENT_BGM_FAILED': // 通知背景音乐播放失败
                    case 'YOUME_EVENT_OTHERS_MIC_ON': // 其他用户麦克风打开
                    case 'YOUME_EVENT_OTHERS_MIC_OFF': // 其他用户麦克风关闭
                    case 'YOUME_EVENT_OTHERS_SPEAKER_ON': // 其他用户扬声器打开
                    case 'YOUME_EVENT_OTHERS_SPEAKER_OFF': // 其他用户扬声器关闭
                    case 'YOUME_EVENT_OTHERS_VOICE_ON': // 其他用户进入讲话状态
                    case 'YOUME_EVENT_OTHERS_VOICE_OFF': // 其他用户进入静默状态
                    case 'YOUME_EVENT_MY_MIC_LEVEL': // 麦克风的语音级别
                    case 'YOUME_EVENT_MIC_CTR_ON': // 麦克风被其他用户打开
                    case 'YOUME_EVENT_MIC_CTR_OFF': // 麦克风被其他用户关闭
                    case 'YOUME_EVENT_SPEAKER_CTR_ON': // 扬声器被其他用户打开
                    case 'YOUME_EVENT_SPEAKER_CTR_OFF': // 扬声器被其他用户关闭
                    case 'YOUME_EVENT_LISTEN_OTHER_ON': // 取消屏蔽某人语音
                    case 'YOUME_EVENT_LISTEN_OTHER_OFF': // 屏蔽某人语音
                    case 'YOUME_EVENT_MESSAGE_NOTIFY': // 收到Message, param为message内容
                    case 'YOUME_EVENT_KICK_RESULT': // 踢人的应答
                    case 'YOUME_EVENT_KICK_NOTIFY': // 被踢通知   ,param: （踢人者ID，被踢原因，被禁时间）
                    case 'YOUME_EVENT_FAREND_VOICE_LEVEL': // 远端说话人音量大小
                    case 'YOUME_EVENT_OTHERS_BE_KICKED': // 房间里其他人被踢出房间
        
                    case 'YOUME_EVENT_OTHERS_VIDEO_ON': // 收到其它用户的视频流
                    case 'YOUME_EVENT_MASK_VIDEO_BY_OTHER_USER': // 视频被其他用户屏蔽
                    case 'YOUME_EVENT_RESUME_VIDEO_BY_OTHER_USER': // 视频被其他用户恢复
                    case 'YOUME_EVENT_OTHERS_VIDEO_SHUT_DOWN': // 其它用户的视频流断开（包含网络中断的情况）
                    case 'YOUME_EVENT_OTHERS_VIDEO_INPUT_START': // 其他用户视频输入开始（内部采集下开启摄像头)
                    case 'YOUME_EVENT_OTHERS_VIDEO_INPUT_STOP': // 其他用户视频输入停止（内部采集下停止摄像头)
                    case 'YOUME_EVENT_MEDIA_DATA_ROAD_PASS': // 音视频数据通路连通，定时检测，一开始收到数据会收到PASS事件，之后变化的时候会发送
                    case 'YOUME_EVENT_MEDIA_DATA_ROAD_BLOCK': // 音视频数据通路不通
                    case 'YOUME_EVENT_QUERY_USERS_VIDEO_INFO': // 查询用户视频信息返回
                    case 'YOUME_EVENT_SET_USERS_VIDEO_INFO': // 设置用户接收视频信息返回
        
                    case 'YOUME_EVENT_OTHERS_DATA_ERROR': // 数据错误
                    case 'YOUME_EVENT_OTHERS_NETWORK_BAD': // 网络不好
                    case 'YOUME_EVENT_OTHERS_BLACK_FULL': // 黑屏
                    case 'YOUME_EVENT_OTHERS_GREEN_FULL': // 绿屏
                    case 'YOUME_EVENT_OTHERS_BLACK_BORDER': // 黑边
                    case 'YOUME_EVENT_OTHERS_GREEN_BORDER': // 绿边
                    case 'YOUME_EVENT_OTHERS_BLURRED_SCREEN': // 花屏
                    case 'YOUME_EVENT_OTHERS_ENCODER_ERROR': // 编码错误
                    case 'YOUME_EVENT_OTHERS_DECODER_ERROR': // 解码错误
        
                    case 'YOUME_EVENT_CAMERA_DEVICE_CONNECT': // 摄像头设备插入，移动端无效
                    case 'YOUME_EVENT_CAMERA_DEVICE_DISCONNECT': // 摄像头设备拔出，移动端无效
                        youme.emitter.on(event, callback);
                        break;
        
                    default:
                        break;
                }*/
    };
    return YouMeVideo;
}());
exports.default = YouMeVideo;
/**
* 初始化成功
*/
youme.emitter.on('YOUME_EVENT_INIT_OK', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('INIT_OK', obj);
    if (isFunction(loginCallback)) {
        loginCallback(obj.errorcode, obj);
        loginCallback = null;
    }
    ;
});
/**
* 初始化失败
*/
youme.emitter.on('YOUME_EVENT_INIT_FAILED', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('INIT_FAILED', obj);
    if (isFunction(loginCallback)) {
        loginCallback(obj.errorcode, obj);
        loginCallback = null;
    }
    ;
});
/**
* 加入房间成功
*/
youme.emitter.on('YOUME_EVENT_JOIN_OK', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('JOIN_OK', obj);
    if (isFunction(joinRoomCallback)) {
        joinRoomCallback(obj.errorcode, obj);
        joinRoomCallback = null;
    }
    ;
});
/**
* 加入房间失败
*/
youme.emitter.on('YOUME_EVENT_JOIN_FAILED', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('JOIN_FAILED', obj);
    if (isFunction(joinRoomCallback)) {
        joinRoomCallback(obj.errorcode, obj);
        joinRoomCallback = null;
    }
    ;
});
/**
* 离开房间成功
*/
youme.emitter.on('YOUME_EVENT_LEAVED_ALL', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('LEAVED_ALL', obj);
    if (isFunction(leaveRoomCallback)) {
        leaveRoomCallback(obj.errorcode, obj);
        leaveRoomCallback = null;
    }
    ;
});
/**
* 自己的麦克风打开
*/
youme.emitter.on('YOUME_EVENT_LOCAL_MIC_ON', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('LOCAL_MIC_ON', obj);
    if (isFunction(openMicroPhoneCallback)) {
        openMicroPhoneCallback(obj.errorcode, obj);
        openMicroPhoneCallback = null;
    }
    ;
});
/**
* 自己的麦克风关闭
*/
youme.emitter.on('YOUME_EVENT_LOCAL_MIC_OFF', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('LOCAL_MIC_OFF', obj);
    if (isFunction(closeMicroPhoneCallback)) {
        closeMicroPhoneCallback(obj.errorcode, obj);
        closeMicroPhoneCallback = null;
    }
    ;
});
/**
* 自己的扬声器打开
*/
youme.emitter.on('YOUME_EVENT_LOCAL_SPEAKER_ON', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('LOCAL_SPEAKER_ON', obj);
    if (isFunction(openSpeakerCallback)) {
        openSpeakerCallback(obj.errorcode, obj);
        openSpeakerCallback = null;
    }
    ;
});
/**
* 自己的扬声器关闭
*/
youme.emitter.on('YOUME_EVENT_LOCAL_SPEAKER_OFF', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('LOCAL_SPEAKER_OFF', obj);
    if (isFunction(closeSpeakerCallback)) {
        closeSpeakerCallback(obj.errorcode, obj);
        closeSpeakerCallback = null;
    }
    ;
});
/**
* 自己的摄像头开启
*/
youme.emitter.on('YOUME_EVENT_LOCAL_VIDEO_INPUT_START', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('VIDEO_INPUT_START', obj);
    if (isFunction(openCameraCallback)) {
        openCameraCallback(obj.errorcode, obj);
        openCameraCallback = null;
    }
    ;
});
/**
* 自己的摄像头关闭
*/
youme.emitter.on('YOUME_EVENT_LOCAL_VIDEO_INPUT_STOP', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('VIDEO_INPUT_STOP', obj);
    if (isFunction(closeCameraCallback)) {
        closeCameraCallback(obj.errorcode, obj);
        closeCameraCallback = null;
    }
    ;
});
/**
* 暂停频道完成
*/
youme.emitter.on('YOUME_EVENT_PAUSED', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('YOUME_EVENT_PAUSED', obj);
    if (isFunction(pauseChannelCallback)) {
        pauseChannelCallback(obj.errorcode, obj);
        pauseChannelCallback = null;
    }
    ;
});
/**
* 恢复频道完成
*/
youme.emitter.on('YOUME_EVENT_RESUMED', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('YOUME_EVENT_RESUMED', obj);
    if (isFunction(resumeChannelCallback)) {
        resumeChannelCallback(obj.errorcode, obj);
        resumeChannelCallback = null;
    }
    ;
});
/**
* 屏蔽某人的视频
*/
youme.emitter.on('YOUME_EVENT_MASK_VIDEO_FOR_USER', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('MASK_VIDEO_FOR_USER', obj);
    if (isFunction(maskVideoForUserCallback[obj.param])) {
        maskVideoForUserCallback[obj.param](obj.errorcode, obj);
        delete maskVideoForUserCallback[obj.param];
    }
    ;
});
/**
* 恢复某人的视频
*/
youme.emitter.on('YOUME_EVENT_RESUME_VIDEO_FOR_USER', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('RESUME_VIDEO_FOR_USER', obj);
    if (isFunction(resumeVideoForUserCallback[obj.param])) {
        resumeVideoForUserCallback[obj.param](obj.errorcode, obj);
        delete resumeVideoForUserCallback[obj.param];
    }
    ;
});
/**
* sendMessage成功与否的通知，param为回传的requestID
*/
youme.emitter.on('YOUME_EVENT_SEND_MESSAGE_RESULT', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('SEND_MESSAGE_RESULT', obj);
    if (isFunction(sendMessageCallback[obj.param])) {
        sendMessageCallback[obj.param](obj.errorcode, obj);
        delete sendMessageCallback[obj.param];
    }
    ;
});
/**
* onRequestRestAPI回调
*/
youme.emitter.on('onRequestRestAPI', function (obj) {
    YMLogUtils_1.YMLogUtils.LOGI('onRequestRestAPI', obj);
    if (isFunction(requestRestApiCallback[obj.requestid])) {
        requestRestApiCallback[obj.requestid](obj.errorcode, obj);
        delete requestRestApiCallback[obj.requestid];
    }
    ;
});


/***/ }),

/***/ "./app/canvas/BGRAWebGLCanvas.js":
/*!***************************************!*\
  !*** ./app/canvas/BGRAWebGLCanvas.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Program     = __webpack_require__(/*! ./Program */ "./app/canvas/Program.js");
var Size        = __webpack_require__(/*! ../utils/Size */ "./app/utils/Size.js");
var Shader      = __webpack_require__(/*! ./Shader */ "./app/canvas/Shader.js");
var Texture     = __webpack_require__(/*! ./Texture */ "./app/canvas/Texture.js");
var Script      = __webpack_require__(/*! ./Script */ "./app/canvas/Script.js");
var WebGLCanvas = __webpack_require__(/*! ./WebGLCanvas */ "./app/canvas/WebGLCanvas.js");

var Class       = __webpack_require__(/*! uclass */ "./node_modules/uclass/uClass.js");

var vertexShaderScript = Script.createFromSource("x-shader/x-vertex", " \
  attribute vec3 aVertexPosition; \
  attribute vec2 aTextureCoord; \
  uniform mat4 uMVMatrix; \
  uniform mat4 uPMatrix; \
  varying highp vec2 vTextureCoord; \
  void main(void) { \
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); \
    vTextureCoord = aTextureCoord; \
  } \
");


var fragmentShaderScript = Script.createFromSource("x-shader/x-fragment", " \
  precision highp float; \
  varying highp vec2 vTextureCoord; \
  uniform sampler2D texture; \
  void main(void) { \
    gl_FragColor = texture2D(texture, vTextureCoord).bgra; \
  } \
");




var BGRAWebGLCanvas = new Class({
  Extends  : WebGLCanvas,
  Binds : ['decode'],

  initialize : function(canvas, size) {
    this.canvas = canvas;
    this.canvas.width = size.w;
    this.canvas.height = size.h;
    this.fmt = 1;
  },

  resize : function (size) {
    if (this.size && this.size.w === size.w && this.size.h === size.h) return;

    BGRAWebGLCanvas.parent.initialize.call(this, this.canvas, size);
  },

  onInitShaders: function() {
    this.program = new Program(this.gl);
    this.program.attach(new Shader(this.gl, vertexShaderScript));
    this.program.attach(new Shader(this.gl, fragmentShaderScript));
    this.program.link();
    this.program.use();
    this.vertexPositionAttribute = this.program.getAttributeLocation("aVertexPosition");
    this.gl.enableVertexAttribArray(this.vertexPositionAttribute);
    this.textureCoordAttribute = this.program.getAttributeLocation("aTextureCoord");
    this.gl.enableVertexAttribArray(this.textureCoordAttribute);
  },

  onInitTextures: function () {
    var gl = this.gl;
    this.texture = new Texture(gl, this.size, gl.RGBA);
  },

  onInitSceneTextures: function () {
    this.texture.bind(0, this.program, "texture");
  },

  fillBGRATextures: function(bgra) {
    this.texture.fill(bgra);
  },

  decode: function(buffer, width, height) {

    if (!buffer)
      return;

    this.resize(new Size(width, height));

    var lumaSize = width * height * 4;

    this.texture.fill(buffer.subarray(0, lumaSize));
    this.drawScene();
  },

  toString: function() {
    return "BRGACanvas Size: " + this.size;
  }
});





module.exports = BGRAWebGLCanvas;


/***/ }),

/***/ "./app/canvas/Program.js":
/*!*******************************!*\
  !*** ./app/canvas/Program.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var assert = __webpack_require__(/*! ../utils/assert */ "./app/utils/assert.js");


function Program(gl) {
  this.gl = gl;
  this.program = this.gl.createProgram();
}

Program.prototype = {
  attach: function (shader) {
    this.gl.attachShader(this.program, shader.shader);
  }, 
  link: function () {
    this.gl.linkProgram(this.program);
    // If creating the shader program failed, alert.
    assert(this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS),
           "Unable to initialize the shader program.");
  },
  use: function () {
    this.gl.useProgram(this.program);
  },
  getAttributeLocation: function(name) {
    return this.gl.getAttribLocation(this.program, name);
  },
  setMatrixUniform: function(name, array) {
    var uniform = this.gl.getUniformLocation(this.program, name);
    this.gl.uniformMatrix4fv(uniform, false, array);
  }
};
module.exports = Program;



/***/ }),

/***/ "./app/canvas/Script.js":
/*!******************************!*\
  !*** ./app/canvas/Script.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! ../utils/assert */ "./app/utils/assert.js");

/**
 * Represents a WebGL shader script.
 */

function Script() {}

Script.createFromElementId = function(id) {
  var script = document.getElementById(id);
  
  // Didn't find an element with the specified ID, abort.
  assert(script , "Could not find shader with ID: " + id);
  
  // Walk through the source element's children, building the shader source string.
  var source = "";
  var currentChild = script .firstChild;
  while(currentChild) {
    if (currentChild.nodeType == 3) {
      source += currentChild.textContent;
    }
    currentChild = currentChild.nextSibling;
  }
  
  var res = new Scriptor();
  res.type = script.type;
  res.source = source;
  return res;
};

Script.createFromSource = function(type, source) {
  var res = new Script();
  res.type = type;
  res.source = source;
  return res;
}


module.exports = Script;

/***/ }),

/***/ "./app/canvas/Shader.js":
/*!******************************!*\
  !*** ./app/canvas/Shader.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var error = __webpack_require__(/*! ../utils/error */ "./app/utils/error.js");

/**
 * Represents a WebGL shader object and provides a mechanism to load shaders from HTML
 * script tags.
 */


function Shader(gl, script) {
  
  // Now figure out what type of shader script we have, based on its MIME type.
  if (script.type == "x-shader/x-fragment") {
    this.shader = gl.createShader(gl.FRAGMENT_SHADER);
  } else if (script.type == "x-shader/x-vertex") {
    this.shader = gl.createShader(gl.VERTEX_SHADER);
  } else {
    error("Unknown shader type: " + script.type);
    return;
  }
  
  // Send the source to the shader object.
  gl.shaderSource(this.shader, script.source);
  
  // Compile the shader program.
  gl.compileShader(this.shader);
  
  // See if it compiled successfully.
  if (!gl.getShaderParameter(this.shader, gl.COMPILE_STATUS)) {
    error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(this.shader));
    return;
  }
}
module.exports = Shader;





/***/ }),

/***/ "./app/canvas/Texture.js":
/*!*******************************!*\
  !*** ./app/canvas/Texture.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! ../utils/assert */ "./app/utils/assert.js");

/**
 * Represents a WebGL texture object.
 */

function Texture(gl, size, format) {
  this.gl = gl;
  this.size = size;
  this.texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, this.texture);
  this.format = format ? format : gl.LUMINANCE; 
  gl.texImage2D(gl.TEXTURE_2D, 0, this.format, size.w, size.h, 0, this.format, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

var textureIDs = null;
Texture.prototype = {
  fill: function(textureData, useTexSubImage2D) {
    var gl = this.gl;
    assert(textureData.length >= this.size.w * this.size.h, 
           "Texture size mismatch, data:" + textureData.length + ", texture: " + this.size.w * this.size.h);
           gl.bindTexture(gl.TEXTURE_2D, this.texture);
    if (1) {

      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.size.w , this.size.h, this.format, gl.UNSIGNED_BYTE, textureData);
    } else {}
  },
  bind: function(n, program, name) {
    var gl = this.gl;
    if (!textureIDs) {
      textureIDs = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2];
    }
    gl.activeTexture(textureIDs[n]);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.uniform1i(gl.getUniformLocation(program.program, name), n);
  }
};
module.exports = Texture;



/***/ }),

/***/ "./app/canvas/WebGLCanvas.js":
/*!***********************************!*\
  !*** ./app/canvas/WebGLCanvas.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Generic WebGL backed canvas that sets up: a quad to paint a texture on, appropriate vertex/fragment shaders,
 * scene parameters and other things. Specialized versions of this class can be created by overriding several 
 * initialization methods.

 */

var Script = __webpack_require__(/*! ./Script */ "./app/canvas/Script.js");
var error  = __webpack_require__(/*! ../utils/error */ "./app/utils/error.js");
var makePerspective  = __webpack_require__(/*! ../utils/glUtils */ "./app/utils/glUtils.js").makePerspective;
var Matrix = __webpack_require__(/*! sylvester.js */ "./node_modules/sylvester.js/lib/index.js").Matrix;
var Class  = __webpack_require__(/*! uclass */ "./node_modules/uclass/uClass.js");
var Program = __webpack_require__(/*! ./Program */ "./app/canvas/Program.js");
var Shader = __webpack_require__(/*! ./Shader */ "./app/canvas/Shader.js");
var Texture = __webpack_require__(/*! ./Texture */ "./app/canvas/Texture.js");

var fmt = 0;
  

var vertexShaderScript = Script.createFromSource("x-shader/x-vertex", " \
  attribute vec3 aVertexPosition; \
  attribute vec2 aTextureCoord; \
  uniform mat4 uMVMatrix; \
  uniform mat4 uPMatrix; \
  varying highp vec2 vTextureCoord; \
  void main(void) { \
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); \
    vTextureCoord = aTextureCoord; \
  } \
");

var fragmentShaderScript = Script.createFromSource("x-shader/x-fragment", " \
  precision highp float; \
  varying highp vec2 vTextureCoord; \
  uniform sampler2D texture; \
  void main(void) { \
    gl_FragColor = texture2D(texture, vTextureCoord); \
  } \
");

var WebGLCanvas = new Class({

  initialize : function(canvas, size, useFrameBuffer) {

    this.canvas = canvas;
    this.size = size;
    this.canvas.width = size.w;
    this.canvas.height = size.h;

    this.onInitWebGL();

    this.onInitShaders();
    this.initBuffers();

    if (useFrameBuffer)
      this.initFramebuffer();

    this.onInitTextures();
    this.initScene();
  },

/**
 * Initialize a frame buffer so that we can render off-screen.
 */
  initFramebuffer : function() {

    var gl = this.gl;

    // Create framebuffer object and texture.
    this.framebuffer = gl.createFramebuffer(); 
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    this.framebufferTexture = new Texture(this.gl, this.size, gl.RGBA);

    // Create and allocate renderbuffer for depth data.
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.size.w, this.size.h);

    // Attach texture and renderbuffer to the framebuffer.
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.framebufferTexture.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
  },



/**
 * Initialize vertex and texture coordinate buffers for a plane.
 */
  initBuffers : function () {
    var tmp;
    var gl = this.gl;
    
    // Create vertex position buffer.
    this.quadVPBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVPBuffer);
    tmp = [
       1.0,  1.0, 0.0,
      -1.0,  1.0, 0.0, 
       1.0, -1.0, 0.0, 
      -1.0, -1.0, 0.0];
    
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tmp), gl.STATIC_DRAW);
    this.quadVPBuffer.itemSize = 3;
    this.quadVPBuffer.numItems = 4;
    
    /*
     +--------------------+ 
     | -1,1 (1)           | 1,1 (0)
     |                    |
     |                    |
     |                    |
     |                    |
     |                    |
     | -1,-1 (3)          | 1,-1 (2)
     +--------------------+
     */
    
    var scaleX = 1.0;
    var scaleY = 1.0;
    
    // Create vertex texture coordinate buffer.
    this.quadVTCBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVTCBuffer);
    tmp = [
      scaleX, 0.0,
      0.0, 0.0,
      scaleX, scaleY,
      0.0, scaleY,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tmp), gl.STATIC_DRAW);
  },


  mvIdentity : function () {
    this.mvMatrix = Matrix.I(4);
  },

  mvMultiply : function(m) {
    this.mvMatrix = this.mvMatrix.x(m);
  },

  mvTranslate : function (m) {
    this.mvMultiply(Matrix.Translation($V([m[0], m[1], m[2]])).ensure4x4());
  },

  setMatrixUniforms : function () {
    this.program.setMatrixUniform("uPMatrix", new Float32Array(this.perspectiveMatrix.flatten()));
    this.program.setMatrixUniform("uMVMatrix", new Float32Array(this.mvMatrix.flatten()));
  },

  initScene : function() {
    var gl = this.gl;
    
    // Establish the perspective with which we want to view the
    // scene. Our field of view is 45 degrees, with a width/height
    // ratio of 640:480, and we only want to see objects between 0.1 units
    // and 100 units away from the camera.
    
    this.perspectiveMatrix = makePerspective(45, 1, 0.1, 100.0);
    
    // Set the drawing position to the "identity" point, which is
    // the center of the scene.
    this.mvIdentity();

    // Now move the drawing position a bit to where we want to start
    // drawing the square.
    this.mvTranslate([0.0, 0.0, -2.4]);

    // Draw the cube by binding the array buffer to the cube's vertices
    // array, setting attributes, and pushing it to GL.
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVPBuffer);
    gl.vertexAttribPointer(this.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    
    // Set the texture coordinates attribute for the vertices.
    
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVTCBuffer);
    gl.vertexAttribPointer(this.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);  
    
    this.onInitSceneTextures();
    
    this.setMatrixUniforms();
    
    if (this.framebuffer) {
      console.log("Bound Frame Buffer");
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    }
  },



  toString: function() {
    return "WebGLCanvas Size: " + this.size;
  },

  checkLastError: function (operation) {
    var err = this.gl.getError();
    if (err != this.gl.NO_ERROR) {
      var name = this.glNames[err];
      name = (name !== undefined) ? name + "(" + err + ")":
          ("Unknown WebGL ENUM (0x" + value.toString(16) + ")");
      if (operation) {
        console.log("WebGL Error: %s, %s", operation, name);
      } else {
        console.log("WebGL Error: %s", name);
      }
      console.trace();
    }
  },

  onInitWebGL: function () {
    try {
      this.gl = this.canvas.getContext("experimental-webgl") || this.canvas.getContext('webgl');
    } catch(e) {}
    if (!this.gl) {
      error("Unable to initialize WebGL. Your browser may not support it.");
    }
    if (this.glNames) {
      return;
    }
    this.glNames = {};
    for (var propertyName in this.gl) {
      if (typeof this.gl[propertyName] == 'number') {
        this.glNames[this.gl[propertyName]] = propertyName;
      }
    }
  },

  onInitShaders: function() {
    this.program = new Program(this.gl);
    this.program.attach(new Shader(this.gl, vertexShaderScript));
    this.program.attach(new Shader(this.gl, fragmentShaderScript));
    this.program.link();
    this.program.use();
    this.vertexPositionAttribute = this.program.getAttributeLocation("aVertexPosition");
    this.gl.enableVertexAttribArray(this.vertexPositionAttribute);
    this.textureCoordAttribute = this.program.getAttributeLocation("aTextureCoord");;
    this.gl.enableVertexAttribArray(this.textureCoordAttribute);
  },

  onInitTextures: function () {
    var gl = this.gl;
    this.texture = new Texture(gl, this.size, gl.RGBA);
  },

  onInitSceneTextures: function () {
    this.texture.bind(0, this.program, "texture");
  },

  drawScene: function() {
    var gl = this.gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVPBuffer);
    gl.vertexAttribPointer(this.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
    
    // Set the texture coordinates attribute for the vertices.
    
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVTCBuffer);
    gl.vertexAttribPointer(this.textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);  
    
    this.setMatrixUniforms();

    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
  },

  readPixels: function(buffer) {
    var gl = this.gl;
    gl.readPixels(0, 0, this.size.w, this.size.h, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
  },

  bindFrameBuffer: function(){
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  },

});



module.exports = WebGLCanvas;


/***/ }),

/***/ "./app/canvas/YUVWebGLCanvas.js":
/*!**************************************!*\
  !*** ./app/canvas/YUVWebGLCanvas.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Program     = __webpack_require__(/*! ./Program */ "./app/canvas/Program.js");
var Size        = __webpack_require__(/*! ../utils/Size */ "./app/utils/Size.js");
var Shader      = __webpack_require__(/*! ./Shader */ "./app/canvas/Shader.js");
var Texture     = __webpack_require__(/*! ./Texture */ "./app/canvas/Texture.js");
var Script      = __webpack_require__(/*! ./Script */ "./app/canvas/Script.js");
var WebGLCanvas = __webpack_require__(/*! ./WebGLCanvas */ "./app/canvas/WebGLCanvas.js");

var Class       = __webpack_require__(/*! uclass */ "./node_modules/uclass/uClass.js");

var vertexShaderScript = Script.createFromSource("x-shader/x-vertex", " \
  attribute vec3 aVertexPosition; \
  attribute vec2 aTextureCoord; \
  uniform mat4 uMVMatrix; \
  uniform mat4 uPMatrix; \
  varying highp vec2 vTextureCoord; \
  void main(void) { \
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); \
    vTextureCoord = aTextureCoord; \
  } \
");


var fragmentShaderScript = Script.createFromSource("x-shader/x-fragment", " \
  precision highp float; \
  varying highp vec2 vTextureCoord; \
  uniform sampler2D YTexture; \
  uniform sampler2D UTexture; \
  uniform sampler2D VTexture; \
  const mat4 YUV2RGB = mat4 \
  ( \
   1.1643828125, 0, 1.59602734375, -.87078515625, \
   1.1643828125, -.39176171875, -.81296875, .52959375, \
   1.1643828125, 2.017234375, 0, -1.081390625, \
   0, 0, 0, 1 \
  ); \
  void main(void) { \
   gl_FragColor = vec4( texture2D(YTexture,  vTextureCoord).x, texture2D(UTexture, vTextureCoord).x, texture2D(VTexture, vTextureCoord).x, 1) * YUV2RGB; \
  } \
");




var YUVWebGLCanvas = new Class({
  Extends  : WebGLCanvas,
  Binds : ['decode'],

  initialize : function(canvas, size) {
    this.canvas = canvas;
    this.canvas.width = size.w;
    this.canvas.height = size.h;
    this.fmt = 0;
  },

  resize : function (size) {
    if (this.size && this.size.w === size.w && this.size.h === size.h)
    return;
    YUVWebGLCanvas.parent.initialize.call(this, this.canvas, size);
  },

  onInitShaders: function() {
    this.program = new Program(this.gl);
    this.program.attach(new Shader(this.gl, vertexShaderScript));
    this.program.attach(new Shader(this.gl, fragmentShaderScript));
    this.program.link();
    this.program.use();
    this.vertexPositionAttribute = this.program.getAttributeLocation("aVertexPosition");
    this.gl.enableVertexAttribArray(this.vertexPositionAttribute);
    this.textureCoordAttribute = this.program.getAttributeLocation("aTextureCoord");
    this.gl.enableVertexAttribArray(this.textureCoordAttribute);
  },

  onInitTextures: function () {
    var gl = this.gl;
    this.YTexture = new Texture(this.gl, this.size, false);
    this.UTexture = new Texture(this.gl, this.size.getHalfSize(), false);
    this.VTexture = new Texture(this.gl, this.size.getHalfSize(), false);
  },

  onInitSceneTextures: function () {
    this.YTexture.bind(0, this.program, "YTexture");
    this.UTexture.bind(1, this.program, "UTexture");
    this.VTexture.bind(2, this.program, "VTexture");
  },

  fillYUVTextures: function(y, u, v) {
    this.YTexture.fill(y);
    this.UTexture.fill(u);
    this.VTexture.fill(v);
  },

  decode: function(buffer, width, height) {

    if (!buffer)
      return;
      
    this.resize(new Size(width, height));
    this.bindFrameBuffer();
    var lumaSize = width * height;
    var chromaSize = lumaSize >> 2;

    this.YTexture.fill(buffer.subarray(0, lumaSize));
    this.UTexture.fill(buffer.subarray(lumaSize, lumaSize + chromaSize));
    this.VTexture.fill(buffer.subarray(lumaSize + chromaSize, lumaSize + 2 * chromaSize));
    this.drawScene();
  },

  toString: function() {
    return "YUVCanvas Size: " + this.size;
  }
});





module.exports = YUVWebGLCanvas;


/***/ }),

/***/ "./app/utils/Size.js":
/*!***************************!*\
  !*** ./app/utils/Size.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Represents a 2-dimensional size value. 
 */

function Size(w, h) {
  this.w = w;
  this.h = h;
}

Size.prototype = {
  toString: function () {
    return "(" + this.w + ", " + this.h + ")";
  },
  getHalfSize: function() {
    return new Size(this.w >>> 1, this.h >>> 1);
  },
  length: function() {
    return this.w * this.h;
  }
}
module.exports = Size;

/***/ }),

/***/ "./app/utils/assert.js":
/*!*****************************!*\
  !*** ./app/utils/assert.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var error = __webpack_require__(/*! ./error */ "./app/utils/error.js");

function assert(condition, message) {
  if (!condition) {
    error(message);
  }
}


module.exports = assert;


/***/ }),

/***/ "./app/utils/error.js":
/*!****************************!*\
  !*** ./app/utils/error.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function error(message) {
  console.error(message);
  console.trace();
}

module.exports = error;


/***/ }),

/***/ "./app/utils/glUtils.js":
/*!******************************!*\
  !*** ./app/utils/glUtils.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Matrix = __webpack_require__(/*! sylvester.js */ "./node_modules/sylvester.js/lib/index.js").Matrix;
var Vector = __webpack_require__(/*! sylvester.js */ "./node_modules/sylvester.js/lib/index.js").Vector;
var $M     = Matrix.create;


// augment Sylvester some
Matrix.Translation = function (v)
{
  if (v.elements.length == 2) {
    var r = Matrix.I(3);
    r.elements[2][0] = v.elements[0];
    r.elements[2][1] = v.elements[1];
    return r;
  }

  if (v.elements.length == 3) {
    var r = Matrix.I(4);
    r.elements[0][3] = v.elements[0];
    r.elements[1][3] = v.elements[1];
    r.elements[2][3] = v.elements[2];
    return r;
  }

  throw "Invalid length for Translation";
}

Matrix.prototype.flatten = function ()
{
    var result = [];
    if (this.elements.length == 0)
        return [];


    for (var j = 0; j < this.elements[0].length; j++)
        for (var i = 0; i < this.elements.length; i++)
            result.push(this.elements[i][j]);
    return result;
}

Matrix.prototype.ensure4x4 = function()
{
    if (this.elements.length == 4 &&
        this.elements[0].length == 4)
        return this;

    if (this.elements.length > 4 ||
        this.elements[0].length > 4)
        return null;

    for (var i = 0; i < this.elements.length; i++) {
        for (var j = this.elements[i].length; j < 4; j++) {
            if (i == j)
                this.elements[i].push(1);
            else
                this.elements[i].push(0);
        }
    }

    for (var i = this.elements.length; i < 4; i++) {
        if (i == 0)
            this.elements.push([1, 0, 0, 0]);
        else if (i == 1)
            this.elements.push([0, 1, 0, 0]);
        else if (i == 2)
            this.elements.push([0, 0, 1, 0]);
        else if (i == 3)
            this.elements.push([0, 0, 0, 1]);
    }

    return this;
};


Vector.prototype.flatten = function ()
{
    return this.elements;
};



//
// gluPerspective
//
function makePerspective(fovy, aspect, znear, zfar)
{
    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
}

//
// glFrustum
//
function makeFrustum(left, right,
                     bottom, top,
                     znear, zfar)
{
    var X = 2*znear/(right-left);
    var Y = 2*znear/(top-bottom);
    var A = (right+left)/(right-left);
    var B = (top+bottom)/(top-bottom);
    var C = -(zfar+znear)/(zfar-znear);
    var D = -2*zfar*znear/(zfar-znear);

    return $M([[X, 0, A, 0],
               [0, Y, B, 0],
               [0, 0, C, D],
               [0, 0, -1, 0]]);
}

module.exports.makePerspective = makePerspective;



/***/ }),

/***/ "./node_modules/mout/lang/clone.js":
/*!*****************************************!*\
  !*** ./node_modules/mout/lang/clone.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var kindOf = __webpack_require__(/*! ./kindOf */ "./node_modules/mout/lang/kindOf.js");
var isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/mout/lang/isPlainObject.js");
var mixIn = __webpack_require__(/*! ../object/mixIn */ "./node_modules/mout/object/mixIn.js");

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;




/***/ }),

/***/ "./node_modules/mout/lang/createObject.js":
/*!************************************************!*\
  !*** ./node_modules/mout/lang/createObject.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mixIn = __webpack_require__(/*! ../object/mixIn */ "./node_modules/mout/object/mixIn.js");

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;




/***/ }),

/***/ "./node_modules/mout/lang/deepClone.js":
/*!*********************************************!*\
  !*** ./node_modules/mout/lang/deepClone.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var clone = __webpack_require__(/*! ./clone */ "./node_modules/mout/lang/clone.js");
var forOwn = __webpack_require__(/*! ../object/forOwn */ "./node_modules/mout/object/forOwn.js");
var kindOf = __webpack_require__(/*! ./kindOf */ "./node_modules/mout/lang/kindOf.js");
var isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/mout/lang/isPlainObject.js");

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;





/***/ }),

/***/ "./node_modules/mout/lang/isKind.js":
/*!******************************************!*\
  !*** ./node_modules/mout/lang/isKind.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var kindOf = __webpack_require__(/*! ./kindOf */ "./node_modules/mout/lang/kindOf.js");
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;



/***/ }),

/***/ "./node_modules/mout/lang/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/mout/lang/isObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKind = __webpack_require__(/*! ./isKind */ "./node_modules/mout/lang/isKind.js");
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;



/***/ }),

/***/ "./node_modules/mout/lang/isPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/mout/lang/isPlainObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;




/***/ }),

/***/ "./node_modules/mout/lang/kindOf.js":
/*!******************************************!*\
  !*** ./node_modules/mout/lang/kindOf.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {


    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
    }
    module.exports = kindOf;



/***/ }),

/***/ "./node_modules/mout/object/forIn.js":
/*!*******************************************!*\
  !*** ./node_modules/mout/object/forIn.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__(/*! ./hasOwn */ "./node_modules/mout/object/hasOwn.js");

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;




/***/ }),

/***/ "./node_modules/mout/object/forOwn.js":
/*!********************************************!*\
  !*** ./node_modules/mout/object/forOwn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__(/*! ./hasOwn */ "./node_modules/mout/object/hasOwn.js");
var forIn = __webpack_require__(/*! ./forIn */ "./node_modules/mout/object/forIn.js");

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;




/***/ }),

/***/ "./node_modules/mout/object/hasOwn.js":
/*!********************************************!*\
  !*** ./node_modules/mout/object/hasOwn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {



    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;




/***/ }),

/***/ "./node_modules/mout/object/merge.js":
/*!*******************************************!*\
  !*** ./node_modules/mout/object/merge.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__(/*! ./hasOwn */ "./node_modules/mout/object/hasOwn.js");
var deepClone = __webpack_require__(/*! ../lang/deepClone */ "./node_modules/mout/lang/deepClone.js");
var isObject = __webpack_require__(/*! ../lang/isObject */ "./node_modules/mout/lang/isObject.js");

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;




/***/ }),

/***/ "./node_modules/mout/object/mixIn.js":
/*!*******************************************!*\
  !*** ./node_modules/mout/object/mixIn.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOwn = __webpack_require__(/*! ./forOwn */ "./node_modules/mout/object/forOwn.js");

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;



/***/ }),

/***/ "./node_modules/sylvester.js/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/sylvester.js/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel

var global = (Function('return this'))();

exports.Vector = __webpack_require__(/*! ./vector */ "./node_modules/sylvester.js/lib/vector.js");
global.$V = exports.Vector.create;
exports.Matrix = __webpack_require__(/*! ./matrix */ "./node_modules/sylvester.js/lib/matrix.js");
global.$M = exports.Matrix.create;
exports.Line = __webpack_require__(/*! ./line */ "./node_modules/sylvester.js/lib/line.js");
global.$L = exports.Line.create;
exports.Plane = __webpack_require__(/*! ./plane */ "./node_modules/sylvester.js/lib/plane.js");
global.$P = exports.Plane.create;
exports.Line.Segment = __webpack_require__(/*! ./line.segment */ "./node_modules/sylvester.js/lib/line.segment.js");
exports.Sylvester = __webpack_require__(/*! ./sylvester */ "./node_modules/sylvester.js/lib/sylvester.js");


/***/ }),

/***/ "./node_modules/sylvester.js/lib/line.js":
/*!***********************************************!*\
  !*** ./node_modules/sylvester.js/lib/line.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel, James Coglan
var Vector = __webpack_require__(/*! ./vector */ "./node_modules/sylvester.js/lib/vector.js");
var Matrix = __webpack_require__(/*! ./matrix */ "./node_modules/sylvester.js/lib/matrix.js");
var Plane = __webpack_require__(/*! ./plane */ "./node_modules/sylvester.js/lib/plane.js");
var Sylvester = __webpack_require__(/*! ./sylvester */ "./node_modules/sylvester.js/lib/sylvester.js");

// Line class - depends on Vector, and some methods require Matrix and Plane.

function Line() {}
Line.prototype = {

  // Returns true if the argument occupies the same space as the line
  eql: function(line) {
    return (this.isParallelTo(line) && this.contains(line.anchor));
  },

  // Returns a copy of the line
  dup: function() {
    return Line.create(this.anchor, this.direction);
  },

  // Returns the result of translating the line by the given vector/array
  translate: function(vector) {
    var V = vector.elements || vector;
    return Line.create([
      this.anchor.elements[0] + V[0],
      this.anchor.elements[1] + V[1],
      this.anchor.elements[2] + (V[2] || 0)
    ], this.direction);
  },

  // Returns true if the line is parallel to the argument. Here, 'parallel to'
  // means that the argument's direction is either parallel or antiparallel to
  // the line's own direction. A line is parallel to a plane if the two do not
  // have a unique intersection.
  isParallelTo: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }
    var theta = this.direction.angleFrom(obj.direction);
    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);
  },

  // Returns the line's perpendicular distance from the argument,
  // which can be a point, a line or a plane
  distanceFrom: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }
    if (obj.direction) {
      // obj is a line
      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
      var N = this.direction.cross(obj.direction).toUnitVector().elements;
      var A = this.anchor.elements, B = obj.anchor.elements;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.elements || obj;
      var A = this.anchor.elements, D = this.direction.elements;
      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
      if (modPA === 0) return 0;
      // Assumes direction vector is normalized
      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
      var sin2 = 1 - cosTheta*cosTheta;
      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));
    }
  },

  // Returns true iff the argument is a point on the line, or if the argument
  // is a line segment lying within the receiver
  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var dist = this.distanceFrom(obj);
    return (dist !== null && dist <= Sylvester.precision);
  },

  // Returns the distance from the anchor of the given point. Negative values are
  // returned for points that are in the opposite direction to the line's direction from
  // the line's anchor point.
  positionOf: function(point) {
    if (!this.contains(point)) { return null; }
    var P = point.elements || point;
    var A = this.anchor.elements, D = this.direction.elements;
    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
  },

  // Returns true iff the line lies in the given plane
  liesIn: function(plane) {
    return plane.contains(this);
  },

  // Returns true iff the line has a unique point of intersection with the argument
  intersects: function(obj) {
    if (obj.normal) { return obj.intersects(this); }
    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);
  },

  // Returns the unique intersection point with the argument, if one exists
  intersectionWith: function(obj) {
    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }
    if (!this.intersects(obj)) { return null; }
    var P = this.anchor.elements, X = this.direction.elements,
        Q = obj.anchor.elements, Y = obj.direction.elements;
    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
    var XdotX = X1*X1 + X2*X2 + X3*X3;
    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
  },

  // Returns the point on the line that is closest to the given point or line/line segment
  pointClosestTo: function(obj) {
    if (obj.start && obj.end) {
      // obj is a line segment
      var P = obj.pointClosestTo(this);
      return (P === null) ? null : this.pointClosestTo(P);
    } else if (obj.direction) {
      // obj is a line
      if (this.intersects(obj)) { return this.intersectionWith(obj); }
      if (this.isParallelTo(obj)) { return null; }
      var D = this.direction.elements, E = obj.direction.elements;
      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
      // Create plane containing obj and the shared normal and intersect this with it
      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance
      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
      var P = Plane.create(obj.anchor, N);
      return P.intersectionWith(this);
    } else {
      // obj is a point
      var P = obj.elements || obj;
      if (this.contains(P)) { return Vector.create(P); }
      var A = this.anchor.elements, D = this.direction.elements;
      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
      var k = this.distanceFrom(P) / V.modulus();
      return Vector.create([
        P[0] + V.elements[0] * k,
        P[1] + V.elements[1] * k,
        (P[2] || 0) + V.elements[2] * k
      ]);
    }
  },

  // Returns a copy of the line rotated by t radians about the given line. Works by
  // finding the argument's closest point to this line's anchor point (call this C) and
  // rotating the anchor about C. Also rotates the line's direction about the argument's.
  // Be careful with this - the rotation axis' direction affects the outcome!
  rotate: function(t, line) {
    // If we're working in 2D
    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }
    var R = Matrix.Rotation(t, line.direction).elements;
    var C = line.pointClosestTo(this.anchor).elements;
    var A = this.anchor.elements, D = this.direction.elements;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Line.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
    ]);
  },

  // Returns a copy of the line with its direction vector reversed.
  // Useful when using lines for rotations.
  reverse: function() {
    return Line.create(this.anchor, this.direction.x(-1));
  },

  // Returns the line's reflection in the given point or line
  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.elements, D = this.direction.elements;
      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
      var newA = this.anchor.reflectionIn(obj).elements;
      // Add the line's direction vector to its anchor, then mirror that in the plane
      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;
      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
      return Line.create(newA, newD);
    } else if (obj.direction) {
      // obj is a line - reflection obtained by rotating PI radians about obj
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point - just reflect the line's anchor in it
      var P = obj.elements || obj;
      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
    }
  },

  // Set the line's anchor point and direction.
  setVectors: function(anchor, direction) {
    // Need to do this so that line's properties are not
    // references to the arguments passed in
    anchor = Vector.create(anchor);
    direction = Vector.create(direction);
    if (anchor.elements.length == 2) {anchor.elements.push(0); }
    if (direction.elements.length == 2) { direction.elements.push(0); }
    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }
    var mod = direction.modulus();
    if (mod === 0) { return null; }
    this.anchor = anchor;
    this.direction = Vector.create([
      direction.elements[0] / mod,
      direction.elements[1] / mod,
      direction.elements[2] / mod
    ]);
    return this;
  }
};

// Constructor function
Line.create = function(anchor, direction) {
  var L = new Line();
  return L.setVectors(anchor, direction);
};

// Axes
Line.X = Line.create(Vector.Zero(3), Vector.i);
Line.Y = Line.create(Vector.Zero(3), Vector.j);
Line.Z = Line.create(Vector.Zero(3), Vector.k);

module.exports = Line;


/***/ }),

/***/ "./node_modules/sylvester.js/lib/line.segment.js":
/*!*******************************************************!*\
  !*** ./node_modules/sylvester.js/lib/line.segment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel, James Coglan
// Line.Segment class - depends on Line and its dependencies.

var Line = __webpack_require__(/*! ./line */ "./node_modules/sylvester.js/lib/line.js");
var Vector = __webpack_require__(/*! ./vector */ "./node_modules/sylvester.js/lib/vector.js");

Line.Segment = function() {};
Line.Segment.prototype = {

  // Returns true iff the line segment is equal to the argument
  eql: function(segment) {
    return (this.start.eql(segment.start) && this.end.eql(segment.end)) ||
        (this.start.eql(segment.end) && this.end.eql(segment.start));
  },

  // Returns a copy of the line segment
  dup: function() {
    return Line.Segment.create(this.start, this.end);
  },

  // Returns the length of the line segment
  length: function() {
    var A = this.start.elements, B = this.end.elements;
    var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];
    return Math.sqrt(C1*C1 + C2*C2 + C3*C3);
  },

  // Returns the line segment as a vector equal to its
  // end point relative to its endpoint
  toVector: function() {
    var A = this.start.elements, B = this.end.elements;
    return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);
  },

  // Returns the segment's midpoint as a vector
  midpoint: function() {
    var A = this.start.elements, B = this.end.elements;
    return Vector.create([(B[0] + A[0])/2, (B[1] + A[1])/2, (B[2] + A[2])/2]);
  },

  // Returns the plane that bisects the segment
  bisectingPlane: function() {
    return Plane.create(this.midpoint(), this.toVector());
  },

  // Returns the result of translating the line by the given vector/array
  translate: function(vector) {
    var V = vector.elements || vector;
    var S = this.start.elements, E = this.end.elements;
    return Line.Segment.create(
      [S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)],
      [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]
    );
  },

  // Returns true iff the line segment is parallel to the argument. It simply forwards
  // the method call onto its line property.
  isParallelTo: function(obj) {
    return this.line.isParallelTo(obj);
  },

  // Returns the distance between the argument and the line segment's closest point to the argument
  distanceFrom: function(obj) {
    var P = this.pointClosestTo(obj);
    return (P === null) ? null : P.distanceFrom(obj);
  },

  // Returns true iff the given point lies on the segment
  contains: function(obj) {
    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }
    var P = (obj.elements || obj).slice();
    if (P.length == 2) { P.push(0); }
    if (this.start.eql(P)) { return true; }
    var S = this.start.elements;
    var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);
    var vect = this.toVector();
    return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();
  },

  // Returns true iff the line segment intersects the argument
  intersects: function(obj) {
    return (this.intersectionWith(obj) !== null);
  },

  // Returns the unique point of intersection with the argument
  intersectionWith: function(obj) {
    if (!this.line.intersects(obj)) { return null; }
    var P = this.line.intersectionWith(obj);
    return (this.contains(P) ? P : null);
  },

  // Returns the point on the line segment closest to the given object
  pointClosestTo: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var V = this.line.intersectionWith(obj);
      if (V === null) { return null; }
      return this.pointClosestTo(V);
    } else {
      // obj is a line (segment) or point
      var P = this.line.pointClosestTo(obj);
      if (P === null) { return null; }
      if (this.contains(P)) { return P; }
      return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();
    }
  },

  // Set the start and end-points of the segment
  setPoints: function(startPoint, endPoint) {
    startPoint = Vector.create(startPoint).to3D();
    endPoint = Vector.create(endPoint).to3D();
    if (startPoint === null || endPoint === null) { return null; }
    this.line = Line.create(startPoint, endPoint.subtract(startPoint));
    this.start = startPoint;
    this.end = endPoint;
    return this;
  }
};

// Constructor function
Line.Segment.create = function(v1, v2) {
  var S = new Line.Segment();
  return S.setPoints(v1, v2);
};

module.exports = Line.Segment;


/***/ }),

/***/ "./node_modules/sylvester.js/lib/matrix.js":
/*!*************************************************!*\
  !*** ./node_modules/sylvester.js/lib/matrix.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel, James Coglan
// Matrix class - depends on Vector.

var Sylvester = __webpack_require__(/*! ./sylvester */ "./node_modules/sylvester.js/lib/sylvester.js");
var Vector = __webpack_require__(/*! ./vector */ "./node_modules/sylvester.js/lib/vector.js");

// augment a matrix M with identity rows/cols
function identSize(M, m, n, k) {
    var e = M.elements;
    var i = k - 1;

    while(i--) {
	var row = [];
	
	for(var j = 0; j < n; j++)
	    row.push(j == i ? 1 : 0);
	
        e.unshift(row);
    }
    
    for(var i = k - 1; i < m; i++) {
        while(e[i].length < n)
            e[i].unshift(0);
    }

    return $M(e);
}

function pca(X) {
    var Sigma = X.transpose().x(X).x(1 / X.rows());
    var svd = Sigma.svd();
    return {U: svd.U, S: svd.S};
}

// singular value decomposition in pure javascript
function svdJs() {
    var A = this;
    var V = Matrix.I(A.rows());
    var S = A.transpose();
    var U = Matrix.I(A.cols());
    var err = Number.MAX_VALUE;
    var i = 0;
    var maxLoop = 100;

    while(err > 2.2737e-13 && i < maxLoop) {
        var qr = S.transpose().qrJs();
        S = qr.R;
        V = V.x(qr.Q);
        qr = S.transpose().qrJs();
        U = U.x(qr.Q);
        S = qr.R;

        var e = S.triu(1).unroll().norm();
        var f = S.diagonal().norm();

        if(f == 0)
            f = 1;

        err = e / f;

        i++;
    }

    var ss = S.diagonal();
    var s = [];

    for(var i = 1; i <= ss.cols(); i++) {
        var ssn = ss.e(i);
        s.push(Math.abs(ssn));

        if(ssn < 0) {
            for(var j = 0; j < U.rows(); j++) {
                V.elements[j][i - 1] = -(V.elements[j][i - 1]);
            }
        }
    }

    return {U: U, S: $V(s).toDiagonalMatrix(), V: V};
}



// QR decomposition in pure javascript
function qrJs() {
    var m = this.rows();
    var n = this.cols();
    var Q = Matrix.I(m);
    var A = this;
    
    for(var k = 1; k < Math.min(m, n); k++) {
	var ak = A.slice(k, 0, k, k).col(1);
	var oneZero = [1];
	
	while(oneZero.length <=  m - k)
	    oneZero.push(0);
	
	oneZero = $V(oneZero);
	var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));
	var Vk = $M(vk);
	var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));
	var Qk = identSize(Hk, m, n, k);
	A = Qk.x(A);
	// slow way to compute Q
	Q = Q.x(Qk);
    }
    
    return {Q: Q, R: A};
}




function Matrix() {}
Matrix.prototype = {
    // solve a system of linear equations (work in progress)
    solve: function(b) {
	var lu = this.lu();
	b = lu.P.x(b);
	var y = lu.L.forwardSubstitute(b);
	var x = lu.U.backSubstitute(y);
	return lu.P.x(x);
	//return this.inv().x(b);
    },

    // project a matrix onto a lower dim
    pcaProject: function(k, U) {
	var U = U || pca(this).U;
	var Ureduce= U.slice(1, U.rows(), 1, k);
	return {Z: this.x(Ureduce), U: U};
    },

    // recover a matrix to a higher dimension
    pcaRecover: function(U) {
	var k = this.cols();
	var Ureduce = U.slice(1, U.rows(), 1, k);
	return this.x(Ureduce.transpose());
    },    

    // grab the upper triangular part of the matrix
    triu: function(k) {
	if(!k)
	    k = 0;
	
	return this.map(function(x, i, j) {
	    return j - i >= k ? x : 0;
	});
    },

    // unroll a matrix into a vector
    unroll: function() {
	var v = [];
	
	for(var i = 1; i <= this.cols(); i++) {
	    for(var j = 1; j <= this.rows(); j++) {
		v.push(this.e(j, i));
	    }
	}

	return $V(v);
    },

    // return a sub-block of the matrix
    slice: function(startRow, endRow, startCol, endCol) {
	var x = [];
	
	if(endRow == 0)
	    endRow = this.rows();
	
	if(endCol == 0)
	    endCol = this.cols();

	for(i = startRow; i <= endRow; i++) {
	    var row = [];

	    for(j = startCol; j <= endCol; j++) {
		row.push(this.e(i, j));
	    }

	    x.push(row);
	}

	return $M(x);
    },

    // Returns element (i,j) of the matrix
    e: function(i,j) {
	if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) { return null; }
	return this.elements[i - 1][j - 1];
    },

    // Returns row k of the matrix as a vector
    row: function(i) {
	if (i > this.elements.length) { return null; }
	return $V(this.elements[i - 1]);
    },

    // Returns column k of the matrix as a vector
    col: function(j) {
	if (j > this.elements[0].length) { return null; }
	var col = [], n = this.elements.length;
	for (var i = 0; i < n; i++) { col.push(this.elements[i][j - 1]); }
	return $V(col);
    },

    // Returns the number of rows/columns the matrix has
    dimensions: function() {
	return {rows: this.elements.length, cols: this.elements[0].length};
    },

    // Returns the number of rows in the matrix
    rows: function() {
	return this.elements.length;
    },

    // Returns the number of columns in the matrix
    cols: function() {
	return this.elements[0].length;
    },

    approxEql: function(matrix) {
	return this.eql(matrix, Sylvester.approxPrecision);
    },

    // Returns true iff the matrix is equal to the argument. You can supply
    // a vector as the argument, in which case the receiver must be a
    // one-column matrix equal to the vector.
    eql: function(matrix, precision) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	if (this.elements.length != M.length ||
            this.elements[0].length != M[0].length) { return false; }
	var i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) { j = nj;
		      while (j--) {
			  if (Math.abs(this.elements[i][j] - M[i][j]) > (precision || Sylvester.precision)) { return false; }
		      }
		    }
	return true;
    },

    // Returns a copy of the matrix
    dup: function() {
	return Matrix.create(this.elements);
    },

    // Maps the matrix to another matrix (of the same dimensions) according to the given function
    map: function(fn) {
    var els = [], i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) { j = nj;
		      els[i] = [];
		      while (j--) {
			  els[i][j] = fn(this.elements[i][j], i + 1, j + 1);
		      }
		    }
	return Matrix.create(els);
    },

    // Returns true iff the argument has the same dimensions as the matrix
    isSameSizeAs: function(matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	return (this.elements.length == M.length &&
		this.elements[0].length == M[0].length);
    },

    // Returns the result of adding the argument to the matrix
    add: function(matrix) {
	if(typeof(matrix) == 'number') {
	    return this.map(function(x, i, j) { return x + matrix});
	} else {
	    var M = matrix.elements || matrix;
	    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	    if (!this.isSameSizeAs(M)) { return null; }
	    return this.map(function(x, i, j) { return x + M[i - 1][j - 1]; });
	}
    },

    // Returns the result of subtracting the argument from the matrix
    subtract: function(matrix) {
	if(typeof(matrix) == 'number') {
	    return this.map(function(x, i, j) { return x - matrix});
	} else {
	    var M = matrix.elements || matrix;
	    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	    if (!this.isSameSizeAs(M)) { return null; }
	    return this.map(function(x, i, j) { return x - M[i - 1][j - 1]; });
	}
    },

    // Returns true iff the matrix can multiply the argument from the left
    canMultiplyFromLeft: function(matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	// this.columns should equal matrix.rows
	return (this.elements[0].length == M.length);
    },

    // Returns the result of a multiplication-style operation the matrix from the right by the argument.
    // If the argument is a scalar then just operate on all the elements. If the argument is
    // a vector, a vector is returned, which saves you having to remember calling
    // col(1) on the result.
    mulOp: function(matrix, op) {
	if (!matrix.elements) {
	    return this.map(function(x) { return op(x, matrix); });
	}

	var returnVector = matrix.modulus ? true : false;
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == 'undefined') 
	    M = Matrix.create(M).elements;
	if (!this.canMultiplyFromLeft(M)) 
	    return null; 
	var e = this.elements, rowThis, rowElem, elements = [],
        sum, m = e.length, n = M[0].length, o = e[0].length, i = m, j, k;

	while (i--) {
            rowElem = [];
            rowThis = e[i];
            j = n;

            while (j--) {
		sum = 0;
		k = o;

		while (k--) {
                    sum += op(rowThis[k], M[k][j]);
		}

		rowElem[j] = sum;
            }

            elements[i] = rowElem;
	}

	var M = Matrix.create(elements);
	return returnVector ? M.col(1) : M;
    },

    // Returns the result of dividing the matrix from the right by the argument.
    // If the argument is a scalar then just divide all the elements. If the argument is
    // a vector, a vector is returned, which saves you having to remember calling
    // col(1) on the result.
    div: function(matrix) {
	return this.mulOp(matrix, function(x, y) { return x / y});
    },

    // Returns the result of multiplying the matrix from the right by the argument.
    // If the argument is a scalar then just multiply all the elements. If the argument is
    // a vector, a vector is returned, which saves you having to remember calling
    // col(1) on the result.
    multiply: function(matrix) {
	return this.mulOp(matrix, function(x, y) { return x * y});
    },

    x: function(matrix) { return this.multiply(matrix); },

    elementMultiply: function(v) {
        return this.map(function(k, i, j) {
            return v.e(i, j) * k;
        });
    },

    // sum all elements in the matrix
    sum: function() {
        var sum = 0;

        this.map(function(x) { sum += x;});

        return sum;
    },

    // Returns a Vector of each colum averaged.
    mean: function() {
      var dim = this.dimensions();
      var r = [];
      for (var i = 1; i <= dim.cols; i++) {
        r.push(this.col(i).sum() / dim.rows);
      }
      return $V(r);
    },

    column: function(n) {
	return this.col(n);
    },

    // element-wise log
    log: function() {
	return this.map(function(x) { return Math.log(x); });
    },

    // Returns a submatrix taken from the matrix
    // Argument order is: start row, start col, nrows, ncols
    // Element selection wraps if the required index is outside the matrix's bounds, so you could
    // use this to perform row/column cycling or copy-augmenting.
    minor: function(a, b, c, d) {
	var elements = [], ni = c, i, nj, j;
	var rows = this.elements.length, cols = this.elements[0].length;
	while (ni--) {
	    i = c - ni - 1;
	    elements[i] = [];
	    nj = d;
	    while (nj--) {
		j = d - nj - 1;
		elements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];
	    }
	}
	return Matrix.create(elements);
    },

    // Returns the transpose of the matrix
    transpose: function() {
    var rows = this.elements.length, i, cols = this.elements[0].length, j;
	var elements = [], i = cols;
	while (i--) {
	    j = rows;
	    elements[i] = [];
	    while (j--) {
		elements[i][j] = this.elements[j][i];
	    }
	}
	return Matrix.create(elements);
    },

    // Returns true iff the matrix is square
    isSquare: function() {
	return (this.elements.length == this.elements[0].length);
    },

    // Returns the (absolute) largest element of the matrix
    max: function() {
	var m = 0, i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) {
	    j = nj;
	    while (j--) {
		if (Math.abs(this.elements[i][j]) > Math.abs(m)) { m = this.elements[i][j]; }
	    }
	}
	return m;
    },

    // Returns the indeces of the first match found by reading row-by-row from left to right
    indexOf: function(x) {
	var index = null, ni = this.elements.length, i, nj = this.elements[0].length, j;
	for (i = 0; i < ni; i++) {
	    for (j = 0; j < nj; j++) {
		if (this.elements[i][j] == x) { return {i: i + 1, j: j + 1}; }
	    }
	}
	return null;
    },

    // If the matrix is square, returns the diagonal elements as a vector.
    // Otherwise, returns null.
    diagonal: function() {
	if (!this.isSquare) { return null; }
	var els = [], n = this.elements.length;
	for (var i = 0; i < n; i++) {
	    els.push(this.elements[i][i]);
	}
	return $V(els);
    },

    // Make the matrix upper (right) triangular by Gaussian elimination.
    // This method only adds multiples of rows to other rows. No rows are
    // scaled up or switched, and the determinant is preserved.
    toRightTriangular: function() {
	var M = this.dup(), els;
	var n = this.elements.length, i, j, np = this.elements[0].length, p;
	for (i = 0; i < n; i++) {
	    if (M.elements[i][i] == 0) {
		for (j = i + 1; j < n; j++) {
		    if (M.elements[j][i] != 0) {
			els = [];
			for (p = 0; p < np; p++) { els.push(M.elements[i][p] + M.elements[j][p]); }
			M.elements[i] = els;
			break;
		    }
		}
	    }
	    if (M.elements[i][i] != 0) {
		for (j = i + 1; j < n; j++) {
		    var multiplier = M.elements[j][i] / M.elements[i][i];
		    els = [];
		    for (p = 0; p < np; p++) {
			// Elements with column numbers up to an including the number
			// of the row that we're subtracting can safely be set straight to
			// zero, since that's the point of this routine and it avoids having
			// to loop over and correct rounding errors later
			els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);
		    }
		    M.elements[j] = els;
		}
	    }
	}
	return M;
    },

    toUpperTriangular: function() { return this.toRightTriangular(); },

    // Returns the determinant for square matrices
    determinant: function() {
	if (!this.isSquare()) { return null; }
	if (this.cols == 1 && this.rows == 1) { return this.row(1); }
	if (this.cols == 0 && this.rows == 0) { return 1; }
	var M = this.toRightTriangular();
	var det = M.elements[0][0], n = M.elements.length;
	for (var i = 1; i < n; i++) {
	    det = det * M.elements[i][i];
	}
	return det;
    },
    det: function() { return this.determinant(); },

    // Returns true iff the matrix is singular
    isSingular: function() {
	return (this.isSquare() && this.determinant() === 0);
    },

    // Returns the trace for square matrices
    trace: function() {
	if (!this.isSquare()) { return null; }
	var tr = this.elements[0][0], n = this.elements.length;
	for (var i = 1; i < n; i++) {
	    tr += this.elements[i][i];
	}
	return tr;
    },

    tr: function() { return this.trace(); },

    // Returns the rank of the matrix
    rank: function() {
	var M = this.toRightTriangular(), rank = 0;
	var i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) {
	    j = nj;
	    while (j--) {
		if (Math.abs(M.elements[i][j]) > Sylvester.precision) { rank++; break; }
	    }
	}
	return rank;
    },

    rk: function() { return this.rank(); },

    // Returns the result of attaching the given argument to the right-hand side of the matrix
    augment: function(matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }
	var T = this.dup(), cols = T.elements[0].length;
	var i = T.elements.length, nj = M[0].length, j;
	if (i != M.length) { return null; }
	while (i--) {
	    j = nj;
	    while (j--) {
		T.elements[i][cols + j] = M[i][j];
	    }
	}
	return T;
    },

    // Returns the inverse (if one exists) using Gauss-Jordan
    inverse: function() {
	if (!this.isSquare() || this.isSingular()) { return null; }
	var n = this.elements.length, i = n, j;
	var M = this.augment(Matrix.I(n)).toRightTriangular();
	var np = M.elements[0].length, p, els, divisor;
	var inverse_elements = [], new_element;
	// Matrix is non-singular so there will be no zeros on the diagonal
	// Cycle through rows from last to first
	while (i--) {
	    // First, normalise diagonal elements to 1
	    els = [];
	    inverse_elements[i] = [];
	    divisor = M.elements[i][i];
	    for (p = 0; p < np; p++) {
        new_element = M.elements[i][p] / divisor;
		els.push(new_element);
		// Shuffle off the current row of the right hand side into the results
		// array as it will not be modified by later runs through this loop
		if (p >= n) { inverse_elements[i].push(new_element); }
	    }
	    M.elements[i] = els;
	    // Then, subtract this row from those above it to
	    // give the identity matrix on the left hand side
	    j = i;
	    while (j--) {
		els = [];
		for (p = 0; p < np; p++) {
		    els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);
		}
		M.elements[j] = els;
	    }
	}
	return Matrix.create(inverse_elements);
    },

    inv: function() { return this.inverse(); },

    // Returns the result of rounding all the elements
    round: function() {
	return this.map(function(x) { return Math.round(x); });
    },

    // Returns a copy of the matrix with elements set to the given value if they
    // differ from it by less than Sylvester.precision
    snapTo: function(x) {
	return this.map(function(p) {
	    return (Math.abs(p - x) <= Sylvester.precision) ? x : p;
	});
    },

    // Returns a string representation of the matrix
    inspect: function() {
	var matrix_rows = [];
	var n = this.elements.length;
	for (var i = 0; i < n; i++) {
	    matrix_rows.push($V(this.elements[i]).inspect());
	}
	return matrix_rows.join('\n');
    },

    // Returns a array representation of the matrix
    toArray: function() {
    	var matrix_rows = [];
    	var n = this.elements.length;
    	for (var i = 0; i < n; i++) {
        matrix_rows.push(this.elements[i]);
    	}
      return matrix_rows;
    },


    // Set the matrix's elements from an array. If the argument passed
    // is a vector, the resulting matrix will be a single column.
    setElements: function(els) {
	var i, j, elements = els.elements || els;
	if (typeof(elements[0][0]) != 'undefined') {
	    i = elements.length;
	    this.elements = [];
	    while (i--) {
		j = elements[i].length;
		this.elements[i] = [];
		while (j--) {
		    this.elements[i][j] = elements[i][j];
		}
	    }
	    return this;
	}
	var n = elements.length;
	this.elements = [];
	for (i = 0; i < n; i++) {
	    this.elements.push([elements[i]]);
	}
	return this;
    },

    // return the indexes of the columns with the largest value
    // for each row
    maxColumnIndexes: function() {
	var maxes = [];

	for(var i = 1; i <= this.rows(); i++) {
	    var max = null;
	    var maxIndex = -1;

	    for(var j = 1; j <= this.cols(); j++) {
		if(max === null || this.e(i, j) > max) {
		    max = this.e(i, j);
		    maxIndex = j;
		}
	    }

	    maxes.push(maxIndex);
	}

	return $V(maxes);
    },

    // return the largest values in each row
    maxColumns: function() {
	var maxes = [];

	for(var i = 1; i <= this.rows(); i++) {
	    var max = null;

	    for(var j = 1; j <= this.cols(); j++) {
		if(max === null || this.e(i, j) > max) {
		    max = this.e(i, j);
		}
	    }

	    maxes.push(max);
	}

	return $V(maxes);
    },

    // return the indexes of the columns with the smallest values
    // for each row
    minColumnIndexes: function() {
	var mins = [];

	for(var i = 1; i <= this.rows(); i++) {
	    var min = null;
	    var minIndex = -1;

	    for(var j = 1; j <= this.cols(); j++) {
		if(min === null || this.e(i, j) < min) {
		    min = this.e(i, j);
		    minIndex = j;
		}
	    }

	    mins.push(minIndex);
	}

	return $V(mins);
    },

    // return the smallest values in each row
    minColumns: function() {
	var mins = [];

	for(var i = 1; i <= this.rows(); i++) {
	    var min = null;

	    for(var j = 1; j <= this.cols(); j++) {
		if(min === null || this.e(i, j) < min) {
		    min = this.e(i, j);
		}
	    }

	    mins.push(min);
	}

	return $V(mins);
    },
    
    // perorm a partial pivot on the matrix. essentially move the largest
    // row below-or-including the pivot and replace the pivot's row with it.
    // a pivot matrix is returned so multiplication can perform the transform.
    partialPivot: function(k, j, P, A, L) {
	var maxIndex = 0;
	var maxValue = 0;

	for(var i = k; i <= A.rows(); i++) {
	    if(Math.abs(A.e(i, j)) > maxValue) {
		maxValue = Math.abs(A.e(k, j));
		maxIndex = i;
	    }
	}

	if(maxIndex != k) {
	    var tmp = A.elements[k - 1];
	    A.elements[k - 1] = A.elements[maxIndex - 1];
	    A.elements[maxIndex - 1] = tmp;
	    
	    P.elements[k - 1][k - 1] = 0;
	    P.elements[k - 1][maxIndex - 1] = 1;
	    P.elements[maxIndex - 1][maxIndex - 1] = 0;
	    P.elements[maxIndex - 1][k - 1] = 1;
	}
	
	return P;
    },

    // solve lower-triangular matrix * x = b via forward substitution
    forwardSubstitute: function(b) {
	var xa = [];

	for(var i = 1; i <= this.rows(); i++) {
	    var w = 0;

	    for(var j = 1; j < i; j++) {
		w += this.e(i, j) * xa[j - 1];
	    }

	    xa.push((b.e(i) - w) / this.e(i, i));
	}

	return $V(xa);
    },

    // solve an upper-triangular matrix * x = b via back substitution
    backSubstitute: function(b) {
	var xa = [];

	for(var i = this.rows(); i > 0; i--) {
	    var w = 0;

	    for(var j = this.cols(); j > i; j--) {
		w += this.e(i, j) * xa[this.rows() - j];
	    }

	    xa.push((b.e(i) - w) / this.e(i, i));
	}

	return $V(xa.reverse());
    },
    
    luJs: luJs,
    svdJs: svdJs,
    qrJs: qrJs,
};


var tolerance =  1.4901e-08;

// pure Javascript LU factorization
function luJs() {
    var A = this.dup();
    var L = Matrix.I(A.rows());
    var P = Matrix.I(A.rows());
    var U = Matrix.Zeros(A.rows(), A.cols());
    var p = 1;

    for(var k = 1; k <= Math.min(A.cols(), A.rows()); k++) {
	P = A.partialPivot(k, p, P, A, L);
	
	for(var i = k + 1; i <= A.rows(); i++) {
	    var l = A.e(i, p) / A.e(k, p);
	    L.elements[i - 1][k - 1] = l;
	    
	    for(var j = k + 1 ; j <= A.cols(); j++) {
		A.elements[i - 1][j - 1] -= A.e(k, j) * l;
	    }
	}
	
	for(var j = k; j <= A.cols(); j++) {
	    U.elements[k - 1][j - 1] = A.e(k, j);
	}

	if(p < A.cols())
	    p++;
    }    
    
    return {L: L, U: U, P: P};
}



Matrix.prototype.svd = svdJs;
Matrix.prototype.qr = qrJs;
Matrix.prototype.lu = luJs;

// Constructor function
Matrix.create = function(aElements) {
    var M = new Matrix().setElements(aElements);
    return M;
};

// Identity matrix of size n
Matrix.I = function(n) {
    var els = [], i = n, j;
    while (i--) {
	j = n;
	els[i] = [];
	while (j--) {
	    els[i][j] = (i == j) ? 1 : 0;
	}
    }
    return Matrix.create(els);
};

Matrix.loadFile = function(file) {
    var fs = __webpack_require__(/*! fs */ "fs");
    var contents = fs.readFileSync(file, 'utf-8');
    var matrix = [];

    var rowArray = contents.split('\n');
    for (var i = 0; i < rowArray.length; i++) {
	var d = rowArray[i].split(',');
	if (d.length > 1) {
	    matrix.push(d);
	}
    }

    var M = new Matrix();
    return M.setElements(matrix);
};

// Diagonal matrix - all off-diagonal elements are zero
Matrix.Diagonal = function(elements) {
    var i = elements.length;
    var M = Matrix.I(i);
    while (i--) {
	M.elements[i][i] = elements[i];
    }
    return M;
};

// Rotation matrix about some axis. If no axis is
// supplied, assume we're after a 2D transform
Matrix.Rotation = function(theta, a) {
    if (!a) {
	return Matrix.create([
	    [Math.cos(theta), -Math.sin(theta)],
	    [Math.sin(theta), Math.cos(theta)]
	]);
    }
    var axis = a.dup();
    if (axis.elements.length != 3) { return null; }
    var mod = axis.modulus();
    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;
    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
    // That proof rotates the co-ordinate system so theta
    // becomes -theta and sin becomes -sin here.
    return Matrix.create([
	[t * x * x + c, t * x * y - s * z, t * x * z + s * y],
	[t * x * y + s * z, t * y * y + c, t * y * z - s * x],
	[t * x * z - s * y, t * y * z + s * x, t * z * z + c]
    ]);
};

// Special case rotations
Matrix.RotationX = function(t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[1, 0, 0],
	[0, c, -s],
	[0, s, c]
    ]);
};

Matrix.RotationY = function(t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[c, 0, s],
	[0, 1, 0],
	[-s, 0, c]
    ]);
};

Matrix.RotationZ = function(t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[c, -s, 0],
	[s, c, 0],
	[0, 0, 1]
    ]);
};

// Random matrix of n rows, m columns
Matrix.Random = function(n, m) {
    if (arguments.length === 1) m = n;
    return Matrix.Zero(n, m).map(
	function() { return Math.random(); }
  );
};

Matrix.Fill = function(n, m, v) {
    if (arguments.length === 2) {
	v = m;
	m = n;
    }

    var els = [], i = n, j;

    while (i--) {
	j = m;
	els[i] = [];

	while (j--) {
	    els[i][j] = v;
	}
    }

    return Matrix.create(els);
};

// Matrix filled with zeros
Matrix.Zero = function(n, m) {
    return Matrix.Fill(n, m, 0);
};

// Matrix filled with zeros
Matrix.Zeros = function(n, m) {
    return Matrix.Zero(n, m);
};

// Matrix filled with ones
Matrix.One = function(n, m) {
    return Matrix.Fill(n, m, 1);
};

// Matrix filled with ones
Matrix.Ones = function(n, m) {
    return Matrix.One(n, m);
};

module.exports = Matrix;


/***/ }),

/***/ "./node_modules/sylvester.js/lib/plane.js":
/*!************************************************!*\
  !*** ./node_modules/sylvester.js/lib/plane.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel, James Coglan
// Plane class - depends on Vector. Some methods require Matrix and Line.
var Vector = __webpack_require__(/*! ./vector */ "./node_modules/sylvester.js/lib/vector.js");
var Matrix = __webpack_require__(/*! ./matrix */ "./node_modules/sylvester.js/lib/matrix.js");
var Line = __webpack_require__(/*! ./line */ "./node_modules/sylvester.js/lib/line.js");

var Sylvester = __webpack_require__(/*! ./sylvester */ "./node_modules/sylvester.js/lib/sylvester.js");

function Plane() {}
Plane.prototype = {

  // Returns true iff the plane occupies the same space as the argument
  eql: function(plane) {
    return (this.contains(plane.anchor) && this.isParallelTo(plane));
  },

  // Returns a copy of the plane
  dup: function() {
    return Plane.create(this.anchor, this.normal);
  },

  // Returns the result of translating the plane by the given vector
  translate: function(vector) {
    var V = vector.elements || vector;
    return Plane.create([
      this.anchor.elements[0] + V[0],
      this.anchor.elements[1] + V[1],
      this.anchor.elements[2] + (V[2] || 0)
    ], this.normal);
  },

  // Returns true iff the plane is parallel to the argument. Will return true
  // if the planes are equal, or if you give a line and it lies in the plane.
  isParallelTo: function(obj) {
    var theta;
    if (obj.normal) {
      // obj is a plane
      theta = this.normal.angleFrom(obj.normal);
      return (Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision);
    } else if (obj.direction) {
      // obj is a line
      return this.normal.isPerpendicularTo(obj.direction);
    }
    return null;
  },

  // Returns true iff the receiver is perpendicular to the argument
  isPerpendicularTo: function(plane) {
    var theta = this.normal.angleFrom(plane.normal);
    return (Math.abs(Math.PI/2 - theta) <= Sylvester.precision);
  },

  // Returns the plane's distance from the given object (point, line or plane)
  distanceFrom: function(obj) {
    if (this.intersects(obj) || this.contains(obj)) { return 0; }
    if (obj.anchor) {
      // obj is a plane or line
      var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;
      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
    } else {
      // obj is a point
      var P = obj.elements || obj;
      var A = this.anchor.elements, N = this.normal.elements;
      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
    }
  },

  // Returns true iff the plane contains the given point or line
  contains: function(obj) {
    if (obj.normal) { return null; }
    if (obj.direction) {
      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));
    } else {
      var P = obj.elements || obj;
      var A = this.anchor.elements, N = this.normal.elements;
      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
      return (diff <= Sylvester.precision);
    }
  },

  // Returns true iff the plane has a unique point/line of intersection with the argument
  intersects: function(obj) {
    if (typeof(obj.direction) == 'undefined' && typeof(obj.normal) == 'undefined') { return null; }
    return !this.isParallelTo(obj);
  },

  // Returns the unique intersection with the argument, if one exists. The result
  // will be a vector if a line is supplied, and a line if a plane is supplied.
  intersectionWith: function(obj) {
    if (!this.intersects(obj)) { return null; }
    if (obj.direction) {
      // obj is a line
      var A = obj.anchor.elements, D = obj.direction.elements,
          P = this.anchor.elements, N = this.normal.elements;
      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
    } else if (obj.normal) {
      // obj is a plane
      var direction = this.normal.cross(obj.normal).toUnitVector();
      // To find an anchor point, we find one co-ordinate that has a value
      // of zero somewhere on the intersection, and remember which one we picked
      var N = this.normal.elements, A = this.anchor.elements,
          O = obj.normal.elements, B = obj.anchor.elements;
      var solver = Matrix.Zero(2,2), i = 0;
      while (solver.isSingular()) {
        i++;
        solver = Matrix.create([
          [ N[i%3], N[(i+1)%3] ],
          [ O[i%3], O[(i+1)%3]  ]
        ]);
      }
      // Then we solve the simultaneous equations in the remaining dimensions
      var inverse = solver.inverse().elements;
      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
      var intersection = [
        inverse[0][0] * x + inverse[0][1] * y,
        inverse[1][0] * x + inverse[1][1] * y
      ];
      var anchor = [];
      for (var j = 1; j <= 3; j++) {
        // This formula picks the right element from intersection by
        // cycling depending on which element we set to zero above
        anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);
      }
      return Line.create(anchor, direction);
    }
  },

  // Returns the point in the plane closest to the given point
  pointClosestTo: function(point) {
    var P = point.elements || point;
    var A = this.anchor.elements, N = this.normal.elements;
    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
  },

  // Returns a copy of the plane, rotated by t radians about the given line
  // See notes on Line#rotate.
  rotate: function(t, line) {
    var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;
    var C = line.pointClosestTo(this.anchor).elements;
    var A = this.anchor.elements, N = this.normal.elements;
    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = A1 - C1, y = A2 - C2, z = A3 - C3;
    return Plane.create([
      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
    ], [
      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
    ]);
  },

  // Returns the reflection of the plane in the given point, line or plane.
  reflectionIn: function(obj) {
    if (obj.normal) {
      // obj is a plane
      var A = this.anchor.elements, N = this.normal.elements;
      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
      var newA = this.anchor.reflectionIn(obj).elements;
      // Add the plane's normal to its anchor, then mirror that in the other plane
      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;
      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
      return Plane.create(newA, newN);
    } else if (obj.direction) {
      // obj is a line
      return this.rotate(Math.PI, obj);
    } else {
      // obj is a point
      var P = obj.elements || obj;
      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
    }
  },

  // Sets the anchor point and normal to the plane. If three arguments are specified,
  // the normal is calculated by assuming the three points should lie in the same plane.
  // If only two are sepcified, the second is taken to be the normal. Normal vector is
  // normalised before storage.
  setVectors: function(anchor, v1, v2) {
    anchor = Vector.create(anchor);
    anchor = anchor.to3D(); if (anchor === null) { return null; }
    v1 = Vector.create(v1);
    v1 = v1.to3D(); if (v1 === null) { return null; }
    if (typeof(v2) == 'undefined') {
      v2 = null;
    } else {
      v2 = Vector.create(v2);
      v2 = v2.to3D(); if (v2 === null) { return null; }
    }
    var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];
    var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
    var normal, mod;
    if (v2 !== null) {
      var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];
      normal = Vector.create([
        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
      ]);
      mod = normal.modulus();
      if (mod === 0) { return null; }
      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);
    } else {
      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
      if (mod === 0) { return null; }
      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
    }
    this.anchor = anchor;
    this.normal = normal;
    return this;
  }
};

// Constructor function
Plane.create = function(anchor, v1, v2) {
  var P = new Plane();
  return P.setVectors(anchor, v1, v2);
};

// X-Y-Z planes
Plane.XY = Plane.create(Vector.Zero(3), Vector.k);
Plane.YZ = Plane.create(Vector.Zero(3), Vector.i);
Plane.ZX = Plane.create(Vector.Zero(3), Vector.j);
Plane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;

// Returns the plane containing the given points (can be arrays as
// well as vectors). If the points are not coplanar, returns null.
Plane.fromPoints = function(points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i < np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n > 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].elements; B = list[n-2].elements; C = list[n-3].elements;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n > 3) {
        // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.
        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals
        // to find which way the plane normal should point so that the points form an anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above misses out
  A = list[1].elements; B = list[0].elements; C = list[n-1].elements; D = list[n-2].elements;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
};

module.exports = Plane;


/***/ }),

/***/ "./node_modules/sylvester.js/lib/sylvester.js":
/*!****************************************************!*\
  !*** ./node_modules/sylvester.js/lib/sylvester.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright (c) 2011, Chris Umbel, James Coglan
// This file is required in order for any other classes to work. Some Vector methods work with the
// other Sylvester classes and are useless unless they are included. Other classes such as Line and
// Plane will not function at all without Vector being loaded first.           

Math.sign = function(x) {
    return x < 0 ? -1: 1;
}
                                              
var Sylvester = {
    precision: 1e-6,
    approxPrecision: 1e-5
};

module.exports = Sylvester;


/***/ }),

/***/ "./node_modules/sylvester.js/lib/vector.js":
/*!*************************************************!*\
  !*** ./node_modules/sylvester.js/lib/vector.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2011, Chris Umbel, James Coglan
// This file is required in order for any other classes to work. Some Vector methods work with the
// other Sylvester classes and are useless unless they are included. Other classes such as Line and
// Plane will not function at all without Vector being loaded first.

var Sylvester = __webpack_require__(/*! ./sylvester */ "./node_modules/sylvester.js/lib/sylvester.js"),
Matrix = __webpack_require__(/*! ./matrix */ "./node_modules/sylvester.js/lib/matrix.js");

function Vector() {}
Vector.prototype = {

    norm: function() {
	var n = this.elements.length;
	var sum = 0;

	while (n--) {
	    sum += Math.pow(this.elements[n], 2);
	}

	return Math.sqrt(sum);
    },

    // Returns element i of the vector
    e: function(i) {
      return (i < 1 || i > this.elements.length) ? null : this.elements[i - 1];
    },

    // Returns the number of rows/columns the vector has
    dimensions: function() {
      return {rows: 1, cols: this.elements.length};
    },

    // Returns the number of rows in the vector
    rows: function() {
      return 1;
    },

    // Returns the number of columns in the vector
    cols: function() {
      return this.elements.length;
    },

    // Returns the modulus ('length') of the vector
    modulus: function() {
      return Math.sqrt(this.dot(this));
    },

    // Returns true iff the vector is equal to the argument
    eql: function(vector) {
    	var n = this.elements.length;
    	var V = vector.elements || vector;
    	if (n != V.length) { return false; }
    	while (n--) {
    	    if (Math.abs(this.elements[n] - V[n]) > Sylvester.precision) { return false; }
    	}
    	return true;
    },

    // Returns a copy of the vector
    dup: function() {
	    return Vector.create(this.elements);
    },

    // Maps the vector to another vector according to the given function
    map: function(fn) {
	var elements = [];
	this.each(function(x, i) {
	    elements.push(fn(x, i));
	});
	return Vector.create(elements);
    },

    // Calls the iterator for each element of the vector in turn
    each: function(fn) {
	var n = this.elements.length;
	for (var i = 0; i < n; i++) {
	    fn(this.elements[i], i + 1);
	}
    },

    // Returns a new vector created by normalizing the receiver
    toUnitVector: function() {
	var r = this.modulus();
	if (r === 0) { return this.dup(); }
	return this.map(function(x) { return x / r; });
    },

    // Returns the angle between the vector and the argument (also a vector)
    angleFrom: function(vector) {
	var V = vector.elements || vector;
	var n = this.elements.length, k = n, i;
	if (n != V.length) { return null; }
	var dot = 0, mod1 = 0, mod2 = 0;
	// Work things out in parallel to save time
	this.each(function(x, i) {
	    dot += x * V[i - 1];
	    mod1 += x * x;
	    mod2 += V[i - 1] * V[i - 1];
	});
	mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
	if (mod1 * mod2 === 0) { return null; }
	var theta = dot / (mod1 * mod2);
	if (theta < -1) { theta = -1; }
	if (theta > 1) { theta = 1; }
	return Math.acos(theta);
    },

    // Returns true iff the vector is parallel to the argument
    isParallelTo: function(vector) {
	var angle = this.angleFrom(vector);
	return (angle === null) ? null : (angle <= Sylvester.precision);
    },

    // Returns true iff the vector is antiparallel to the argument
    isAntiparallelTo: function(vector) {
	var angle = this.angleFrom(vector);
	return (angle === null) ? null : (Math.abs(angle - Math.PI) <= Sylvester.precision);
    },

    // Returns true iff the vector is perpendicular to the argument
    isPerpendicularTo: function(vector) {
	var dot = this.dot(vector);
	return (dot === null) ? null : (Math.abs(dot) <= Sylvester.precision);
    },

    // Returns the result of adding the argument to the vector
    add: function(value) {
	var V = value.elements || value;

	if (this.elements.length != V.length) 
	    return this.map(function(v) { return v + value });
	else
	    return this.map(function(x, i) { return x + V[i - 1]; });
    },

    // Returns the result of subtracting the argument from the vector
    subtract: function(v) {
	if (typeof(v) == 'number')
	    return this.map(function(k) { return k - v; });

	var V = v.elements || v;
	if (this.elements.length != V.length) { return null; }
	return this.map(function(x, i) { return x - V[i - 1]; });
    },

    // Returns the result of multiplying the elements of the vector by the argument
    multiply: function(k) {
	return this.map(function(x) { return x * k; });
    },

    elementMultiply: function(v) {
	return this.map(function(k, i) {
	    return v.e(i) * k;
	});
    },

    sum: function() {
	var sum = 0;
	this.map(function(x) { sum += x;});
	return sum;
    },

    chomp: function(n) {
	var elements = [];

	for (var i = n; i < this.elements.length; i++) {
	    elements.push(this.elements[i]);
	}

	return Vector.create(elements);
    },

    top: function(n) {
	var elements = [];

	for (var i = 0; i < n; i++) {
	    elements.push(this.elements[i]);
	}

	return Vector.create(elements);
    },

    augment: function(elements) {
	var newElements = this.elements;

	for (var i = 0; i < elements.length; i++) {
	    newElements.push(elements[i]);
	}

	return Vector.create(newElements);
    },

    x: function(k) { return this.multiply(k); },

    log: function() {
	return Vector.log(this);
    },

    elementDivide: function(vector) {
	return this.map(function(v, i) {
	    return v / vector.e(i);
	});
    },

    product: function() {
	var p = 1;

	this.map(function(v) {
	    p *= v;
	});

	return p;
    },

    // Returns the scalar product of the vector with the argument
    // Both vectors must have equal dimensionality
    dot: function(vector) {
	var V = vector.elements || vector;
	var i, product = 0, n = this.elements.length;	
	if (n != V.length) { return null; }
	while (n--) { product += this.elements[n] * V[n]; }
	return product;
    },

    // Returns the vector product of the vector with the argument
    // Both vectors must have dimensionality 3
    cross: function(vector) {
	var B = vector.elements || vector;
	if (this.elements.length != 3 || B.length != 3) { return null; }
	var A = this.elements;
	return Vector.create([
	    (A[1] * B[2]) - (A[2] * B[1]),
	    (A[2] * B[0]) - (A[0] * B[2]),
	    (A[0] * B[1]) - (A[1] * B[0])
	]);
    },

    // Returns the (absolute) largest element of the vector
    max: function() {
	var m = 0, i = this.elements.length;
	while (i--) {
	    if (Math.abs(this.elements[i]) > Math.abs(m)) { m = this.elements[i]; }
	}
	return m;
    },


    maxIndex: function() {
	var m = 0, i = this.elements.length;
	var maxIndex = -1;

	while (i--) {
	    if (Math.abs(this.elements[i]) > Math.abs(m)) { 
		m = this.elements[i]; 
		maxIndex = i + 1;
	    }
	}

	return maxIndex;
    },


    // Returns the index of the first match found
    indexOf: function(x) {
	var index = null, n = this.elements.length;
	for (var i = 0; i < n; i++) {
	    if (index === null && this.elements[i] == x) {
		index = i + 1;
	    }
	}
	return index;
    },

    // Returns a diagonal matrix with the vector's elements as its diagonal elements
    toDiagonalMatrix: function() {
	return Matrix.Diagonal(this.elements);
    },

    // Returns the result of rounding the elements of the vector
    round: function() {
	return this.map(function(x) { return Math.round(x); });
    },

    // Transpose a Vector, return a 1xn Matrix
    transpose: function() {
	var rows = this.elements.length;
	var elements = [];

	for (var i = 0; i < rows; i++) {
	    elements.push([this.elements[i]]);
	}
	return Matrix.create(elements);
    },

    // Returns a copy of the vector with elements set to the given value if they
    // differ from it by less than Sylvester.precision
    snapTo: function(x) {
	return this.map(function(y) {
	    return (Math.abs(y - x) <= Sylvester.precision) ? x : y;
	});
    },

    // Returns the vector's distance from the argument, when considered as a point in space
    distanceFrom: function(obj) {
	if (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }
	var V = obj.elements || obj;
	if (V.length != this.elements.length) { return null; }
	var sum = 0, part;
	this.each(function(x, i) {
	    part = x - V[i - 1];
	    sum += part * part;
	});
	return Math.sqrt(sum);
    },

    // Returns true if the vector is point on the given line
    liesOn: function(line) {
	return line.contains(this);
    },

    // Return true iff the vector is a point in the given plane
    liesIn: function(plane) {
	return plane.contains(this);
    },

    // Rotates the vector about the given object. The object should be a
    // point if the vector is 2D, and a line if it is 3D. Be careful with line directions!
    rotate: function(t, obj) {
	var V, R = null, x, y, z;
	if (t.determinant) { R = t.elements; }
	switch (this.elements.length) {
	case 2:
            V = obj.elements || obj;
            if (V.length != 2) { return null; }
            if (!R) { R = Matrix.Rotation(t).elements; }
            x = this.elements[0] - V[0];
            y = this.elements[1] - V[1];
            return Vector.create([
		V[0] + R[0][0] * x + R[0][1] * y,
		V[1] + R[1][0] * x + R[1][1] * y
            ]);
            break;
	case 3:
            if (!obj.direction) { return null; }
            var C = obj.pointClosestTo(this).elements;
            if (!R) { R = Matrix.Rotation(t, obj.direction).elements; }
            x = this.elements[0] - C[0];
            y = this.elements[1] - C[1];
            z = this.elements[2] - C[2];
            return Vector.create([
		C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
		C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
		C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
            ]);
            break;
	default:
            return null;
	}
    },

    // Returns the result of reflecting the point in the given point, line or plane
    reflectionIn: function(obj) {
	if (obj.anchor) {
	    // obj is a plane or line
	    var P = this.elements.slice();
	    var C = obj.pointClosestTo(P).elements;
	    return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
	} else {
	    // obj is a point
	    var Q = obj.elements || obj;
	    if (this.elements.length != Q.length) { return null; }
	    return this.map(function(x, i) { return Q[i - 1] + (Q[i - 1] - x); });
	}
    },

    // Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added
    to3D: function() {
	var V = this.dup();
	switch (V.elements.length) {
	case 3: break;
	case 2: V.elements.push(0); break;
	default: return null;
	}
	return V;
    },

    // Returns a string representation of the vector
    inspect: function() {
	return '[' + this.elements.join(', ') + ']';
    },

    // Set vector's elements from an array
    setElements: function(els) {
	this.elements = (els.elements || els).slice();
	return this;
    }
};

// Constructor function
Vector.create = function(elements) {
    var V = new Vector();
    return V.setElements(elements);
};

// i, j, k unit vectors
Vector.i = Vector.create([1, 0, 0]);
Vector.j = Vector.create([0, 1, 0]);
Vector.k = Vector.create([0, 0, 1]);

// Random vector of size n
Vector.Random = function(n) {
    var elements = [];
    while (n--) { elements.push(Math.random()); }
    return Vector.create(elements);
};

Vector.Fill = function(n, v) {
    var elements = [];
    while (n--) { elements.push(v); }
    return Vector.create(elements);
};

// Vector filled with zeros
Vector.Zero = function(n) {
    return Vector.Fill(n, 0);
};

Vector.One = function(n) {
    return Vector.Fill(n, 1);
};

Vector.log = function(v) {
    return v.map(function(x) {
	return Math.log(x);
    });
};

module.exports = Vector;


/***/ }),

/***/ "./node_modules/uclass/implement.js":
/*!******************************************!*\
  !*** ./node_modules/uclass/implement.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var verbs = /^Implements|Extends|Binds$/

module.exports = function(ctx, obj){
  for(var key in obj) {
    if(key.match(verbs)) continue;
    if((typeof obj[key] == 'function') && obj[key].$static)
      ctx[key] = obj[key];
    else
      ctx.prototype[key] = obj[key];
  }
  return ctx;
}

/***/ }),

/***/ "./node_modules/uclass/uClass.js":
/*!***************************************!*\
  !*** ./node_modules/uclass/uClass.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwn = __webpack_require__(/*! mout/object/hasOwn */ "./node_modules/mout/object/hasOwn.js");
var create = __webpack_require__(/*! mout/lang/createObject */ "./node_modules/mout/lang/createObject.js");
var merge  = __webpack_require__(/*! mout/object/merge */ "./node_modules/mout/object/merge.js");
var kindOf = __webpack_require__(/*! mout/lang/kindOf */ "./node_modules/mout/lang/kindOf.js");
var mixIn  = __webpack_require__(/*! mout/object/mixIn */ "./node_modules/mout/object/mixIn.js");

var implement = __webpack_require__(/*! ./implement */ "./node_modules/uclass/implement.js");
var verbs = /^Implements|Extends|Binds$/




var uClass = function(proto){

  if(kindOf(proto) === "Function") proto = {initialize: proto};

  var superprime = proto.Extends;

  var constructor = (hasOwn(proto, "initialize")) ? proto.initialize : superprime ? superprime : function(){};



  var out = function() {
    var self = this;
      //autobinding takes place here
    if(proto.Binds) proto.Binds.forEach(function(f){
      var original = self[f];
      if(original)
        self[f] = mixIn(self[f].bind(self), original);
    });

      //clone non function/static properties to current instance
    for(var key in out.prototype) {
      var v = out.prototype[key], t = kindOf(v);

      if(key.match(verbs) || t === "Function" || t == "GeneratorFunction")
        continue;

      if(t == "Object")
        self[key] = merge({}, self[key]); //create(null, self[key]);
      else if(t == "Array")
        self[key] = v.slice(); //clone ??
      else
        self[key] = v;
    }

    if(proto.Implements)
      proto.Implements.forEach(function(Mixin){
        Mixin.call(self);
      });




    constructor.apply(this, arguments);
  }


  if (superprime) {
    // inherit from superprime
      var superproto = superprime.prototype;
      if(superproto.Binds)
        proto.Binds = (proto.Binds || []).concat(superproto.Binds);

      if(superproto.Implements)
        proto.Implements = (proto.Implements || []).concat(superproto.Implements);

      var cproto = out.prototype = create(superproto);
      // setting constructor.parent to superprime.prototype
      // because it's the shortest possible absolute reference
      out.parent = superproto;
      cproto.constructor = out

  }


 if(proto.Implements) {
    if (kindOf(proto.Implements) !== "Array")
      proto.Implements = [proto.Implements];
    proto.Implements.forEach(function(Mixin){
      implement(out, Mixin.prototype);
    });
  }

  implement(out, proto);
  if(proto.Binds)
     out.prototype.Binds = proto.Binds;
  if(proto.Implements)
     out.prototype.Implements = proto.Implements;

  return out;
};



module.exports = uClass;

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "ffi":
/*!**********************!*\
  !*** external "ffi" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ffi");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "ref":
/*!**********************!*\
  !*** external "ref" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("ref");

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXBwL1lNTG9nVXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL1lvdU1lU0RLLmpzIiwid2VicGFjazovLy8uL2FwcC9Zb3VNZVZpZGVvLnRzIiwid2VicGFjazovLy8uL2FwcC9jYW52YXMvQkdSQVdlYkdMQ2FudmFzLmpzIiwid2VicGFjazovLy8uL2FwcC9jYW52YXMvUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY2FudmFzL1NjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY2FudmFzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY2FudmFzL1RleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NhbnZhcy9XZWJHTENhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY2FudmFzL1lVVldlYkdMQ2FudmFzLmpzIiwid2VicGFjazovLy8uL2FwcC91dGlscy9TaXplLmpzIiwid2VicGFjazovLy8uL2FwcC91dGlscy9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3V0aWxzL2Vycm9yLmpzIiwid2VicGFjazovLy8uL2FwcC91dGlscy9nbFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb3V0L2xhbmcvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvbGFuZy9jcmVhdGVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvbGFuZy9kZWVwQ2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc0tpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvbGFuZy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW91dC9sYW5nL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvbGFuZy9raW5kT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2ZvckluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb3V0L29iamVjdC9mb3JPd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L2hhc093bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW91dC9vYmplY3QvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vdXQvb2JqZWN0L21peEluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIuanMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIuanMvbGliL2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bHZlc3Rlci5qcy9saWIvbGluZS5zZWdtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIuanMvbGliL21hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyLmpzL2xpYi9wbGFuZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyLmpzL2xpYi9zeWx2ZXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bHZlc3Rlci5qcy9saWIvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Y2xhc3MvaW1wbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Y2xhc3MvdUNsYXNzLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImV2ZW50c1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImZmaVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImZzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicmVmXCIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdURBQXVEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUN6SWEsbURBQW1EOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeHlDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7O0FBSUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7O0FBSUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxp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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDaCtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBLHdCOzs7Ozs7Ozs7OztBQ2pHQSxtQzs7Ozs7Ozs7Ozs7QUNBQSxnQzs7Ozs7Ozs7Ozs7QUNBQSwrQjs7Ozs7Ozs7Ozs7QUNBQSwrQjs7Ozs7Ozs7Ozs7QUNBQSxpQzs7Ozs7Ozs7Ozs7QUNBQSxnQyIsImZpbGUiOiJ5b3VtZXZpZGVvLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vYXBwL1lvdU1lVmlkZW8udHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICog5pel5b+X57qn5YirXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbnZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJESVNBQkxFRFwiXSA9IDBdID0gXCJESVNBQkxFRFwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJGQVRBTFwiXSA9IDFdID0gXCJGQVRBTFwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDEwXSA9IFwiRVJST1JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTklOR1wiXSA9IDIwXSA9IFwiV0FSTklOR1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gNDBdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gNTBdID0gXCJERUJVR1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJWRVJCT1NFXCJdID0gNjBdID0gXCJWRVJCT1NFXCI7XHJcbn0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XHJcbi8qKlxyXG4gKiDml6Xlv5flt6XlhbdcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgWU1Mb2dVdGlsc1xyXG4gKi9cclxudmFyIFlNTG9nVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBZTUxvZ1V0aWxzKCkge1xyXG4gICAgICAgIFlNTG9nVXRpbHMuX2xvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcclxuICAgIH1cclxuICAgIFlNTG9nVXRpbHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGxldmVsO1xyXG4gICAgfTtcclxuICAgIFlNTG9nVXRpbHMuZ2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5qC85byP5YyW5pe26Ze0XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgWU1Mb2dVdGlsc1xyXG4gICAgICovXHJcbiAgICBZTUxvZ1V0aWxzLmdldE5vd0Zvcm1hdERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHZhciBzZXBlcmF0b3IxID0gXCItXCI7XHJcbiAgICAgICAgdmFyIHNlcGVyYXRvcjIgPSBcIjpcIjtcclxuICAgICAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xyXG4gICAgICAgIHZhciBtb250aFN0ciA9IFwiXCI7XHJcbiAgICAgICAgdmFyIG51bURhdGUgPSBkYXRlLmdldERhdGUoKTtcclxuICAgICAgICB2YXIgc3RyRGF0ZSA9IFwiXCI7XHJcbiAgICAgICAgaWYgKG1vbnRoID49IDEgJiYgbW9udGggPD0gOSkge1xyXG4gICAgICAgICAgICBtb250aFN0ciA9IFwiMFwiICsgbW9udGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb250aFN0ciA9IFwiXCIgKyBtb250aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bURhdGUgPj0gMCAmJiBudW1EYXRlIDw9IDkpIHtcclxuICAgICAgICAgICAgc3RyRGF0ZSA9IFwiMFwiICsgbnVtRGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ckRhdGUgPSBcIlwiICsgbnVtRGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnRkYXRlID0gZGF0ZS5nZXRGdWxsWWVhcigpICsgc2VwZXJhdG9yMSArIG1vbnRoU3RyICsgc2VwZXJhdG9yMSArIHN0ckRhdGVcclxuICAgICAgICAgICAgKyBcIiBcIiArIGRhdGUuZ2V0SG91cnMoKSArIHNlcGVyYXRvcjIgKyBkYXRlLmdldE1pbnV0ZXMoKVxyXG4gICAgICAgICAgICArIHNlcGVyYXRvcjIgKyBkYXRlLmdldFNlY29uZHMoKSArIHNlcGVyYXRvcjIgKyBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50ZGF0ZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIElORk/nuqfliKvml6Xlv5dcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0gey4uLmFueVtdfSBsb2dQYXJhbXNcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKiBAbWVtYmVyb2YgWU1Mb2dVdGlsc1xyXG4gICAgICovXHJcbiAgICBZTUxvZ1V0aWxzLkxPR0kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvZ1BhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGxvZ1BhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoWU1Mb2dVdGlscy5fbG9nTGV2ZWwgPCBMb2dMZXZlbC5JTkZPKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIgJiYgcGFyc2VJbnQobmF2aWdhdG9yLmFwcFZlcnNpb24uc3BsaXQoXCI7XCIpWzFdLnJlcGxhY2UoL1sgXS9nLCBcIlwiKS5yZXBsYWNlKFwiTVNJRVwiLCBcIlwiKSkgPCAxMSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIllvdU1lVmlkZW8gLUlORk8tIFwiICsgdGhpcy5nZXROb3dGb3JtYXREYXRlKCkgKyBsb2dQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgW1wiWW91TWVWaWRlbyAtSU5GTy0gXCIsIHRoaXMuZ2V0Tm93Rm9ybWF0RGF0ZSgpXS5jb25jYXQobG9nUGFyYW1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV0FSTue6p+WIq+eahOaXpeW/l1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Li4uYW55W119IGxvZ1BhcmFtc1xyXG4gICAgICogQHJldHVybnNcclxuICAgICAqIEBtZW1iZXJvZiBZTUxvZ1V0aWxzXHJcbiAgICAgKi9cclxuICAgIFlNTG9nVXRpbHMuTE9HVyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbG9nUGFyYW1zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgbG9nUGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChZTUxvZ1V0aWxzLl9sb2dMZXZlbCA8IExvZ0xldmVsLldBUk5JTkcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIiAmJiBwYXJzZUludChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5zcGxpdChcIjtcIilbMV0ucmVwbGFjZSgvWyBdL2csIFwiXCIpLnJlcGxhY2UoXCJNU0lFXCIsIFwiXCIpKSA8IDExKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdU1lVmlkZW8gLVdBUk5JTkctIFwiICsgdGhpcy5nZXROb3dGb3JtYXREYXRlKCkgKyBsb2dQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIFtcIllvdU1lVmlkZW8gLVdBUk5JTkctIFwiLCB0aGlzLmdldE5vd0Zvcm1hdERhdGUoKV0uY29uY2F0KGxvZ1BhcmFtcykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVSUk9S57qn5Yir55qE5pel5b+XXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsuLi5hbnlbXX0gbG9nUGFyYW1zXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICogQG1lbWJlcm9mIFlNTG9nVXRpbHNcclxuICAgICAqL1xyXG4gICAgWU1Mb2dVdGlscy5MT0dFID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2dQYXJhbXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBsb2dQYXJhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFlNTG9nVXRpbHMuX2xvZ0xldmVsIDwgTG9nTGV2ZWwuRVJST1IpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIiAmJiBwYXJzZUludChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5zcGxpdChcIjtcIilbMV0ucmVwbGFjZSgvWyBdL2csIFwiXCIpLnJlcGxhY2UoXCJNU0lFXCIsIFwiXCIpKSA8IDExKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3VNZVZpZGVvIC1FUlJPUi0gXCIgKyB0aGlzLmdldE5vd0Zvcm1hdERhdGUoKSArIGxvZ1BhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIFtcIllvdU1lVmlkZW8gLUVSUk9SLSBcIiwgdGhpcy5nZXROb3dGb3JtYXREYXRlKCldLmNvbmNhdChsb2dQYXJhbXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgWU1Mb2dVdGlscy5fbG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4gICAgcmV0dXJuIFlNTG9nVXRpbHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuWU1Mb2dVdGlscyA9IFlNTG9nVXRpbHM7XHJcbiIsIlwidXNlIHN0cmljdFwiOy8v5ZCv55So5Lil5qC85qih5byP77yMRVM2IOeahOaooeWdl+iHquWKqOmHh+eUqOS4peagvOaooeW8j++8jOS4jeeuoeS9oOacieayoeacieWcqOaooeWdl+WktOmDqOWKoOS4ilwidXNlIHN0cmljdFwiO+OAglxyXG5cclxuY29uc3QgZmZpID0gcmVxdWlyZSgnZmZpJylcclxuY29uc3QgcmVmID0gcmVxdWlyZShcInJlZlwiKVxyXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XHJcbnZhciBwbGF0ID0gb3MucGxhdGZvcm0oKTtcclxudmFyIGFyY2ggPSBvcy5hcmNoKCk7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5cclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcbmNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG52YXIgQkdSQVdlYkdMQ2FudmFzID0gcmVxdWlyZSgnLi9jYW52YXMvQkdSQVdlYkdMQ2FudmFzJyk7XHJcbnZhciBXZWJHTENhbnZhcyA9IHJlcXVpcmUoJy4vY2FudmFzL1dlYkdMQ2FudmFzJyk7XHJcbnZhciBZVVZXZWJHTENhbnZhcyA9IHJlcXVpcmUoJy4vY2FudmFzL1lVVldlYkdMQ2FudmFzJyk7XHJcbnZhciBTaXplID0gcmVxdWlyZSgnLi91dGlscy9TaXplJyk7XHJcblxyXG5sZXQgbGliUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd5b3VtZV92b2ljZV9lbmdpbmUnLCAnbWFjb3MnLCAneW91bWVfdm9pY2VfZW5naW5lX21hY2QnKTtcclxuaWYgKHBsYXQgIT09IFwiZGFyd2luXCIpIHtcclxuICAgIHZhciBrZXJuZWwzMiA9IGZmaS5MaWJyYXJ5KFwia2VybmVsMzJcIiwge1xyXG4gICAgICAgICdTZXREbGxEaXJlY3RvcnlBJzogW1wiYm9vbFwiLCBbXCJzdHJpbmdcIl1dXHJcbiAgICB9KTtcclxuICAgIGlmIChhcmNoID09PSAneDY0Jykge1xyXG4gICAgICAgIGtlcm5lbDMyLlNldERsbERpcmVjdG9yeUEocGF0aC5qb2luKF9fZGlybmFtZSwgJ3lvdW1lX3ZvaWNlX2VuZ2luZScsICd4ODYtNjQnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtlcm5lbDMyLlNldERsbERpcmVjdG9yeUEocGF0aC5qb2luKF9fZGlybmFtZSwgJ3lvdW1lX3ZvaWNlX2VuZ2luZScsICd4ODYnKSk7XHJcbiAgICB9XHJcbiAgICBsaWJQYXRoID0gJ3lvdW1lX3ZvaWNlX2VuZ2luZSc7XHJcbn1cclxuXHJcbi8v5LuOY+W6k+S4reWvvOWHumpz5o6l5Y+jXHJcbnZhciBjRGVmaW5lcyA9IHtcclxuICAgIFwieW91bWVfaW5pdFwiOiBbJ2ludCcsIFsnc3RyaW5nJywgJ3N0cmluZycsICdpbnQnLCAnc3RyaW5nJ11dLFxyXG4gICAgXCJ5b3VtZV9zZXRFeHRlcm5hbElucHV0TW9kZVwiOiBbXCJ2b2lkXCIsIFsnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0QVZTdGF0aXN0aWNJbnRlcnZhbFwiOiBbXCJ2b2lkXCIsIFsnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRWaWRlb05ldFJlc29sdXRpb25cIjogWydpbnQnLCBbJ2ludCcsICdpbnQnXV0sXHJcbiAgICBcInlvdW1lX3NldFZpZGVvTG9jYWxSZXNvbHV0aW9uXCI6IFsnaW50JywgWydpbnQnLCAnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9nZXRDYk1lc3NhZ2UyXCI6IFsnY2hhciAqJywgW11dLFxyXG4gICAgXCJ5b3VtZV9mcmVlQ2JNZXNzYWdlMlwiOiBbJ3ZvaWQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfam9pbkNoYW5uZWxTaW5nbGVNb2RlXCI6IFsnaW50JywgWydzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddXSxcclxuICAgIFwieW91bWVfZ2V0U0RLVmVyc2lvblwiOiBbJ2ludCcsIFtdXSxcclxuICAgIFwieW91bWVfbGVhdmVDaGFubmVsQWxsXCI6IFsnaW50JywgW11dLFxyXG4gICAgXCJ5b3VtZV9zZXRUb2tlblwiOiBbJ3ZvaWQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfc2V0QXVkaW9RdWFsaXR5XCI6IFsndm9pZCcsIFsnaW50J11dLFxyXG4gICAgXCJ5b3VtZV91bkluaXRcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldFZvbHVtZVwiOiBbJ3ZvaWQnLCBbJ2ludCddXSxcclxuICAgIFwieW91bWVfZ2V0Vm9sdW1lXCI6IFsndWludCcsIFtdXSxcclxuICAgIFwieW91bWVfc2V0TWljcm9waG9uZU11dGVcIjogWyd2b2lkJywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9nZXRNaWNyb3Bob25lTXV0ZVwiOiBbJ2Jvb2wnLCBbXV0sXHJcbiAgICBcInlvdW1lX2dldFNwZWFrZXJNdXRlXCI6IFsnYm9vbCcsIFtdXSxcclxuICAgIFwieW91bWVfc2V0U3BlYWtlck11dGVcIjogWyd2b2lkJywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9zZXRPdGhlclNwZWFrZXJNdXRlXCI6IFsnaW50JywgWydzdHJpbmcnLCAnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0T3RoZXJNaWNNdXRlXCI6IFsnaW50JywgWydzdHJpbmcnLCAnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0TGlzdGVuT3RoZXJWb2ljZVwiOiBbJ2ludCcsIFsnc3RyaW5nJywgJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3NldExvZ0xldmVsXCI6IFsnaW50JywgWydpbnQnLCAnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRTZXJ2ZXJSZWdpb25cIjogWyd2b2lkJywgWydpbnQnLCAnc3RyaW5nJywgJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3N0YXJ0Q2FwdHVyZVwiOiBbJ2ludCcsIFtdXSxcclxuICAgIFwieW91bWVfc3RvcENhcHR1cmVcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldFRlc3RDb25maWdcIjogWyd2b2lkJywgWydpbnQnXV0sXHJcbiAgICBcInlvdW1lX3NldE91dHB1dFRvU3BlYWtlclwiOiBbJ2ludCcsIFsnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0QXV0b1NlbmRTdGF0dXNcIjogWyd2b2lkJywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9nZXRVc2VNb2JpbGVOZXR3b3JrRW5hYmxlZFwiOiBbJ2Jvb2wnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldFVzZU1vYmlsZU5ldHdvcmtFbmFibGVkXCI6IFsndm9pZCcsIFsnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0VXNlckxvZ1BhdGhcIjogWydpbnQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfcGxheUJhY2tncm91bmRNdXNpY1wiOiBbJ2ludCcsIFsnc3RyaW5nJywgJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3BhdXNlQmFja2dyb3VuZE11c2ljXCI6IFsnaW50JywgW11dLFxyXG4gICAgXCJ5b3VtZV9yZXN1bWVCYWNrZ3JvdW5kTXVzaWNcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3N0b3BCYWNrZ3JvdW5kTXVzaWNcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldEJhY2tncm91bmRNdXNpY1ZvbHVtZVwiOiBbJ2ludCcsIFsnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRIZWFkc2V0TW9uaXRvck9uXCI6IFsnaW50JywgWydib29sJywgJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3NldFJldmVyYkVuYWJsZWRcIjogWydpbnQnLCBbJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3NldFZhZENhbGxiYWNrRW5hYmxlZFwiOiBbJ2ludCcsIFsnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0TWljTGV2ZWxDYWxsYmFja1wiOiBbJ2ludCcsIFsnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRGYXJlbmRWb2ljZUxldmVsQ2FsbGJhY2tcIjogWydpbnQnLCBbJ2ludCddXSxcclxuICAgIFwieW91bWVfc2V0UmVsZWFzZU1pY1doZW5NdXRlXCI6IFsnaW50JywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9wYXVzZUNoYW5uZWxcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3Jlc3VtZUNoYW5uZWxcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldFJlY29yZGluZ1RpbWVNc1wiOiBbJ3ZvaWQnLCBbJ3VpbnQnXV0sXHJcbiAgICBcInlvdW1lX3NldFBsYXlpbmdUaW1lTXNcIjogWyd2b2lkJywgWyd1aW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRTZXJ2ZXJNb2RlXCI6IFsndm9pZCcsIFsnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9yZXF1ZXN0UmVzdEFwaVwiOiBbJ2ludCcsIFsnc3RyaW5nJywgJ3N0cmluZycsIHJlZi5yZWZUeXBlKCdpbnQnKV1dLFxyXG4gICAgXCJ5b3VtZV9nZXRDaGFubmVsVXNlckxpc3RcIjogWydpbnQnLCBbJ3N0cmluZycsICdpbnQnLCAnYm9vbCddXSxcclxuICAgIFwieW91bWVfc2V0VXNlclJvbGVcIjogWydpbnQnLCBbJ2ludCddXSxcclxuICAgIFwieW91bWVfZ2V0VXNlclJvbGVcIjogWydpbnQnLCBbXV0sXHJcbiAgICBcInlvdW1lX2lzQmFja2dyb3VuZE11c2ljUGxheWluZ1wiOiBbJ2Jvb2wnLCBbXV0sXHJcbiAgICBcInlvdW1lX2lzSW5pdGVkXCI6IFsnYm9vbCcsIFtdXSxcclxuICAgIFwieW91bWVfaXNJbkNoYW5uZWxcIjogWydib29sJywgWydzdHJpbmcnXV0sXHJcbiAgICBcInlvdW1lX3NlbmRNZXNzYWdlXCI6IFsnaW50JywgWydzdHJpbmcnLCAnc3RyaW5nJywgcmVmLnJlZlR5cGUoJ2ludCcpXV0sXHJcbiAgICBcInlvdW1lX2tpY2tPdGhlckZyb21DaGFubmVsXCI6IFsnaW50JywgWydzdHJpbmcnLCAnc3RyaW5nJywgJ2ludCddXSxcclxuICAgIFwieW91bWVfb3BlblZpZGVvRW5jb2RlclwiOiBbJ2ludCcsIFsnc3RyaW5nJ11dLFxyXG4gICAgXCJ5b3VtZV9pbnB1dEF1ZGlvRnJhbWVcIjogWydpbnQnLCBbcmVmLnJlZlR5cGUoJ3BvaW50ZXInKSwgJ2ludCcsICd1aW50NjQnXV0sXHJcbiAgICBcInlvdW1lX2lucHV0VmlkZW9GcmFtZVwiOiBbJ2ludCcsIFtyZWYucmVmVHlwZSgncG9pbnRlcicpLCAnaW50JywgJ2ludCcsICdpbnQnLCAnaW50JywgJ2ludCcsICdpbnQnLCAndWludDY0J11dLFxyXG4gICAgXCJ5b3VtZV9zdG9wSW5wdXRWaWRlb0ZyYW1lXCI6IFsnaW50JywgW11dLFxyXG4gICAgXCJ5b3VtZV9nZXRWaWRlb0ZyYW1lXCI6IFsnY2hhciAqJywgWydzdHJpbmcnLCByZWYucmVmVHlwZSgnaW50JyksIHJlZi5yZWZUeXBlKCdpbnQnKSwgcmVmLnJlZlR5cGUoJ2ludCcpXV0sXHJcbiAgICBcInlvdW1lX3NldFZpZGVvQ2FsbGJhY2tcIjogWydpbnQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfc2V0VmlkZW9GcHNcIjogWydpbnQnLCBbJ2ludCddXSxcclxuICAgIFwieW91bWVfc3dpdGNoQ2FtZXJhXCI6IFsnaW50JywgW11dLFxyXG4gICAgXCJ5b3VtZV9yZXNldENhbWVyYVwiOiBbJ2ludCcsIFtdXSxcclxuICAgIFwieW91bWVfc2V0Q2FwdHVyZUZyb250Q2FtZXJhRW5hYmxlXCI6IFsnaW50JywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9tYXNrVmlkZW9CeVVzZXJJZFwiOiBbJ2ludCcsIFsnc3RyaW5nJywgJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3NldEV4dGVybmFsSW5wdXRTYW1wbGVSYXRlXCI6IFsnaW50JywgWydpbnQnLCAnaW50J11dLFxyXG4gICAgXCJ5b3VtZV9zZXRWaWRlb05ldFJlc29sdXRpb25Gb3JTZWNvbmRcIjogWydpbnQnLCBbJ2ludCcsICdpbnQnXV0sXHJcbiAgICBcInlvdW1lX3NldFZpZGVvQ29kZUJpdHJhdGVGb3JTZWNvbmRcIjogWyd2b2lkJywgWyd1aW50JywgJ3VpbnQnXV0sXHJcbiAgICBcInlvdW1lX2dldEN1cnJlbnRWaWRlb0NvZGVCaXRyYXRlXCI6IFsndWludCcsIFtdXSxcclxuICAgIFwieW91bWVfc2V0VmlkZW9IYXJkd2FyZUNvZGVFbmFibGVcIjogWyd2b2lkJywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9nZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZVwiOiBbJ2Jvb2wnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldFZpZGVvTm9GcmFtZVRpbWVvdXRcIjogWyd2b2lkJywgWydpbnQnXV0sXHJcbiAgICBcInlvdW1lX3F1ZXJ5VXNlcnNWaWRlb0luZm9cIjogWydpbnQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfc2V0VXNlcnNWaWRlb0luZm9cIjogWydpbnQnLCBbJ3N0cmluZyddXSxcclxuICAgIFwieW91bWVfb3BlbkJlYXV0aWZ5XCI6IFsnaW50JywgWydib29sJ11dLFxyXG4gICAgXCJ5b3VtZV9iZWF1dGlmeUNoYW5nZWRcIjogWydpbnQnLCBbJ2RvdWJsZSddXSxcclxuICAgIFwieW91bWVfc3RyZXRjaEZhY2VcIjogWydpbnQnLCBbJ2Jvb2wnXV0sXHJcbiAgICBcInlvdW1lX3JlbGVhc2VNaWNTeW5jXCI6IFsnYm9vbCcsIFtdXSxcclxuICAgIFwieW91bWVfcmVzdW1lTWljU3luY1wiOiBbJ2Jvb2wnLCBbXV0sXHJcbiAgICBcInlvdW1lX3NldE1peFZpZGVvU2l6ZVwiOiBbJ3ZvaWQnLCBbJ2ludCcsICdpbnQnXV0sXHJcbiAgICBcInlvdW1lX2dldENhbWVyYUNvdW50XCI6IFsnaW50JywgW11dLFxyXG4gICAgXCJ5b3VtZV9nZXRDYW1lcmFOYW1lXCI6IFsnaW50JywgWydpbnQnLCByZWYucmVmVHlwZShyZWYudHlwZXMuY2hhcildXSxcclxuICAgIFwieW91bWVfc2V0T3BlbkNhbWVyYUlkXCI6IFsnaW50JywgWydpbnQnXV0sXHJcbiAgICBcInlvdW1lX2dldFZpZGVvRnJhbWVOZXdcIjogWydjaGFyIConLCBbJ3N0cmluZycsIHJlZi5yZWZUeXBlKCdpbnQnKSwgcmVmLnJlZlR5cGUoJ2ludCcpLCByZWYucmVmVHlwZSgnaW50JyksIHJlZi5yZWZUeXBlKCdpbnQnKV1dLFxyXG4gICAgXCJ5b3VtZV92aWRlb0VuZ2luZU1vZGVsRW5hYmxlZFwiOiBbJ3ZvaWQnLCBbJ2Jvb2wnXV0sXHJcbn1cclxuXHJcbnZhciB5b3VtZSA9IGZmaS5MaWJyYXJ5KGxpYlBhdGgsIGNEZWZpbmVzKTtcclxuXHJcbi8v6I635Y+W5byV5pOO5Zue6LCDXHJcblxyXG5mdW5jdGlvbiBHZXRNc2coKSB7XHJcbiAgICB2YXIgbXNnID0geW91bWUueW91bWVfZ2V0Q2JNZXNzYWdlMigpO1xyXG5cclxuICAgIHdoaWxlIChtc2cgIT0gbnVsbCAmJiBtc2cgIT0gXCJcIiAmJiBtc2cgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IHJlZi5yZWFkQ1N0cmluZyhtc2cpO1xyXG4gICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZShzdHIpO1xyXG4gICAgICAgIHZhciByZXN1bHRfb2JqID0gbmV3IE9iamVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgdHlwZSA9IGpzb24udHlwZTtcclxuICAgICAgICB2YXIgbWVtY2hhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IGpzb24uZXZlbnQ7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmouZXJyb3Jjb2RlID0ganNvbi5lcnJvcjtcclxuICAgICAgICAgICAgcmVzdWx0X29iai5jaGFubmVsaWQgPSBqc29uLmNoYW5uZWxpZDtcclxuICAgICAgICAgICAgcmVzdWx0X29iai5wYXJhbSA9IGpzb24ucGFyYW07XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX0lOSVRfT0sg5Yid5aeL5YyW5oiQ5YqfXHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9JTklUX09LJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9JTklUX0ZBSUxFRCAgU0RL5Yid5aeL5YyW5aSx6LSlXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9JTklUX0ZBSUxFRCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfSk9JTl9PSyAgIOi/m+WFpeivremfs+mikemBk+aIkOWKn1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfSk9JTl9PSycsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfSk9JTl9GQUlMRUQgICDov5vlhaXor63pn7PpopHpgZPlpLHotKVcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0pPSU5fRkFJTEVEJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9MRUFWRURfQUxMICAg6YCA5Ye65omA5pyJ6K+t6Z+z6aKR6YGT5a6M5oiQXHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9MRUFWRURfQUxMJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9QQVVTRUQgICDmmoLlgZzor63pn7PpopHpgZPlrozmiJBcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX1BBVVNFRCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfUkVTVU1FRCAgIOaBouWkjeivremfs+mikemBk+WujOaIkFxyXG4gICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfUkVTVU1FRCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfUkVDT05ORUNUSU5HICAg5pat572R5LqG77yM5q2j5Zyo6YeN6L+eXHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfUkVDT05ORUNUSU5HJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9SRUNPTk5FQ1RFRCAgIOaWree9kemHjei/nuaIkOWKn1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX1JFQ09OTkVDVEVEJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9SRUNfUEVSTUlTU0lPTl9TVEFUVVNcclxuICAgICAgICAgICAgICAgIC8v6YCa55+l5b2V6Z+z5p2D6ZmQ54q25oCB77yM5oiQ5Yqf6I635Y+W5p2D6ZmQ5pe26ZSZ6K+v56CB5Li6WU9VTUVfU1VDQ0VTU++8jOiOt+WPluWksei0peS4ullPVU1FX0VSUk9SX1JFQ19OT19QRVJNSVNTSU9O77yI5q2k5pe25LiN566h6bqm5YWL6aOObXV0ZeeKtuaAgeWmguS9le+8jOmDveayoeacieWjsOmfs+i+k+WHuu+8iVxyXG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX1JFQ19QRVJNSVNTSU9OX1NUQVRVUycsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfQkdNX1NUT1BQRUQgIOmAmuefpeiDjOaZr+mfs+S5kOaSreaUvue7k+adn1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0JHTV9TVE9QUEVEJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9CR01fRkFJTEVEICDpgJrnn6Xog4zmma/pn7PkuZDmkq3mlL7lpLHotKVcclxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9CR01fRkFJTEVEJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfTUlDX09OICDlhbbku5bnlKjmiLfpuqblhYvpo47miZPlvIBcclxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfTUlDX09OJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfTUlDX09GRiAg5YW25LuW55So5oi36bqm5YWL6aOO5YWz6ZetXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX01JQ19PRkYnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX09USEVSU19TUEVBS0VSX09OICDlhbbku5bnlKjmiLfmiazlo7DlmajmiZPlvIBcclxuICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfU1BFQUtFUl9PTicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX1NQRUFLRVJfT0ZGICDlhbbku5bnlKjmiLfmiazlo7DlmajlhbPpl61cclxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfU1BFQUtFUl9PRkYnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX09USEVSU19WT0lDRV9PTiAg5YW25LuW55So5oi36L+b5YWl6K6y6K+d54q25oCBXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX1ZPSUNFX09OJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfVk9JQ0VfT0ZGICDlhbbku5bnlKjmiLfov5vlhaXpnZnpu5jnirbmgIFcclxuICAgICAgICAgICAgICAgIGNhc2UgMjE6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfVk9JQ0VfT0ZGJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9NWV9NSUNfTEVWRUwgIOm6puWFi+mjjueahOivremfs+e6p+WIq1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX01ZX01JQ19MRVZFTCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfTUlDX0NUUl9PTiAg6bqm5YWL6aOO6KKr5YW25LuW55So5oi35omT5byAXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfTUlDX0NUUl9PTicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfTUlDX0NUUl9PRkYgIOm6puWFi+mjjuiiq+WFtuS7lueUqOaIt+WFs+mXrVxyXG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX01JQ19DVFJfT0ZGJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9TUEVBS0VSX0NUUl9PTiAg5oms5aOw5Zmo6KKr5YW25LuW55So5oi35omT5byAXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfU1BFQUtFUl9DVFJfT04nLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX1NQRUFLRVJfQ1RSX09GRiAg5oms5aOw5Zmo6KKr5YW25LuW55So5oi35YWz6ZetXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfU1BFQUtFUl9DVFJfT0ZGJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9MSVNURU5fT1RIRVJfT04gIOWPlua2iOWxj+iUveafkOS6uuivremfs1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0xJU1RFTl9PVEhFUl9PTicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfTElTVEVOX09USEVSX09GRiAg5bGP6JS95p+Q5Lq66K+t6Z+zXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfTElTVEVOX09USEVSX09GRicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfTE9DQUxfTUlDX09OICDoh6rlt7HnmoTpuqblhYvpo47miZPlvIBcclxuICAgICAgICAgICAgICAgIGNhc2UgMjk6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9MT0NBTF9NSUNfT04nLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX0xPQ0FMX01JQ19PRkYgIOiHquW3seeahOm6puWFi+mjjuWFs+mXrVxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0xPQ0FMX01JQ19PRkYnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX0xPQ0FMX1NQRUFLRVJfT04gIOiHquW3seeahOaJrOWjsOWZqOaJk+W8gFxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0xPQ0FMX1NQRUFLRVJfT04nLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX0xPQ0FMX1NQRUFLRVJfT0ZGICDoh6rlt7HnmoTmiazlo7DlmajlhbPpl61cclxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9MT0NBTF9TUEVBS0VSX09GRicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfU0VORF9NRVNTQUdFX1JFU1VMVCAgc2VuZE1lc3NhZ2XmiJDlip/kuI7lkKbnmoTpgJrnn6XvvIxwYXJhbeS4uuWbnuS8oOeahHJlcXVlc3RJRFxyXG4gICAgICAgICAgICAgICAgY2FzZSA2MDpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX1NFTkRfTUVTU0FHRV9SRVNVTFQnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX01FU1NBR0VfTk9USUZZICDmlLbliLBNZXNzYWdlLCBwYXJhbeS4um1lc3NhZ2XlhoXlrrlcclxuICAgICAgICAgICAgICAgIGNhc2UgNjE6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9NRVNTQUdFX05PVElGWScsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfS0lDS19SRVNVTFQgIOi4ouS6uueahOW6lOetlFxyXG4gICAgICAgICAgICAgICAgY2FzZSA2NDpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0tJQ0tfUkVTVUxUJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9LSUNLX05PVElGWSAg6KKr6Lii6YCa55+lICAgLHBhcmFtOiDvvIjouKLkurrogIVJRO+8jOiiq+i4ouWOn+WboO+8jOiiq+emgeaXtumXtO+8iVxyXG4gICAgICAgICAgICAgICAgY2FzZSA2NTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0tJQ0tfTk9USUZZJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9GQVJFTkRfVk9JQ0VfTEVWRUwgIOi/nOerr+ivtOivneS6uumfs+mHj+Wkp+Wwj1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2NjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0ZBUkVORF9WT0lDRV9MRVZFTCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX0JFX0tJQ0tFRCAg5oi/6Ze06YeM5YW25LuW5Lq66KKr6Lii5Ye65oi/6Ze0XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY3OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX0JFX0tJQ0tFRCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX1ZJREVPX09OICDlhbbku5bnlKjmiLfop4bpopHmtYHmiZPlvIBcclxuICAgICAgICAgICAgICAgIGNhc2UgMjAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX1ZJREVPX09OJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9NQVNLX1ZJREVPX0JZX09USEVSX1VTRVIgIOinhumikeiiq+WFtuS7lueUqOaIt+Wxj+iUvVxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9NQVNLX1ZJREVPX0JZX09USEVSX1VTRVInLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX1JFU1VNRV9WSURFT19CWV9PVEhFUl9VU0VSICDop4bpopHooqvlhbbku5bnlKjmiLfmgaLlpI1cclxuICAgICAgICAgICAgICAgIGNhc2UgMjA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfUkVTVU1FX1ZJREVPX0JZX09USEVSX1VTRVInLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX01BU0tfVklERU9fRk9SX1VTRVIgIOWxj+iUveS6huiwgeeahOinhumikVxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDY6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9NQVNLX1ZJREVPX0ZPUl9VU0VSJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9SRVNVTUVfVklERU9fRk9SX1VTRVIgIOaBouWkjeS6huiwgeeahOinhumikVxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDc6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9SRVNVTUVfVklERU9fRk9SX1VTRVInLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX09USEVSU19WSURFT19TSFVUX0RPV04gIOinhumikeaWreW8gFxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDg6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfVklERU9fU0hVVF9ET1dOJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfVklERU9fSU5QVVRfU1RBUlQgIOWFtuS7lueUqOaIt+inhumikei+k+WFpeW8gOWni1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDk6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfVklERU9fSU5QVVRfU1RBUlQnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX09USEVSU19WSURFT19JTlBVVF9TVE9QICDlhbbku5bnlKjmiLfop4bpopHovpPlhaXnu5PmnZ9cclxuICAgICAgICAgICAgICAgIGNhc2UgMjEwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX1ZJREVPX0lOUFVUX1NUT1AnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX01FRElBX0RBVEFfUk9BRF9QQVNTICDpn7Pop4bpopHmlbDmja7pgJrot6/ov57pgJrvvIzlrprml7bmo4DmtYvvvIzkuIDlvIDlp4vmlLbliLDmlbDmja7kvJrmlLbliLBQQVNT5LqL5Lu277yM5LmL5ZCO5Y+Y5YyW55qE5pe25YCZ5Lya5Y+R6YCBXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIxMTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX01FRElBX0RBVEFfUk9BRF9QQVNTJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9NRURJQV9EQVRBX1JPQURfQkxPQ0sgIOmfs+inhumikeaVsOaNrumAmui3r+S4jemAmlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9NRURJQV9EQVRBX1JPQURfQkxPQ0snLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX1FVRVJZX1VTRVJTX1ZJREVPX0lORk8gIOafpeivoueUqOaIt+inhumikeS/oeaBr+i/lOWbnlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyMTM6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9RVUVSWV9VU0VSU19WSURFT19JTkZPJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9TRVRfVVNFUlNfVklERU9fSU5GTyAg6K6+572u55So5oi35o6l5pS26KeG6aKR5L+h5oGv6L+U5ZueXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIxNDpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX1NFVF9VU0VSU19WSURFT19JTkZPJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9MT0NBTF9WSURFT19JTlBVVF9TVEFSVCAg5pys5Zyw6KeG6aKR6L6T5YWl5byA5aeL77yI5YaF6YOo6YeH6ZuG5LiL5byA5aeL5pGE5YOP5aS0L+WklumDqOi+k+WFpeS4i+W8gOWni2lucHV077yJXHJcbiAgICAgICAgICAgICAgICBjYXNlIDIxNTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX0xPQ0FMX1ZJREVPX0lOUFVUX1NUQVJUJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9MT0NBTF9WSURFT19JTlBVVF9TVE9QICDmnKzlnLDop4bpopHovpPlhaXlgZzmraLvvIjlhoXpg6jph4fpm4bkuIvlgZzmraLmkYTlg4/lpLQv5aSW6YOo6L6T5YWl5LiL5YGc5q2iaW5wdXTvvIlcclxuICAgICAgICAgICAgICAgIGNhc2UgMjE2OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfTE9DQUxfVklERU9fSU5QVVRfU1RPUCcsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX0RBVEFfRVJST1IgIOaVsOaNrumUmeivr1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfREFUQV9FUlJPUicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX05FVFdPUktfQkFEICDnvZHnu5zkuI3lpb1cclxuICAgICAgICAgICAgICAgIGNhc2UgMzAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX05FVFdPUktfQkFEJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfQkxBQ0tfRlVMTCAg6buR5bGPXHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwMjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX09USEVSU19CTEFDS19GVUxMJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfR1JFRU5fRlVMTCAg57u/5bGPXHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwMzpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX09USEVSU19HUkVFTl9GVUxMJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9PVEhFUlNfQkxBQ0tfQk9SREVSICDpu5HovrlcclxuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfT1RIRVJTX0JMQUNLX0JPUkRFUicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX0dSRUVOX0JPUkRFUiAg57u/6L65XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwNTpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX09USEVSU19HUkVFTl9CT1JERVInLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvL1lPVU1FX0VWRU5UX09USEVSU19CTFVSUkVEX1NDUkVFTiAg6Iqx5bGPXHJcbiAgICAgICAgICAgICAgICBjYXNlIDMwNjpcclxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ1lPVU1FX0VWRU5UX09USEVSU19CTFVSUkVEX1NDUkVFTicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX0VOQ09ERVJfRVJST1IgIOe8lueggemUmeivr1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDc6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfRU5DT0RFUl9FUlJPUicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfT1RIRVJTX0RFQ09ERVJfRVJST1IgIOino+eggemUmeivr1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDg6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9PVEhFUlNfREVDT0RFUl9FUlJPUicsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vWU9VTUVfRVZFTlRfQ0FNRVJBX0RFVklDRV9DT05ORUNUICDmkYTlg4/lpLTorr7lpIfmj5LlhaXvvIznp7vliqjnq6/ml6DmlYhcclxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnWU9VTUVfRVZFTlRfQ0FNRVJBX0RFVklDRV9DT05ORUNUJywgcmVzdWx0X29iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ZT1VNRV9FVkVOVF9DQU1FUkFfREVWSUNFX0RJU0NPTk5FQ1QgIOaRhOWDj+WktOiuvuWkh+aLlOWHuu+8jOenu+WKqOerr+aXoOaViFxyXG4gICAgICAgICAgICAgICAgY2FzZSA0MDE6XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdZT1VNRV9FVkVOVF9DQU1FUkFfREVWSUNFX0RJU0NPTk5FQ1QnLCByZXN1bHRfb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmoucmVxdWVzdGlkID0ganNvbi5yZXF1ZXN0aWQ7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmouZXJyb3Jjb2RlID0ganNvbi5lcnJvcjtcclxuICAgICAgICAgICAgcmVzdWx0X29iai5xdWVyeSA9IGpzb24ucXVlcnk7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmoucmVzdWx0ID0ganNvbi5yZXN1bHQ7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcIm9uUmVxdWVzdFJlc3RBUElcIiwgcmVzdWx0X29iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgcmVzdWx0X29iai5jaGFubmVsaWQgPSBqc29uLmNoYW5uZWxpZDtcclxuICAgICAgICAgICAgcmVzdWx0X29iai5pc1VwZGF0ZSA9IGpzb24uaXNVcGRhdGU7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmoubWVtY2hhbmdlID0ganNvbi5tZW1jaGFuZ2U7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcIm9uTWVtYmVyQ2hhbmdlXCIsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmouYmMgPSBqc29uLmJjO1xyXG4gICAgICAgICAgICByZXN1bHRfb2JqLmNoYW5uZWxpZCA9IGpzb24uY2hhbm5lbGlkO1xyXG4gICAgICAgICAgICByZXN1bHRfb2JqLnBhcmFtMSA9IGpzb24ucGFyYW0xO1xyXG4gICAgICAgICAgICByZXN1bHRfb2JqLnBhcmFtMiA9IGpzb24ucGFyYW0yO1xyXG4gICAgICAgICAgICByZXN1bHRfb2JqLmNvbnRlbnQgPSBqc29uLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcIm9uQnJvYWRjYXN0XCIsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSA0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmouYXZ0eXBlID0ganNvbi5hdnR5cGU7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmoudXNlcmlkID0ganNvbi51c2VyaWQ7XHJcbiAgICAgICAgICAgIHJlc3VsdF9vYmoudmFsdWUgPSBqc29uLnZhbHVlO1xyXG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJvbkFWU3RhdGlzdGljXCIsIHJlc3VsdF9vYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbXNnID0geW91bWUueW91bWVfZnJlZUNiTWVzc2FnZTIobXNnKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8v5byA5aeL5ZGo5pyf5oCn5ouJ5Y+W5Zue6LCD5L+h5oGvXHJcbnZhciBpbnRlcnZhbCA9IDIwICogMTsgLy8gXHJcbnZhciBwb2xsaW5nVGFzayA9IG51bGw7XHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRHZXRNc2coKSB7XHJcbiAgICBpZiAocG9sbGluZ1Rhc2spIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdUYXNrKTtcclxuICAgIH1cclxuICAgIHBvbGxpbmdUYXNrID0gc2V0SW50ZXJ2YWwoR2V0TXNnLCBpbnRlcnZhbCk7XHJcbn1cclxuXHJcbmxldCBnbGNhbnZhc01hcCA9IHt9O1xyXG52YXIgTXlXZWJHTENhbnZhcztcclxuXHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDYW52YXModXNlcmlkLCBjYW52YXNpZCkge1xyXG5cclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNpZCk7XHJcblxyXG4gICAgaWYgKGNhbnZhcyA9PT0gdW5kZWZpbmVkIHx8IGNhbnZhcyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGVuID0gcmVmLmFsbG9jKCdpbnQnLCAwKTtcclxuICAgIHZhciB3aWR0aCA9IHJlZi5hbGxvYygnaW50JywgMTIpO1xyXG4gICAgdmFyIGhlaWdodCA9IHJlZi5hbGxvYygnaW50JywgMTIpO1xyXG4gICAgdmFyIGZtdCA9IHJlZi5hbGxvYygnaW50JywgMSk7XHJcblxyXG4gICAgLy/ojrflj5bop4bpopHluKfmlbDmja7vvIxiZ3JhL3l1duagvOW8j1xyXG4gICAgdmFyIHZhbHVlID0geW91bWUueW91bWVfZ2V0VmlkZW9GcmFtZU5ldyh1c2VyaWQsIGxlbiwgd2lkdGgsIGhlaWdodCwgZm10KTtcclxuXHJcbiAgICB2YXIgc2l6ZSA9IGxlbi5kZXJlZigpO1xyXG5cclxuICAgIGlmIChzaXplICE9PSAwKSB7XHJcbiAgICAgICAgd2lkdGggPSByZWYuZGVyZWYod2lkdGgpO1xyXG4gICAgICAgIGhlaWdodCA9IHJlZi5kZXJlZihoZWlnaHQpO1xyXG4gICAgICAgIHZhciBkYXRhID0gcmVmLnJlaW50ZXJwcmV0KHZhbHVlLCBzaXplKTtcclxuXHJcbiAgICAgICAgZm10ID0gcmVmLmRlcmVmKGZtdCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhcyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG5cclxuICAgICAgICB2YXIgZ2xjYW52YXMgPSBnbGNhbnZhc01hcFtjYW52YXMuaWRdO1xyXG4gICAgICAgIGlmIChnbGNhbnZhcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChnbGNhbnZhcy5mbXQgPT09IGZtdCkge1xyXG4gICAgICAgICAgICAgICAgZ2xjYW52YXMuZGVjb2RlKGRhdGFzLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVdlYkdMQ2FudmFzKGNhbnZhcywgZm10KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3JlYXRlV2ViR0xDYW52YXMoY2FudmFzLCBmbXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcyA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ2FudmFzKGNhbnZhcywgZm10KSB7XHJcbiAgICBpZiAoZm10ID09PSAwKSB7XHJcbiAgICAgICAgTXlXZWJHTENhbnZhcyA9IG5ldyBZVVZXZWJHTENhbnZhcyhjYW52YXMsIG5ldyBTaXplKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkpO1xyXG4gICAgICAgIGdsY2FudmFzTWFwW2NhbnZhcy5pZF0gPSBNeVdlYkdMQ2FudmFzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZm10ID09PSAxKSB7XHJcbiAgICAgICAgTXlXZWJHTENhbnZhcyA9IG5ldyBCR1JBV2ViR0xDYW52YXMoY2FudmFzLCBuZXcgU2l6ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKTtcclxuICAgICAgICBnbGNhbnZhc01hcFtjYW52YXMuaWRdID0gTXlXZWJHTENhbnZhcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICog5Yqf6IO95o+P6L+wOuWIneWni+WMluW8leaTjlxyXG4gKiDov5nmmK/kuIDkuKrlvILmraXosIPnlKjmjqXlj6PvvIzlpoLmnpzlh73mlbDov5Tlm54gWU9VTUVfU1VDQ0VTU++8jCDliJnpnIDopoHnrYnlvoXku6XkuIvkuovku7blm57osIPovr7liLDmiY3ooajmmI7liJ3lp4vljJblrozmiJBcclxuICogWU9VTUVfRVZFTlRfSU5JVF9PSyAtIOihqOaYjuWIneWni+WMluaIkOWKn1xyXG4gKiBZT1VNRV9FVkVOVF9JTklUX0ZBSUxFRCAtIOihqOaYjuWIneWni+WMluWksei0pe+8jOacgOW4uOingeeahOWksei0peWOn+WboOaYr+e9kee7nOmUmeivr+aIluiAhSBBcHBLZXkvQXBwU2VjcmV0IOmUmeivr1xyXG4gKlxyXG4gKiBAcGFyYW0gc3RyQVBQS2V5IC0g5LuO5ri45a+G55Sz6K+35Yiw55qEIGFwcCBrZXksIOi/meS4quS9oOS7rOW6lOeUqOeoi+W6j+eahOWUr+S4gOagh+ivhlxyXG4gKiBAcGFyYW0gc3RyQVBQU2VjcmV0IC0g5a+55bqUIHN0ckFQUEtleSDnmoTnp4HpkqUsIOi/meS4qumcgOimgeWmpeWWhOS/neWtmO+8jOS4jeimgeaatOmcsue7meWFtuS7luS6ulxyXG4gKiBAcGFyYW0gc2VydmVyUmVnaW9uSWQgLVxyXG4gKiAgICAgICAg6K6+572u6aaW6YCJ6L+e5o6l5pyN5Yqh5Zmo55qE5Yy65Z+f56CBXHJcbiAqICAgICAgICDlpoLmnpzlnKjliJ3lp4vljJbml7bkuI3og73noa7lrprljLrln5/vvIzlj6/ku6XloatSVENfREVGQVVMVF9TRVJWRVLvvIzlkI7pnaLnoa7lrprml7bpgJrov4cgU2V0U2VydmVyUmVnaW9uIOiuvue9ruOAglxyXG4gKiAgICAgICAg5aaC5p6cWU9VTUVfUlRDX1NFUlZFUl9SRUdJT07lrprkuYnnmoTljLrln5/noIHkuI3og73mu6HotrPopoHmsYLvvIzlj6/ku6Xmiorov5nkuKrlj4LmlbDorr7kuLogUlRDX0VYVF9TRVJWRVLvvIznhLblkI5cclxuICogICAgICAgIOmAmui/h+WQjumdoueahOWPguaVsCBzdHJFeHRTZXJ2ZXJSZWdpb25OYW1lIOiuvue9ruS4gOS4quiHquWumueahOWMuuWfn+WAvO+8iOWmguS4reWbveeUqCBcImNuXCIg5oiW6ICFIOKAnGNoXCLooajnpLrvvInvvIznhLblkI7miorov5nkuKroh6rlrprkuYnnmoTljLrln5/lgLzlkIzmraXnu5nmuLjlr4bjgIJcclxuICogICAgICAgIOaIkeS7rOWwhumAmui/h+WQjuWPsOmFjee9ruaYoOWwhOWIsOacgOS9s+WMuuWfn+eahOacjeWKoeWZqOOAglxyXG4gKiBAcEV4dFNlcnZlclJlZ2lvbk5hbWUgLSDmianlsZXnmoTmnI3liqHlmajljLrln5/nroDnp7BcclxuICpcclxuICogQHJldHVybiAtIFlPVU1FX1NVQ0NFU1NcclxuICogICAgICAgICAgIOWFtuS7lui/lOWbnuWAvOihqOaYjuWPkeeUn+S6humUmeivr++8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdChzdHJBUFBLZXksIHN0ckFQUFNlY3JldCwgc2VydmVyUmVnaW9uSWQsIHBFeHRTZXJ2ZXJSZWdpb25OYW1lKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfaW5pdChzdHJBUFBLZXksIHN0ckFQUFNlY3JldCwgc2VydmVyUmVnaW9uSWQsIHBFeHRTZXJ2ZXJSZWdpb25OYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7DvvJrliqDlhaXor63pn7PpopHpgZNcclxuICpcclxuICogIEBwYXJhbSBzdHJVc2VySUQ6IOeUqOaIt0lE77yM6KaB5L+d6K+B5YWo5bGA5ZSv5LiAXHJcbiAqICBAcGFyYW0gc3RyQ2hhbm5lbElEOiDpopHpgZNJRO+8jOimgeS/neivgeWFqOWxgOWUr+S4gFxyXG4gKiAgQHBhcmFtIGVVc2VyUm9sZTog55So5oi36KeS6Imy77yM55So5LqO5Yaz5a6a6K6y6K+dL+aSreaUvuiDjOaZr+mfs+S5kOetieadg+mZkFxyXG4gKlxyXG4gKiAgQHJldHVybiDplJnor6/noIHvvIzor6bop4FZb3VNZUNvbnN0RGVmaW5lLmjlrprkuYlcclxuICovXHJcbmZ1bmN0aW9uIGpvaW5DaGFubmVsU2luZ2xlTW9kZShzdHJVc2VySUQsIHN0ckNoYW5uZWxJRCwgZVVzZXJSb2xlKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfam9pbkNoYW5uZWxTaW5nbGVNb2RlKHN0clVzZXJJRCwgc3RyQ2hhbm5lbElELCBlVXNlclJvbGUpO1xyXG59XHJcblxyXG4vKipcclxuICog5Yqf6IO95o+P6L+wOiAgIOiuvue9ruaYr+WQpueUseWklumDqOi+k+WFpemfs+inhumikVxyXG4gKiBAcGFyYW0gYklucHV0TW9kZUVuYWJsZWQ6IHRydWU65aSW6YOo6L6T5YWl5qih5byP77yMZmFsc2U6U0RL5YaF6YOo6YeH6ZuG5qih5byPXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRFeHRlcm5hbElucHV0TW9kZShiSW5wdXRNb2RlRW5hYmxlZCkge1xyXG4gICAgeW91bWUueW91bWVfc2V0RXh0ZXJuYWxJbnB1dE1vZGUoYklucHV0TW9kZUVuYWJsZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog6K6+572u6Z+z6KeG6aKR57uf6K6h5pWw5o2u5pe26Ze06Ze06ZqUXHJcbiAqICBAcGFyYW0gaW50ZXJ2YWw65pe26Ze06Ze06ZqUXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRBVlN0YXRpc3RpY0ludGVydmFsKGludGVydmFsKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRBVlN0YXRpc3RpY0ludGVydmFsKGludGVydmFsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiuvue9ruinhumikee9kee7nOS8oOi+k+i/h+eoi+eahOWIhui+qOeOhyzpq5jliIbovqjnjodcclxuICogIEBwYXJhbSB3aWR0aDrlrr1cclxuICogIEBwYXJhbSBoZWlnaHQ66auYXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWRlb05ldFJlc29sdXRpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldFZpZGVvTmV0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiuvue9ruacrOWcsOinhumikea4suafk+Wbnuiwg+eahOWIhui+qOeOhyzpq5jliIbovqjnjodcclxuICogIEBwYXJhbSB3aWR0aDrlrr1cclxuICogIEBwYXJhbSBoZWlnaHQ66auYXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWRlb0xvY2FsUmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2V0VmlkZW9Mb2NhbFJlc29sdXRpb24od2lkdGgsIGhlaWdodCk7XHJcbn1cclxuXHJcbi8v6I635Y+W54mI5pys5Y+3XHJcbmZ1bmN0aW9uIGdldFNES1ZlcnNpb24oKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfZ2V0U0RLVmVyc2lvbigpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDrpgIDlh7rmiYDmnInor63pn7PpopHpgZNcclxuICpcclxuICogIEByZXR1cm4g6ZSZ6K+v56CB77yM6K+m6KeBWW91TWVDb25zdERlZmluZS5o5a6a5LmJXHJcbiAqL1xyXG5mdW5jdGlvbiBsZWF2ZUNoYW5uZWxBbGwoKSB7XHJcbiAgICBnbGNhbnZhc01hcCA9IHt9O1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2xlYXZlQ2hhbm5lbEFsbCgpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDrorr7nva7ouqvku73pqozor4HnmoR0b2tlblxyXG4gKiAgQHBhcmFtIHN0clRva2VuOiDouqvku73pqozor4HnlKh0b2tlbu+8jOiuvue9ruS4uk5VTEzmiJbogIXnqbrlrZfnrKbkuLLvvIzmuIXnqbp0b2tlbuWAvOOAglxyXG4gKiAgQHJldHVybiDml6BcclxuICovXHJcbmZ1bmN0aW9uIHNldFRva2VuKHN0clRva2VuKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRUb2tlbihzdHJUb2tlbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDorr7nva5BdWRpb+eahOS8oOi+k+i0qOmHj1xyXG4gKiAgQHBhcmFtIHF1YWxpdHk6IDA6IGxvdyAxOiBoaWdoXHJcbiAqXHJcbiAqICBAcmV0dXJuIE5vbmVcclxuICovXHJcbmZ1bmN0aW9uIHNldEF1ZGlvUXVhbGl0eShxdWFsaXR5KSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRBdWRpb1F1YWxpdHkocXVhbGl0eSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlip/og73mj4/ov7A65Y+N5Yid5aeL5YyW5byV5pOO77yM5Zyo5bqU55So6YCA5Ye65LmL5YmN6ZyA6KaB6LCD55So6L+Z5Liq5o6l5Y+j6YeK5pS+6LWE5rqQ44CCXHJcbiAqICAgICAgICDov5nmmK/kuIDkuKrlkIzmraXosIPnlKjmjqXlj6PvvIzlh73mlbDov5Tlm57ml7booajmmI7mk43kvZzlt7Lnu4/lrozmiJDjgIJcclxuICpcclxuICogQHJldHVybiAtIFlPVU1FX1NVQ0NFU1NcclxuICogICAgICAgICAgIOWFtuS7lui/lOWbnuWAvOihqOaYjuWPkeeUn+S6humUmeivr++8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gKi9cclxuZnVuY3Rpb24gdW5Jbml0KCkge1xyXG4gICAgaWYgKHBvbGxpbmdUYXNrKSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nVGFzayk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfdW5Jbml0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuiuvue9rumfs+mHj++8jOWPluWAvOiMg+WbtOaYr1swLTEwMF0gMTAw6KGo56S65pyA5aSn6Z+z6YeP77yMIOm7mOiupOmfs+mHj+aYrzEwMFxyXG4gKiAgQHBhcmFtIHVpVm9sdW1lOiDpn7Pph49cclxuICogIEByZXR1cm4g5pegXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWb2x1bWUodWlWb2x1bWUpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldFZvbHVtZSh1aVZvbHVtZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuiOt+WPlumfs+mHj+Wkp+WwjyzmraTpn7Pph4/lgLzkuLrnqIvluo/lhoXpg6jnmoTpn7Pph4/vvIzkuI7ns7vnu5/pn7Pph4/nm7jkuZjlvpfliLDnqIvluo/kvb/nlKjnmoTlrp7pmYXpn7Pph49cclxuICpcclxuICogIEByZXR1cm4g6Z+z6YeP5YC8WzAsMTAwXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Vm9sdW1lKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2dldFZvbHVtZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDrpuqblhYvpo44g6Z2Z6Z+zIOaJk+W8gC/lhbPpl61cclxuICpcclxuICogIEBwYXJhbSBiT246dHJ1ZeKAlOKAlOWFs+mXrem6puWFi+mjju+8jGZhbHNl4oCU4oCU5byA5ZCv6bqm5YWL6aOOXHJcbiAqICBAcmV0dXJuIOaXoFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TWljcm9waG9uZU11dGUoYk9uKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRNaWNyb3Bob25lTXV0ZShiT24pO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDrojrflj5bpuqblhYvpo44g6Z2Z6Z+zIOeKtuaAgVxyXG4gKlxyXG4gKiAgQHJldHVybiB0cnVl4oCU4oCU5YWz6Zet77yMZmFsc2XigJTigJTmiZPlvIBcclxuICovXHJcbmZ1bmN0aW9uIGdldE1pY3JvcGhvbmVNdXRlKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2dldE1pY3JvcGhvbmVNdXRlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuiOt+WPluaJrOWjsOWZqCDpnZnpn7Mg54q25oCBXHJcbiAqXHJcbiAqICBAcmV0dXJuIHRydWXigJTigJTlhbPpl63miazlo7DlmajvvIxmYWxzZeKAlOKAlOW8gOWQr+aJrOWjsOWZqFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3BlYWtlck11dGUoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfZ2V0U3BlYWtlck11dGUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A65oms5aOw5ZmoIOmdmemfsyDmiZPlvIAv5YWz6ZetXHJcbiAqXHJcbiAqICBAcGFyYW0gYk9uOnRydWXigJTigJTlhbPpl63miazlo7DlmajvvIxmYWxzZeKAlOKAlOW8gOWQr+aJrOWjsOWZqFxyXG4gKiAgQHJldHVybiDml6BcclxuICovXHJcbmZ1bmN0aW9uIHNldFNwZWFrZXJNdXRlKGJPbikge1xyXG4gICAgeW91bWUueW91bWVfc2V0U3BlYWtlck11dGUoYk9uKTtcclxufVxyXG5cclxuLy/orr7nva7ku5bkurrpuqblhYvpo47nirbmgIFcclxuZnVuY3Rpb24gc2V0T3RoZXJNaWNNdXRlKHVzZXJpZCwgbXV0ZSkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldE90aGVyTWljTXV0ZSh1c2VyaWQsIG11dGUpO1xyXG59XHJcblxyXG4vL+iuvue9ruS7luS6uuaJrOWjsOWZqOeKtuaAgVxyXG5mdW5jdGlvbiBzZXRPdGhlclNwZWFrZXJNdXRlKHVzZXJpZCwgbXV0ZSkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldE90aGVyU3BlYWtlck11dGUodXNlcmlkLCBtdXRlKTtcclxufVxyXG5cclxuLy/orr7nva7mmK/lkKblkKzmn5DkurrnmoTor63pn7PjgIJcclxuZnVuY3Rpb24gc2V0TGlzdGVuT3RoZXJWb2ljZSh1c2VyaWQsIGlzb24pIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRMaXN0ZW5PdGhlclZvaWNlKHVzZXJpZCwgaXNvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDorr7nva7ml6Xlv5fnrYnnuqdcclxuICogIEBwYXJhbSBjb25zb2xlTGV2ZWw6IOaOp+WItuWPsOaXpeW/l+etiee6p1xyXG4gKiAgQHBhcmFtIGZpbGVMZXZlbDog5paH5Lu25pel5b+X562J57qnXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChjb25zb2xlTGV2ZWwsIGZpbGVMZXZlbCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldExvZ0xldmVsKGNvbnNvbGVMZXZlbCwgZmlsZUxldmVsKTtcclxufVxyXG5cclxuLy/orr7nva7mnI3liqHlmajljLrln59cclxuZnVuY3Rpb24gc2V0U2VydmVyUmVnaW9uKHNlcnZlclJlZ2lvbklkLCBzdHJFeHRSZWdpb25OYW1lKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRTZXJ2ZXJSZWdpb24oc2VydmVyUmVnaW9uSWQsIHN0ckV4dFJlZ2lvbk5hbWUpO1xyXG59XHJcblxyXG4vLyDlgZzmraLmjZXojrfmnKzmnLrmkYTlg4/lpLTmlbDmja5cclxuZnVuY3Rpb24gc3RvcENhcHR1cmUoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc3RvcENhcHR1cmUoKTtcclxufVxyXG5cclxuLy8g5byA5aeL5o2V6I635pys5py65pGE5YOP5aS05pWw5o2uXHJcbmZ1bmN0aW9uIHN0YXJ0Q2FwdHVyZSgpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zdGFydENhcHR1cmUoKTtcclxufVxyXG5cclxuLy/mmK/lkKbmmK/mtYvor5XmqKHlvI8s5rWL6K+V5qih5byP5L2/55So5rWL6K+V5pyNXHJcbmZ1bmN0aW9uIHNldFRlc3RDb25maWcoYlRlc3QpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldFRlc3RDb25maWcoYlRlc3QpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDrliIfmjaLor63pn7PovpPlh7rorr7lpIdcclxuICogIOm7mOiupOi+k+WHuuWIsOaJrOWjsOWZqO+8jOWcqOWKoOWFpeaIv+mXtOaIkOWKn+WQjuiuvue9ru+8jOWmguaXoOWQrOetkui+k+WHuueahOmcgOaxguWwvemHj+S4jeimgeiwg+eUqOivpeaOpeWPo+OAglxyXG4gKlxyXG4gKiAgQHBhcmFtIGJPdXRwdXRUb1NwZWFrZXI6dHJ1ZeKAlOKAlOS9v+eUqOaJrOWjsOWZqO+8jGZhbHNl4oCU4oCU5L2/55So5ZCs562SXHJcbiAqICBAcmV0dXJuIOmUmeivr+egge+8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0T3V0cHV0VG9TcGVha2VyKGJPdXRwdXRUb1NwZWFrZXIpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRPdXRwdXRUb1NwZWFrZXIoYk91dHB1dFRvU3BlYWtlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuiuvue9ruaYr+WQpumAmuefpeWFtuS7luS6uuiHquW3seeahOW8gOWFs+m6puWFi+mjjuWSjOaJrOWjsOWZqOeahOeKtuaAgVxyXG4gKlxyXG4gKiAgQHBhcmFtIGJBdXRvU2VuZDp0cnVl4oCU4oCU6YCa55+l77yMZmFsc2XigJTigJTkuI3pgJrnn6VcclxuICogIEByZXR1cm4g5pegXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRBdXRvU2VuZFN0YXR1cyhiQXV0b1NlbmQpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldEF1dG9TZW5kU3RhdHVzKGJBdXRvU2VuZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuWQr+eUqC/npoHnlKjnp7vliqjnvZHnu5xcclxuICpcclxuICogIEBwYXJhbSBiRW5hYmxlZDp0cnVlLeWPr+S7peWQr+eUqO+8jGZhbHNlLeemgeeUqO+8jOm7mOiupOemgeeUqFxyXG4gKlxyXG4gKiAgQHJldHVybiDml6BcclxuICovXHJcbmZ1bmN0aW9uIHNldFVzZU1vYmlsZU5ldHdvcmtFbmFibGVkKGJFbmFibGVkKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRVc2VNb2JpbGVOZXR3b3JrRW5hYmxlZChiRW5hYmxlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOuaYr+WQpuWPr+S9v+eUqOenu+WKqOe9kee7nFxyXG4gKlxyXG4gKiAgQHJldHVybiB0cnVlLeWPr+S7peS9v+eUqO+8jGZhbHNlLeemgeeUqFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VXNlTW9iaWxlTmV0d29ya0VuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfZ2V0VXNlTW9iaWxlTmV0d29ya0VuYWJsZWQoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiuvue9rueUqOaIt+iHquWumuS5iUxvZ+i3r+W+hFxyXG4gKiAgQHBhcmFtIHN0ckZpbGVQYXRoIExvZ+aWh+S7tueahOi3r+W+hFxyXG4gKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VXNlckxvZ1BhdGgoc3RyRmlsZVBhdGgpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRVc2VyTG9nUGF0aChzdHJGaWxlUGF0aCk7XHJcbn1cclxuXHJcbi8vIOaSreaUvuiDjOaZr+mfs+S5kFxyXG5mdW5jdGlvbiBwbGF5QmFja2dyb3VuZE11c2ljKHN0ckZpbGVQYXRoLCBiUmVwZWF0KSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfcGxheUJhY2tncm91bmRNdXNpYyhzdHJGaWxlUGF0aCwgYlJlcGVhdCk7XHJcbn1cclxuXHJcbi8vIOaaguWBnOiDjOaZr+mfs+S5kFxyXG5mdW5jdGlvbiBwYXVzZUJhY2tncm91bmRNdXNpYygpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9wYXVzZUJhY2tncm91bmRNdXNpYygpO1xyXG59XHJcblxyXG4vLyDmgaLlpI3og4zmma/pn7PkuZBcclxuZnVuY3Rpb24gcmVzdW1lQmFja2dyb3VuZE11c2ljKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3Jlc3VtZUJhY2tncm91bmRNdXNpYygpO1xyXG59XHJcblxyXG4vLyDlgZzmraLog4zmma/pn7PkuZBcclxuZnVuY3Rpb24gc3RvcEJhY2tncm91bmRNdXNpYygpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zdG9wQmFja2dyb3VuZE11c2ljKCk7XHJcbn1cclxuXHJcbi8vIOiuvue9ruiDjOaZr+mfs+S5kOmfs+mHj1xyXG5mdW5jdGlvbiBzZXRCYWNrZ3JvdW5kTXVzaWNWb2x1bWUodm9sKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2V0QmFja2dyb3VuZE11c2ljVm9sdW1lKHZvbCk7XHJcbn1cclxuXHJcbi8vIOiuvue9ruaYr+WQpuWwhumAmui/h+iAs+acuuebkeWQrOiHquW3seeahOWjsOmfs1xyXG5mdW5jdGlvbiBzZXRIZWFkc2V0TW9uaXRvck9uKG1pY0VuYWJsZWQsIGJnbUVuYWJsZWQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRIZWFkc2V0TW9uaXRvck9uKG1pY0VuYWJsZWQsIGJnbUVuYWJsZWQpO1xyXG59XHJcblxyXG4vLyDorr7nva7mmK/lkKborr7nva7kuLvmkq3mt7flk43mqKHlvI9cclxuZnVuY3Rpb24gc2V0UmV2ZXJiRW5hYmxlZChiRW5hYmxlZCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldFJldmVyYkVuYWJsZWQoYkVuYWJsZWQpO1xyXG59XHJcblxyXG4vLyDorr7nva7mmK/lkKblkK/liqjor63pn7Pmo4DmtYvlm57osINcclxuZnVuY3Rpb24gc2V0VmFkQ2FsbGJhY2tFbmFibGVkKGVuYWJsZWQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRWYWRDYWxsYmFja0VuYWJsZWQoZW5hYmxlZCk7XHJcbn1cclxuXHJcbi8vIOiuvue9ruaYr+WQpuWQr+WKqOiusuivnemfs+mHj+Wbnuiwg1xyXG5mdW5jdGlvbiBzZXRNaWNMZXZlbENhbGxiYWNrKG1heExldmVsKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2V0TWljTGV2ZWxDYWxsYmFjayhtYXhMZXZlbCk7XHJcbn1cclxuXHJcbi8vIOiuvue9ruaYr+WQpuWQr+WKqOi/nOerr+ivremfs+mfs+mHj+Wbnuiwg1xyXG5mdW5jdGlvbiBzZXRGYXJlbmRWb2ljZUxldmVsQ2FsbGJhY2sobWF4TGV2ZWwpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRGYXJlbmRWb2ljZUxldmVsQ2FsbGJhY2sobWF4TGV2ZWwpO1xyXG59XHJcblxyXG4vLyDorr7nva7lvZPpuqblhYvpo47pnZnpn7Pml7bvvIzmmK/lkKbph4rmlL7puqblhYvpo47orr7lpIfvvIzlnKjliJ3lp4vljJbkuYvlkI7jgIHliqDlhaXmiL/pl7TkuYvliY3osIPnlKhcclxuZnVuY3Rpb24gc2V0UmVsZWFzZU1pY1doZW5NdXRlKGVuYWJsZWQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRSZWxlYXNlTWljV2hlbk11dGUoZW5hYmxlZCk7XHJcbn1cclxuXHJcbi8vIOaaguWBnOmAmuivne+8jOmHiuaUvuWvuem6puWFi+mjjuetieiuvuWkh+i1hOa6kOeahOWNoOeUqFxyXG5mdW5jdGlvbiBwYXVzZUNoYW5uZWwoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfcGF1c2VDaGFubmVsKCk7XHJcbn1cclxuXHJcbi8vIOaBouWkjemAmuivnVxyXG5mdW5jdGlvbiByZXN1bWVDaGFubmVsKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3Jlc3VtZUNoYW5uZWwoKTtcclxufVxyXG5cclxuLy8g6K6+572u5b2T5YmN5b2V6Z+z55qE5pe26Ze05oizXHJcbmZ1bmN0aW9uIHNldFJlY29yZGluZ1RpbWVNcyh0aW1lTXMpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldFJlY29yZGluZ1RpbWVNcyh0aW1lTXMpO1xyXG59XHJcblxyXG4vLyDorr7nva7lvZPliY3mkq3mlL7nmoTml7bpl7TmiLNcclxuZnVuY3Rpb24gc2V0UGxheWluZ1RpbWVNcyh0aW1lTXMpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldFBsYXlpbmdUaW1lTXModGltZU1zKTtcclxufVxyXG5cclxuLy8g6K6+572u5pyN5Yqh5Zmo5qih5byPXHJcbmZ1bmN0aW9uIHNldFNlcnZlck1vZGUobW9kZSkge1xyXG4gICAgeW91bWUueW91bWVfc2V0U2VydmVyTW9kZShtb2RlKTtcclxufVxyXG5cclxuLy9SZXN0QXBp4oCU4oCU5pSv5oyB5Li75pKt55u45YWz5L+h5oGv5p+l6K+iXHJcbmZ1bmN0aW9uIHJlcXVlc3RSZXN0QXBpKHN0ckNvbW1hbmQsIHN0clF1ZXJ5Qm9keSwgcmVxdWVzdElEKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfcmVxdWVzdFJlc3RBcGkoc3RyQ29tbWFuZCwgc3RyUXVlcnlCb2R5LCByZXF1ZXN0SUQpO1xyXG59XHJcblxyXG4vL+afpeivoumikemBk+W9k+WJjeeahOeUqOaIt+WIl+ihqO+8jG1heENvdW506KGo5piO5pyA5aSa6I635Y+W5aSa5bCR77yMLTHooajnpLrojrflj5bmiYDmnIlcclxuZnVuY3Rpb24gZ2V0Q2hhbm5lbFVzZXJMaXN0KHN0ckNoYW5uZWxJRCwgbWF4Q291bnQsIG5vdGlmeU1lbUNoYW5nZSkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2dldENoYW5uZWxVc2VyTGlzdChzdHJDaGFubmVsSUQsIG1heENvdW50LCBub3RpZnlNZW1DaGFuZ2UpO1xyXG59XHJcblxyXG4vLyDov5vlhaXmiL/pl7TlkI7vvIzliIfmjaLouqvku71cclxuZnVuY3Rpb24gc2V0VXNlclJvbGUodXNlclJvbGUpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRVc2VyUm9sZSh1c2VyUm9sZSk7XHJcbn1cclxuXHJcbi8vIOiOt+WPlui6q+S7vVxyXG5mdW5jdGlvbiBnZXRVc2VyUm9sZSgpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9nZXRVc2VyUm9sZSgpO1xyXG59XHJcblxyXG4vLyDog4zmma/pn7PkuZDmmK/lkKblnKjmkq3mlL5cclxuZnVuY3Rpb24gaXNCYWNrZ3JvdW5kTXVzaWNQbGF5aW5nKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2lzQmFja2dyb3VuZE11c2ljUGxheWluZygpO1xyXG59XHJcblxyXG4vLyDmmK/lkKbliJ3lp4vljJbmiJDlip9cclxuZnVuY3Rpb24gaXNJbml0ZWQoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfaXNJbml0ZWQoKTtcclxufVxyXG5cclxuLy8g5piv5ZCm5Zyo5p+Q5Liq6K+t6Z+z5oi/6Ze05YaFXHJcbmZ1bmN0aW9uIGlzSW5DaGFubmVsKHBDaGFubmVsSUQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9pc0luQ2hhbm5lbChwQ2hhbm5lbElEKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIOWKn+iDveaPj+i/sDogICDlkJHmiL/pl7Tlub/mkq3mtojmga9cclxuICogQHBhcmFtIHBDaGFubmVsSUQ6IOW5v+aSreaIv+mXtFxyXG4gKiBAcGFyYW0gcENvbnRlbnQ6IOW5v+aSreWGheWuuS3mlofmnKzkuLJcclxuICogQHBhcmFtIHJlcXVlc3RJRDrov5Tlm57mtojmga/moIfor4bvvIzlm57osIPnmoTml7blgJnkvJrlm57kvKDor6XlgLxcclxuICogQHJldHVybiAgIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kTWVzc2FnZShwQ2hhbm5lbElELCBwQ29udGVudCwgcmVxdWVzdElEKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2VuZE1lc3NhZ2UocENoYW5uZWxJRCwgcENvbnRlbnQsIHJlcXVlc3RJRCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDmiormn5DkurrouKLlh7rmiL/pl7RcclxuICogIEBwYXJhbSAgcFVzZXJJRDog6KKr6Lii55qE55So5oi3SURcclxuICogIEBwYXJhbSAgcENoYW5uZWxJRDog5LuO5ZOq5Liq5oi/6Ze06Lii5Ye6XHJcbiAqICBAcGFyYW0gIGxhc3RUaW1lOiDouKLlh7rlkI7vvIzlpJrplb/ml7bpl7TlhoXkuI3lhYHorrjlho3mrKHov5vlhaVcclxuICogIEByZXR1cm4gWU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICovXHJcbmZ1bmN0aW9uIGtpY2tPdGhlckZyb21DaGFubmVsKHBVc2VySUQsIHBDaGFubmVsSUQsIGxhc3RUaW1lKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfa2lja090aGVyRnJvbUNoYW5uZWwocFVzZXJJRCwgcENoYW5uZWxJRCwgbGFzdFRpbWUpO1xyXG59XHJcblxyXG4vLyDorr7nva7mmK/lkKblvIDlkK/op4bpopHnvJbnoIHlmahcclxuZnVuY3Rpb24gb3BlblZpZGVvRW5jb2RlcihwRmlsZVBhdGgpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9vcGVuVmlkZW9FbmNvZGVyKHBGaWxlUGF0aCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qICDlip/og73mj4/ov7A6ICjkuIPniZvmjqXlj6Mp5bCG5o+Q5L6b55qE6Z+z6aKR5pWw5o2u5re35ZCI5Yiw6bqm5YWL6aOO5oiW6ICF5oms5aOw5Zmo55qE6Z+z6L2o6YeM6Z2i44CCXHJcbiogIEBwYXJhbSBkYXRhIOaMh+WQkVBDTeaVsOaNrueahOe8k+WGsuWMulxyXG4qICBAcGFyYW0gbGVuICDpn7PpopHmlbDmja7nmoTlpKflsI9cclxuKiAgQHBhcmFtIHRpbWVzdGFtcCDml7bpl7TmiLNcclxuKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiovXHJcbmZ1bmN0aW9uIGlucHV0QXVkaW9GcmFtZShkYXRhLCBsZW4sIHRpbWVzdGFtcCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2lucHV0QXVkaW9GcmFtZShkYXRhLCBsZW4sIHRpbWVzdGFtcCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qICDlip/og73mj4/ov7A6ICjkuIPniZvmjqXlj6Mp5bCG5o+Q5L6b55qE6KeG6aKR5pWw5o2u5YiwcHJvZHVjZXLjgIJcclxuKiAgQHBhcmFtIGRhdGEg5oyH5ZCR6KeG6aKR5pWw5o2u55qE57yT5Yay5Yy6XHJcbiogIEBwYXJhbSBsZW4gIOinhumikeaVsOaNrueahOWkp+Wwj1xyXG4qIEBwYXJhbSB3aWR0aCAg6KeG6aKR5a69XHJcbiogQHBhcmFtIGhlaWdodCAg6KeG6aKR6auYXHJcbiogQHBhcmFtIGZtdCAg6KeG6aKR5qC85byPXHJcbiogQHBhcmFtIHJvdGF0aW9uICDop4bpopHop5LluqZcclxuKiBAcGFyYW0gbWlycm9yICDplZzlg49cclxuKiAgQHBhcmFtIHRpbWVzdGFtcCDml7bpl7TmiLNcclxuKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiovXHJcbmZ1bmN0aW9uIGlucHV0VmlkZW9GcmFtZShkYXRhLCBsZW4sIHdpZHRoLCBoZWlnaHQsIGZtdCwgcm90YXRpb24sIG1pcnJvciwgdGltZXN0YW1wKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfaW5wdXRWaWRlb0ZyYW1lKGRhdGEsIGxlbiwgd2lkdGgsIGhlaWdodCwgZm10LCByb3RhdGlvbiwgbWlycm9yLCB0aW1lc3RhbXApO1xyXG59XHJcblxyXG4vKipcclxuICog5Yqf6IO95o+P6L+wOiBcYlxi5YGc5q2i6KeG6aKR5pWw5o2u6L6T5YWlKOS4g+eJm+aOpeWPo++8jOWcqHlvdW1lX2lucHV0VmlkZW9GcmFtZeS5i+WQjuiwg+eUqO+8jOaIv+mXtOWGheWFtuWug+eUqOaIt+S8muaUtuWIsFlPVU1FX0VWRU5UX09USEVSU19WSURFT19JTlBVVF9TVE9Q5LqL5Lu2KVxyXG4gKiBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICovXHJcbmZ1bmN0aW9uIHN0b3BJbnB1dFZpZGVvRnJhbWUoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc3RvcElucHV0VmlkZW9GcmFtZSgpO1xyXG59XHJcblxyXG4vLyDojrflj5bop4bpopHmlbDmja5cclxuZnVuY3Rpb24gZ2V0VmlkZW9GcmFtZSh1c2VySWQsIGxlbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2dldFZpZGVvRnJhbWUodXNlcklkLCBsZW4sIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcblxyXG4vLyDorr7nva7op4bpopHlm57osINcclxuZnVuY3Rpb24gc2V0VmlkZW9DYWxsYmFjaygpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRWaWRlb0NhbGxiYWNrKFwiXCIpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog6K6+572u5bin546HXHJcbiAqICBAcGFyYW0gIGZwczrluKfnjofvvIgxLTMw77yJ77yM6buY6K6kMTXluKfvvIzlv4XpobvlnKjorr7nva7liIbovqjnjofkuYvliY3osIPnlKhcclxuICogIEByZXR1cm4gWU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICovXHJcbmZ1bmN0aW9uIHNldFZpZGVvRnBzKGZwcykge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldFZpZGVvRnBzKGZwcyk7XHJcbn1cclxuXHJcbi8vIOWIh+aNouWJjeWQjuaRhOWDj+WktFxyXG5mdW5jdGlvbiBzd2l0Y2hDYW1lcmEoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc3dpdGNoQ2FtZXJhKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDmnYPpmZDmo4DmtYvnu5PmnZ/lkI7ph43nva7mkYTlg4/lpLRcclxuICogIEBwYXJhbVxyXG4gKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzZXRDYW1lcmEoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfcmVzZXRDYW1lcmEoKTtcclxufVxyXG5cclxuLy8g6K6+572u5piv5ZCm5YmN572u5pGE5YOP5aS0XHJcbmZ1bmN0aW9uIHNldENhcHR1cmVGcm9udENhbWVyYUVuYWJsZShlbmFibGUpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRDYXB0dXJlRnJvbnRDYW1lcmFFbmFibGUoZW5hYmxlKTtcclxufVxyXG5cclxuLy8g5bGP6JS9L+aBouWkjeafkOS4qlVzZXJJZOeahOinhumikea1gVxyXG5mdW5jdGlvbiBtYXNrVmlkZW9CeVVzZXJJZCh1c2VyaWQsIG1hc2spIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9tYXNrVmlkZW9CeVVzZXJJZCh1c2VyaWQsIG1hc2spO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog6K6+572u5aSW6YOo6L6T5YWl5qih5byP55qE6K+t6Z+z6YeH5qC3546HXHJcbiAqICBAcGFyYW0gaW5wdXRTYW1wbGVSYXRlOiDovpPlhaXor63pn7Pph4fmoLfnjodcclxuICogIEBwYXJhbSBtaXhlZENhbGxiYWNrU2FtcGxlUmF0ZTogbWl45ZCO6L6T5Ye66K+t6Z+z6YeH5qC3546HXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRFeHRlcm5hbElucHV0U2FtcGxlUmF0ZShpbnB1dFNhbXBsZVJhdGUsIG1peGVkQ2FsbGJhY2tTYW1wbGVSYXRlKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2V0RXh0ZXJuYWxJbnB1dFNhbXBsZVJhdGUoaW5wdXRTYW1wbGVSYXRlLCBtaXhlZENhbGxiYWNrU2FtcGxlUmF0ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDorr7nva7op4bpopHnvZHnu5zkvKDovpPov4fnqIvnmoTliIbovqjnjofvvIzkvY7liIbovqjnjodcclxuICogIEBwYXJhbSB3aWR0aDrlrr1cclxuICogIEBwYXJhbSBoZWlnaHQ66auYXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWRlb05ldFJlc29sdXRpb25Gb3JTZWNvbmQod2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldFZpZGVvTmV0UmVzb2x1dGlvbkZvclNlY29uZCh3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiuvue9ruinhumikeaVsOaNruS4iuihjOeahOeggeeOh+eahOS4iuS4i+mZkCznrKzkuozot68o6buY6K6k5LiN5LygKVxyXG4gKiAgQHBhcmFtIG1heEJpdHJhdGU6IOacgOWkp+eggeeOh++8jOWNleS9jWtiaXQvcy4gIDDml6DmlYhcclxuICogIEBwYXJhbSBtaW5CaXRyYXRlOiDmnIDlsI/noIHnjofvvIzljZXkvY1rYml0L3MuICAw5peg5pWIXHJcbiBcclxuICogIEByZXR1cm4gTm9uZVxyXG4gKlxyXG4gKiAgQHdhcm5pbmc66ZyA6KaB5Zyo6L+b5oi/6Ze05LmL5YmN6K6+572uXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWRlb0NvZGVCaXRyYXRlRm9yU2Vjb25kKG1heEJpdHJhdGUsIG1pbkJpdHJhdGUpIHtcclxuICAgIHlvdW1lLnlvdW1lX3NldFZpZGVvQ29kZUJpdHJhdGVGb3JTZWNvbmQobWF4Qml0cmF0ZSwgbWluQml0cmF0ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDojrflj5bop4bpopHmlbDmja7kuIrooYznmoTlvZPliY3noIHnjofjgIJcclxuICpcclxuICogIEByZXR1cm4g6KeG6aKR5pWw5o2u5LiK6KGM55qE5b2T5YmN56CB546HXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDdXJyZW50VmlkZW9Db2RlQml0cmF0ZSgpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9nZXRDdXJyZW50VmlkZW9Db2RlQml0cmF0ZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog6K6+572u6KeG6aKR5pWw5o2u5piv5ZCm5ZCM5oSP5byA5ZCv56Gs57yW56Gs6KejXHJcbiAqICBAcGFyYW0gYkVuYWJsZTogdHJ1ZTrlvIDlkK/vvIxmYWxzZTrkuI3lvIDlkK9cclxuICpcclxuICogIEByZXR1cm4gTm9uZVxyXG4gKlxyXG4gKiAgQG5vdGU6IOWunumZheaYr+WQpuW8gOWQr+ehrOino++8jOi/mOi3n+acjeWKoeWZqOmFjee9ruWPiuehrOS7tuaYr+WQpuaUr+aMgeacieWFs++8jOimgeWFqOmDqOaUr+aMgeW8gOWQr+aJjeS8muS9v+eUqOehrOino+OAguW5tuS4lOWmguaenOehrOe8luehrOino+Wksei0pe+8jOS5n+S8muWIh+aNouWbnui9r+ino+OAglxyXG4gKiAgQHdhcm5pbmc66ZyA6KaB5Zyo6L+b5oi/6Ze05LmL5YmN6K6+572uXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZShiRW5hYmxlKSB7XHJcbiAgICB5b3VtZS55b3VtZV9zZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZShiRW5hYmxlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiOt+WPluinhumikeaVsOaNruaYr+WQpuWQjOaEj+W8gOWQr+ehrOe8luehrOino1xyXG4gKiAgQHJldHVybiB0cnVlOuW8gOWQr++8jGZhbHNlOuS4jeW8gOWQr++8jCDpu5jorqTkuLp0cnVlO1xyXG4gKlxyXG4gKiAgQG5vdGU6IOWunumZheaYr+WQpuW8gOWQr+ehrOino++8jOi/mOi3n+acjeWKoeWZqOmFjee9ruWPiuehrOS7tuaYr+WQpuaUr+aMgeacieWFs++8jOimgeWFqOmDqOaUr+aMgeW8gOWQr+aJjeS8muS9v+eUqOehrOino+OAguW5tuS4lOWmguaenOehrOe8luehrOino+Wksei0pe+8jOS5n+S8muWIh+aNouWbnui9r+ino+OAglxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmlkZW9IYXJkd2FyZUNvZGVFbmFibGUoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfZ2V0VmlkZW9IYXJkd2FyZUNvZGVFbmFibGUoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOiuvue9ruinhumikeaXoOW4p+a4suafk+eahOetieW+hei2heaXtuaXtumXtO+8jOi2hei/h+i/meS4quaXtumXtOS8mue7meS4iuWxguWbnuiwg1xyXG4gKiAgQHBhcmFtIHRpbWVvdXQ6IOi2heaXtuaXtumXtO+8jOWNleS9jeS4uuavq+enklxyXG4qL1xyXG5mdW5jdGlvbiBzZXRWaWRlb05vRnJhbWVUaW1lb3V0KHRpbWVvdXQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9zZXRWaWRlb05vRnJhbWVUaW1lb3V0KHRpbWVvdXQpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog5p+l6K+i5aSa5Liq55So5oi36KeG6aKR5L+h5oGv77yI5pSv5oyB5YiG6L6o546H77yJXHJcbiAqICBAcGFyYW0gdXNlckxpc3Q6IOeUqOaIt0lE5YiX6KGo55qEanNvbuaVsOe7hFxyXG4gKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlVc2Vyc1ZpZGVvSW5mbyh1c2VyTGlzdCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3F1ZXJ5VXNlcnNWaWRlb0luZm8odXNlckxpc3QpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog6K6+572u5aSa5Liq55So5oi36KeG6aKR5L+h5oGv77yI5pSv5oyB5YiG6L6o546H77yJXHJcbiAqICBAcGFyYW0gdmlkZW9pbmZvTGlzdDog55So5oi35a+55bqU5YiG6L6o546H5YiX6KGo55qEanNvbuaVsOe7hFxyXG4gKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VXNlcnNWaWRlb0luZm8odmlkZW9pbmZvTGlzdCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3NldFVzZXJzVmlkZW9JbmZvKHZpZGVvaW5mb0xpc3QpO1xyXG59XHJcblxyXG4vKipcclxuICogIOWKn+iDveaPj+i/sDog576O6aKc5byA5YWz77yM6buY6K6k5piv5YWz6Zet576O6aKcXHJcbiAqICBAcGFyYW0gb3BlbjogdHJ1ZeihqOekuuW8gOWQr+e+juminO+8jGZhbHNl6KGo56S65YWz6Zet576O6aKcXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmVhdXRpZnkob3Blbikge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX29wZW5CZWF1dGlmeShvcGVuKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOe+juminOW8uuW6puWPguaVsOiuvue9rlxyXG4gKiAgQHBhcmFtIHBhcmFtOiDnvo7popzlj4LmlbDvvIwwLjAgLSAxLjAg77yM6buY6K6k5Li6MO+8jOWHoOS5juayoeaciee+juminOaViOaenO+8jDAuNeW3puWPs+aViOaenOaYjuaYvlxyXG4gKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gKi9cclxuZnVuY3Rpb24gYmVhdXRpZnlDaGFuZ2VkKHBhcmFtKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfYmVhdXRpZnlDaGFuZ2VkKHBhcmFtKTtcclxufVxyXG5cclxuLyoqXHJcbiAqICDlip/og73mj4/ov7A6IOeYpuiEuOW8gOWFs1xyXG4gKiAgQHBhcmFtIHBhcmFtOiB0cnVlIOW8gOWQr+eYpuiEuO+8jGZhbHNl5YWz6Zet77yM6buY6K6kIGZhbHNlXHJcbiAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJldGNoRmFjZShzdHJldGNoKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc3RyZXRjaEZhY2Uoc3RyZXRjaCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDosIPnlKjlkI7lkIzmraXlrozmiJDpuqblhYvpo47ph4rmlL7vvIzlj6rmmK/kuLrkuobmlrnkvr/kvb/nlKggSU0g55qE5b2V6Z+z5o6l5Y+j5pe25YiH5o2i6bqm5YWL6aOO5L2/55So5p2D44CCXHJcbiAqICBAcmV0dXJuIGJvb2wgLSDmiJDlip9cclxuICovXHJcbmZ1bmN0aW9uIHJlbGVhc2VNaWNTeW5jKCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX3JlbGVhc2VNaWNTeW5jKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAg5Yqf6IO95o+P6L+wOiDosIPnlKjlkI7mgaLlpI3puqblhYvpo47liLDph4rmlL7liY3nmoTnirbmgIHvvIzlj6rmmK/kuLrkuobmlrnkvr/kvb/nlKggSU0g55qE5b2V6Z+z5o6l5Y+j5pe25YiH5o2i6bqm5YWL6aOO5L2/55So5p2D44CCXHJcbiAqICBAcmV0dXJuIGJvb2wgLSB0cnVlIOaIkOWKn1xyXG4gKi9cclxuZnVuY3Rpb24gcmVzdW1lTWljU3luYygpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9yZXN1bWVNaWNTeW5jKCk7XHJcbn1cclxuXHJcbi8vIOiuvue9ruWSjOa1geeUu+W4g+Wkp+Wwj++8iOS4jeiuvue9ruWImem7mOiupOS4uumHh+mbhuinhumikeWIhui+qOeOh++8iVxyXG5mdW5jdGlvbiBzZXRNaXhWaWRlb1NpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgeW91bWUueW91bWVfc2V0TWl4VmlkZW9TaXplKHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcblxyXG4vLyAg6I635Y+W5pGE5YOP5aS05Liq5pWw44CCXHJcbmZ1bmN0aW9uIGdldENhbWVyYUNvdW50KCkge1xyXG4gICAgcmV0dXJuIHlvdW1lLnlvdW1lX2dldENhbWVyYUNvdW50KCk7XHJcbn1cclxuXHJcbi8vICDojrflj5ZjYW1lcmFpZCDlr7nlupTlkI3np7DjgIJcclxuZnVuY3Rpb24gZ2V0Q2FtZXJhTmFtZShjYW1lcmFpZCkge1xyXG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTAwKTtcclxuICAgIGJ1Zi50eXBlID0gcmVmLnR5cGVzLkNTdHJpbmc7XHJcbiAgICB2YXIgbGVuID0geW91bWUueW91bWVfZ2V0Q2FtZXJhTmFtZShjYW1lcmFpZCwgYnVmKTtcclxuICAgIHZhciBuYW1lID0gYnVmLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoKTtcclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxufVxyXG5cclxuLy8g6K6+572u5omT5byA5pGE5YOP5aS0aWTjgIJcclxuZnVuY3Rpb24gc2V0T3BlbkNhbWVyYUlkKGNhbWVyYWlkKSB7XHJcbiAgICByZXR1cm4geW91bWUueW91bWVfc2V0T3BlbkNhbWVyYUlkKGNhbWVyYWlkKTtcclxufVxyXG5cclxuLy8g6I635Y+W6KeG6aKR5pWw5o2uIOW4puinhumikeagvOW8j+aemuS4viB5dXYvYmdyYS9yZ2IyNFxyXG5mdW5jdGlvbiBnZXRWaWRlb0ZyYW1lTmV3KHVzZXJJZCwgbGVuLCB3aWR0aCwgaGVpZ2h0LCBmbXQpIHtcclxuICAgIHJldHVybiB5b3VtZS55b3VtZV9nZXRWaWRlb0ZyYW1lTmV3KHVzZXJJZCwgbGVuLCB3aWR0aCwgaGVpZ2h0LCBmbXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2aWRlb0VuZ2luZU1vZGVsRW5hYmxlZChlbmFiZWxkKSB7XHJcbiAgICB5b3VtZS55b3VtZV92aWRlb0VuZ2luZU1vZGVsRW5hYmxlZChlbmFiZWxkKTtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9XHJcbiAgICB7XHJcbiAgICAgICAgc3RhcnRHZXRNc2csXHJcbiAgICAgICAgZW1pdHRlcixcclxuICAgICAgICBpbml0LFxyXG4gICAgICAgIGpvaW5DaGFubmVsU2luZ2xlTW9kZSxcclxuICAgICAgICBzZXRFeHRlcm5hbElucHV0TW9kZSxcclxuICAgICAgICBzZXRBVlN0YXRpc3RpY0ludGVydmFsLFxyXG4gICAgICAgIHNldFZpZGVvTmV0UmVzb2x1dGlvbixcclxuICAgICAgICBzZXRWaWRlb0xvY2FsUmVzb2x1dGlvbixcclxuICAgICAgICBnZXRTREtWZXJzaW9uLFxyXG4gICAgICAgIHVuSW5pdCxcclxuICAgICAgICBzZXRWb2x1bWUsXHJcbiAgICAgICAgZ2V0Vm9sdW1lLFxyXG4gICAgICAgIHNldE1pY3JvcGhvbmVNdXRlLFxyXG4gICAgICAgIGdldE1pY3JvcGhvbmVNdXRlLFxyXG4gICAgICAgIGdldFNwZWFrZXJNdXRlLFxyXG4gICAgICAgIHNldFNwZWFrZXJNdXRlLFxyXG4gICAgICAgIHNldE90aGVyTWljTXV0ZSxcclxuICAgICAgICBzZXRPdGhlclNwZWFrZXJNdXRlLFxyXG4gICAgICAgIHNldExpc3Rlbk90aGVyVm9pY2UsXHJcbiAgICAgICAgc2V0TG9nTGV2ZWwsXHJcbiAgICAgICAgc2V0U2VydmVyUmVnaW9uLFxyXG4gICAgICAgIHN0b3BDYXB0dXJlLFxyXG4gICAgICAgIHN0YXJ0Q2FwdHVyZSxcclxuICAgICAgICBzZXRUZXN0Q29uZmlnLFxyXG4gICAgICAgIHNldE91dHB1dFRvU3BlYWtlcixcclxuICAgICAgICBzZXRVc2VNb2JpbGVOZXR3b3JrRW5hYmxlZCxcclxuICAgICAgICBnZXRVc2VNb2JpbGVOZXR3b3JrRW5hYmxlZCxcclxuICAgICAgICBzZXRVc2VyTG9nUGF0aCxcclxuICAgICAgICBwbGF5QmFja2dyb3VuZE11c2ljLFxyXG4gICAgICAgIHBhdXNlQmFja2dyb3VuZE11c2ljLFxyXG4gICAgICAgIHJlc3VtZUJhY2tncm91bmRNdXNpYyxcclxuICAgICAgICBzdG9wQmFja2dyb3VuZE11c2ljLFxyXG4gICAgICAgIHNldEJhY2tncm91bmRNdXNpY1ZvbHVtZSxcclxuICAgICAgICBzZXRIZWFkc2V0TW9uaXRvck9uLFxyXG4gICAgICAgIHNldFJldmVyYkVuYWJsZWQsXHJcbiAgICAgICAgc2V0VmFkQ2FsbGJhY2tFbmFibGVkLFxyXG4gICAgICAgIHNldE1pY0xldmVsQ2FsbGJhY2ssXHJcbiAgICAgICAgc2V0RmFyZW5kVm9pY2VMZXZlbENhbGxiYWNrLFxyXG4gICAgICAgIHNldFJlbGVhc2VNaWNXaGVuTXV0ZSxcclxuICAgICAgICBwYXVzZUNoYW5uZWwsXHJcbiAgICAgICAgcmVzdW1lQ2hhbm5lbCxcclxuICAgICAgICBzZXRSZWNvcmRpbmdUaW1lTXMsXHJcbiAgICAgICAgc2V0UGxheWluZ1RpbWVNcyxcclxuICAgICAgICByZXF1ZXN0UmVzdEFwaSxcclxuICAgICAgICBnZXRDaGFubmVsVXNlckxpc3QsXHJcbiAgICAgICAgc2V0VXNlclJvbGUsXHJcbiAgICAgICAgZ2V0VXNlclJvbGUsXHJcbiAgICAgICAgaXNCYWNrZ3JvdW5kTXVzaWNQbGF5aW5nLFxyXG4gICAgICAgIGlzSW5pdGVkLFxyXG4gICAgICAgIGlzSW5DaGFubmVsLFxyXG4gICAgICAgIHNlbmRNZXNzYWdlLFxyXG4gICAgICAgIGlucHV0QXVkaW9GcmFtZSxcclxuICAgICAgICBpbnB1dFZpZGVvRnJhbWUsXHJcbiAgICAgICAgZ2V0VmlkZW9GcmFtZSxcclxuICAgICAgICBzZXRWaWRlb0NhbGxiYWNrLFxyXG4gICAgICAgIHNldFZpZGVvRnBzLFxyXG4gICAgICAgIHN3aXRjaENhbWVyYSxcclxuICAgICAgICBzZXRFeHRlcm5hbElucHV0U2FtcGxlUmF0ZSxcclxuICAgICAgICBzZXRWaWRlb05ldFJlc29sdXRpb25Gb3JTZWNvbmQsXHJcbiAgICAgICAgc2V0VmlkZW9Db2RlQml0cmF0ZUZvclNlY29uZCxcclxuICAgICAgICBnZXRDdXJyZW50VmlkZW9Db2RlQml0cmF0ZSxcclxuICAgICAgICBzZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZSxcclxuICAgICAgICBnZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZSxcclxuICAgICAgICBzZXRWaWRlb05vRnJhbWVUaW1lb3V0LFxyXG4gICAgICAgIHF1ZXJ5VXNlcnNWaWRlb0luZm8sXHJcbiAgICAgICAgc2V0VXNlcnNWaWRlb0luZm8sXHJcbiAgICAgICAgb3BlbkJlYXV0aWZ5LFxyXG4gICAgICAgIGJlYXV0aWZ5Q2hhbmdlZCxcclxuICAgICAgICBzdHJldGNoRmFjZSxcclxuICAgICAgICByZWxlYXNlTWljU3luYyxcclxuICAgICAgICByZXN1bWVNaWNTeW5jLFxyXG4gICAgICAgIHNldFRva2VuLFxyXG4gICAgICAgIHNldEF1ZGlvUXVhbGl0eSxcclxuICAgICAgICBzdG9wSW5wdXRWaWRlb0ZyYW1lLFxyXG4gICAgICAgIGxlYXZlQ2hhbm5lbEFsbCxcclxuICAgICAgICBzZXRBdXRvU2VuZFN0YXR1cyxcclxuICAgICAgICBzZXRTZXJ2ZXJNb2RlLFxyXG4gICAgICAgIGtpY2tPdGhlckZyb21DaGFubmVsLFxyXG4gICAgICAgIG9wZW5WaWRlb0VuY29kZXIsXHJcbiAgICAgICAgcmVzZXRDYW1lcmEsXHJcbiAgICAgICAgc2V0Q2FwdHVyZUZyb250Q2FtZXJhRW5hYmxlLFxyXG4gICAgICAgIG1hc2tWaWRlb0J5VXNlcklkLFxyXG4gICAgICAgIHNldE1peFZpZGVvU2l6ZSxcclxuICAgICAgICBnZXRDYW1lcmFDb3VudCxcclxuICAgICAgICBnZXRDYW1lcmFOYW1lLFxyXG4gICAgICAgIHNldE9wZW5DYW1lcmFJZCxcclxuICAgICAgICBnZXRWaWRlb0ZyYW1lTmV3LFxyXG4gICAgICAgIHZpZGVvRW5naW5lTW9kZWxFbmFibGVkLFxyXG4gICAgICAgIHVwZGF0ZUNhbnZhc1xyXG4gICAgfVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgeW91bWUgPSByZXF1aXJlKFwiLi9Zb3VNZVNES1wiKTtcclxudmFyIHJlZiA9IHJlcXVpcmUoXCJyZWZcIik7XHJcbnZhciBZTUxvZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi9ZTUxvZ1V0aWxzXCIpO1xyXG4vLyDlm57osIPlh73mlbDmmoLlrZhcclxudmFyIGxvZ2luQ2FsbGJhY2sgPSBudWxsO1xyXG52YXIgam9pblJvb21DYWxsYmFjayA9IG51bGw7XHJcbnZhciBsZWF2ZVJvb21DYWxsYmFjayA9IG51bGw7XHJcbnZhciBvcGVuTWljcm9QaG9uZUNhbGxiYWNrID0gbnVsbDtcclxudmFyIGNsb3NlTWljcm9QaG9uZUNhbGxiYWNrID0gbnVsbDtcclxudmFyIG9wZW5TcGVha2VyQ2FsbGJhY2sgPSBudWxsO1xyXG52YXIgY2xvc2VTcGVha2VyQ2FsbGJhY2sgPSBudWxsO1xyXG52YXIgb3BlbkNhbWVyYUNhbGxiYWNrID0gbnVsbDtcclxudmFyIGNsb3NlQ2FtZXJhQ2FsbGJhY2sgPSBudWxsO1xyXG52YXIgcGF1c2VDaGFubmVsQ2FsbGJhY2sgPSBudWxsO1xyXG52YXIgcmVzdW1lQ2hhbm5lbENhbGxiYWNrID0gbnVsbDtcclxudmFyIG1hc2tWaWRlb0ZvclVzZXJDYWxsYmFjayA9IHt9O1xyXG52YXIgcmVzdW1lVmlkZW9Gb3JVc2VyQ2FsbGJhY2sgPSB7fTtcclxudmFyIHJlcXVlc3RSZXN0QXBpQ2FsbGJhY2sgPSB7fTtcclxudmFyIHNlbmRNZXNzYWdlQ2FsbGJhY2sgPSB7fTtcclxuLyoqXHJcbiAq5Yik5pat5piv5ZCm5Li65Ye95pWwXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gZnVuXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bikge1xyXG4gICAgcmV0dXJuIGZ1biAmJiB0eXBlb2YgZnVuID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBZb3VNZVZpZGVvXHJcbiAqL1xyXG52YXIgWW91TWVWaWRlbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFlvdU1lVmlkZW8oKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWunuS+i1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtZb3VNZVZpZGVvfVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgLy8g5LqL5Lu25b6q546vXHJcbiAgICAgICAgICAgIHlvdW1lLnN0YXJ0R2V0TXNnKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKHRoaXMuX2luc3RhbmNlID0gbmV3IFlvdU1lVmlkZW8oKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7ml6Xlv5fnrYnnuqcoSlPlsYLml6Xlv5cpXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8uc2V0SlNMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xyXG4gICAgICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLnNldExvZ0xldmVsKGxldmVsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaXpeW/l+etiee6pyhKU+WxguaXpeW/lylcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLmdldEpTTG9nTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLmdldExvZ0xldmVsKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyQXBwS2V5XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyQVBQU2VjcmV0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2VydmVyUmVnaW9uSWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwRXh0U2VydmVyUmVnaW9uTmFtZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoc3RyQXBwS2V5LCBzdHJBUFBTZWNyZXQsIHNlcnZlclJlZ2lvbklkLCBwRXh0U2VydmVyUmVnaW9uTmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgbG9naW5DYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLmluaXQoc3RyQXBwS2V5LCBzdHJBUFBTZWNyZXQsIHNlcnZlclJlZ2lvbklkLCBwRXh0U2VydmVyUmVnaW9uTmFtZSk7XHJcbiAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWKn+iDveaPj+i/sDrlj43liJ3lp4vljJblvJXmk47vvIzlnKjlupTnlKjpgIDlh7rkuYvliY3pnIDopoHosIPnlKjov5nkuKrmjqXlj6Pph4rmlL7otYTmupDjgIJcclxuICAgICAqICAgICAgICAg6L+Z5piv5LiA5Liq5ZCM5q2l6LCD55So5o6l5Y+j77yM5Ye95pWw6L+U5Zue5pe26KGo5piO5pON5L2c5bey57uP5a6M5oiQ44CCXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgICAgIOWFtuS7lui/lOWbnuWAvOihqOaYjuWPkeeUn+S6humUmeivr++8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS51bmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnVuaW5pdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sO+8muWKoOWFpeivremfs+mikemBk1xyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gc3RyVXNlcklEOiDnlKjmiLdJRO+8jOimgeS/neivgeWFqOWxgOWUr+S4gFxyXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBzdHJDaGFubmVsSUQ6IOmikemBk0lE77yM6KaB5L+d6K+B5YWo5bGA5ZSv5LiAXHJcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IGVVc2VyUm9sZTog55So5oi36KeS6Imy77yM55So5LqO5Yaz5a6a6K6y6K+dL+aSreaUvuiDjOaZr+mfs+S5kOetieadg+mZkFxyXG4gICAgICpcclxuICAgICAqICBAcmV0dXJuIOmUmeivr+egge+8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5qb2luQ2hhbm5lbFNpbmdsZU1vZGUgPSBmdW5jdGlvbiAoc3RyVXNlcklELCBzdHJDaGFubmVsSUQsIGVVc2VyUm9sZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgam9pblJvb21DYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLmpvaW5DaGFubmVsU2luZ2xlTW9kZShzdHJVc2VySUQsIHN0ckNoYW5uZWxJRCwgZVVzZXJSb2xlKTtcclxuICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDrpgIDlh7rmiYDmnInor63pn7PpopHpgZNcclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybiDplJnor6/noIHvvIzor6bop4FZb3VNZUNvbnN0RGVmaW5lLmjlrprkuYlcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUubGVhdmVDaGFubmVsQWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxlYXZlUm9vbUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2RlID0geW91bWUubGVhdmVDaGFubmVsQWxsKCk7XHJcbiAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A66bqm5YWL6aOOIOmdmemfsyDmiZPlvIAv5YWz6ZetXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBiT246dHJ1ZeKAlOKAlOWFs+mXrem6puWFi+mjju+8jGZhbHNl4oCU4oCU5byA5ZCv6bqm5YWL6aOOXHJcbiAgICAgKiAgQHJldHVybiDml6BcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0TWljcm9waG9uZU11dGUgPSBmdW5jdGlvbiAoYk9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoYk9uKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZU1pY3JvUGhvbmVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3Blbk1pY3JvUGhvbmVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlvdW1lLnNldE1pY3JvcGhvbmVNdXRlKGJPbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOuiOt+WPlum6puWFi+mjjiDpnZnpn7Mg54q25oCBXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4gdHJ1ZeKAlOKAlOWFs+mXre+8jGZhbHNl4oCU4oCU5omT5byAXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmdldE1pY3JvcGhvbmVNdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5nZXRNaWNyb3Bob25lTXV0ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDrojrflj5bmiazlo7Dlmagg6Z2Z6Z+zIOeKtuaAgVxyXG4gICAgICpcclxuICAgICAqICBAcmV0dXJuIHRydWXigJTigJTlhbPpl63miazlo7DlmajvvIxmYWxzZeKAlOKAlOW8gOWQr+aJrOWjsOWZqFxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRTcGVha2VyTXV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0U3BlYWtlck11dGUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A65oms5aOw5ZmoIOmdmemfsyDmiZPlvIAv5YWz6ZetXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBiT246dHJ1ZeKAlOKAlOWFs+mXreaJrOWjsOWZqO+8jGZhbHNl4oCU4oCU5byA5ZCv5oms5aOw5ZmoXHJcbiAgICAgKiAgQHJldHVybiDml6BcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0U3BlYWtlck11dGUgPSBmdW5jdGlvbiAoYk9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoYk9uKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZVNwZWFrZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3BlblNwZWFrZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlvdW1lLnNldFNwZWFrZXJNdXRlKGJPbik7XHJcbiAgICB9O1xyXG4gICAgLy8g5YGc5q2i5o2V6I635pys5py65pGE5YOP5aS05pWw5o2uXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zdG9wQ2FwdHVyZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICBjbG9zZUNhbWVyYUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2RlID0geW91bWUuc3RvcENhcHR1cmUoKTtcclxuICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuICAgIC8vIOW8gOWni+aNleiOt+acrOacuuaRhOWDj+WktOaVsOaNrlxyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc3RhcnRDYXB0dXJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgIG9wZW5DYW1lcmFDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLnN0YXJ0Q2FwdHVyZSgpO1xyXG4gICAgICAgIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlip/og73mj4/ov7A6ICAg6K6+572u5piv5ZCm55Sx5aSW6YOo6L6T5YWl6Z+z6KeG6aKRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJJbnB1dE1vZGVFbmFibGVkOiB0cnVlOuWklumDqOi+k+WFpeaooeW8j++8jGZhbHNlOlNES+WGhemDqOmHh+mbhuaooeW8jyDpu5jorqTkuLpmYWxzZVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRFeHRlcm5hbElucHV0TW9kZSA9IGZ1bmN0aW9uIChiSW5wdXRNb2RlRW5hYmxlZCkge1xyXG4gICAgICAgIHlvdW1lLnNldEV4dGVybmFsSW5wdXRNb2RlKGJJbnB1dE1vZGVFbmFibGVkKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9rumfs+inhumikee7n+iuoeaVsOaNruaXtumXtOmXtOmalFxyXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbDrml7bpl7Tpl7TpmpQg5pyA5L2O5Li6NTAwbXNcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0QVZTdGF0aXN0aWNJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgIHlvdW1lLnNldEFWU3RhdGlzdGljSW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDog6K6+572u5pys5Zyw6KeG6aKR5riy5p+T5Zue6LCD55qE5YiG6L6o546HLOmrmOWIhui+qOeOh1xyXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSB3aWR0aDrlrr1cclxuICAgICAqICBAcGFyYW0ge251bWJlcn0gaGVpZ2h0OumrmFxyXG4gICAgICogIEByZXR1cm4ge251bWJlcn1ZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAgICAgKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0VmlkZW9Mb2NhbFJlc29sdXRpb24gPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRWaWRlb0xvY2FsUmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9ruinhumikee9kee7nOS8oOi+k+i/h+eoi+eahOWIhui+qOeOhyzpq5jliIbovqjnjodcclxuICAgICAqICBAcGFyYW0ge251bWJlcn0gd2lkdGg65a69XHJcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IGhlaWdodDrpq5hcclxuICAgICAqICBAcmV0dXJuIHtudW1iZXJ9WU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gICAgICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFZpZGVvTmV0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldFZpZGVvTmV0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7lkozmtYHnlLvluIPlpKflsI/vvIjkuI3orr7nva7liJnpu5jorqTkuLrph4fpm4bop4bpopHliIbovqjnjofvvIlcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldE1peFZpZGVvU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgeW91bWUuc2V0TWl4VmlkZW9TaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8v6K6+5Li6dHJ1Zei/lOWbnmJncuagvOW8j+aVsOaNriDorr7kuLpmYWxzZei/lOWbnmJncmEveXV25qC85byPIOm7mOiupOS4unRydWVcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnZpZGVvRW5naW5lTW9kZWxFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJlbGQpIHtcclxuICAgICAgICB5b3VtZS52aWRlb0VuZ2luZU1vZGVsRW5hYmxlZChlbmFiZWxkKTtcclxuICAgIH07XHJcbiAgICAvLyAg6I635Y+W5pGE5YOP5aS05Liq5pWw44CCXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRDYW1lcmFDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0Q2FtZXJhQ291bnQoKTtcclxuICAgIH07XHJcbiAgICAvLyAg6I635Y+WY2FtZXJhaWQg5a+55bqU5ZCN56ew44CCXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRDYW1lcmFOYW1lID0gZnVuY3Rpb24gKGNhbWVyYWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLmdldENhbWVyYU5hbWUoY2FtZXJhaWQpO1xyXG4gICAgfTtcclxuICAgIC8vIOiuvue9ruaJk+W8gOaRhOWDj+WktGlk44CCXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRPcGVuQ2FtZXJhSWQgPSBmdW5jdGlvbiAoY2FtZXJhaWQpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0T3BlbkNhbWVyYUlkKGNhbWVyYWlkKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7op4bpopHlm57osINcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFZpZGVvQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldFZpZGVvQ2FsbGJhY2soKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A66K6+572u5piv5ZCm6YCa55+l5YW25LuW5Lq66Ieq5bex55qE5byA5YWz6bqm5YWL6aOO5ZKM5oms5aOw5Zmo55qE54q25oCBXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSBiQXV0b1NlbmQ6dHJ1ZeKAlOKAlOmAmuefpe+8jGZhbHNl4oCU4oCU5LiN6YCa55+lXHJcbiAgICAgKiAgQHJldHVybiDml6BcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0QXV0b1NlbmRTdGF0dXMgPSBmdW5jdGlvbiAoYkF1dG9TZW5kKSB7XHJcbiAgICAgICAgeW91bWUuc2V0QXV0b1NlbmRTdGF0dXMoYkF1dG9TZW5kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A66K6+572u6Z+z6YeP77yM5Y+W5YC86IyD5Zu05pivWzAtMTAwXSAxMDDooajnpLrmnIDlpKfpn7Pph4/vvIwg6buY6K6k6Z+z6YeP5pivMTAwXHJcbiAgICAgKiAgQHBhcmFtIHVpVm9sdW1lOiDpn7Pph49cclxuICAgICAqICBAcmV0dXJuIOaXoFxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodWlWb2x1bWUpIHtcclxuICAgICAgICB5b3VtZS5zZXRWb2x1bWUodWlWb2x1bWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDrojrflj5bpn7Pph4/lpKflsI8s5q2k6Z+z6YeP5YC85Li656iL5bqP5YaF6YOo55qE6Z+z6YeP77yM5LiO57O757uf6Z+z6YeP55u45LmY5b6X5Yiw56iL5bqP5L2/55So55qE5a6e6ZmF6Z+z6YePXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4g6Z+z6YeP5YC8WzAsMTAwXVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLmdldFZvbHVtZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIOiOt+WPluinhumikeaVsOaNrlxyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuZ2V0VmlkZW9GcmFtZSA9IGZ1bmN0aW9uICh1c2VySWQsIGxlbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5nZXRWaWRlb0ZyYW1lKHVzZXJJZCwgbGVuLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvLyDojrflj5bop4bpopHmlbDmja4g5bim6KeG6aKR5qC85byP5p6a5Li+IHl1di9iZ3JhL3JnYjI0XHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRWaWRlb0ZyYW1lTmV3ID0gZnVuY3Rpb24gKHVzZXJJZCwgbGVuLCB3aWR0aCwgaGVpZ2h0LCBmbXQpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0VmlkZW9GcmFtZU5ldyh1c2VySWQsIGxlbiwgd2lkdGgsIGhlaWdodCwgZm10KTtcclxuICAgIH07XHJcbiAgICAvLyDmmoLlgZzpgJror53vvIzph4rmlL7lr7npuqblhYvpo47nrYnorr7lpIfotYTmupDnmoTljaDnlKhcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnBhdXNlQ2hhbm5lbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICBwYXVzZUNoYW5uZWxDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLnBhdXNlQ2hhbm5lbCgpO1xyXG4gICAgICAgIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9O1xyXG4gICAgLy8g5oGi5aSN6YCa6K+dXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5yZXN1bWVDaGFubmVsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgIHJlc3VtZUNoYW5uZWxDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLnJlc3VtZUNoYW5uZWwoKTtcclxuICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuICAgIC8vIOWxj+iUvS/mgaLlpI3mn5DkuKpVc2VySWTnmoTop4bpopHmtYFcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLm1hc2tWaWRlb0J5VXNlcklkID0gZnVuY3Rpb24gKHVzZXJpZCwgbWFzaywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLm1hc2tWaWRlb0J5VXNlcklkKHVzZXJpZCwgbWFzaywgZnVuY3Rpb24gKGVyciwgb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1ZpZGVvRm9yVXNlckNhbGxiYWNrW3VzZXJpZF0gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZVZpZGVvRm9yVXNlckNhbGxiYWNrW3VzZXJpZF0gPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfTtcclxuICAgIC8v6I635Y+W54mI5pys5Y+3XHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRTREtWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5nZXRTREtWZXJzaW9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOuiuvue9rui6q+S7vemqjOivgeeahHRva2VuXHJcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHN0clRva2VuOiDouqvku73pqozor4HnlKh0b2tlbu+8jOiuvue9ruS4uk5VTEzmiJbogIXnqbrlrZfnrKbkuLLvvIzmuIXnqbp0b2tlbuWAvOOAglxyXG4gICAgICogIEByZXR1cm4g5pegXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFRva2VuID0gZnVuY3Rpb24gKHN0clRva2VuKSB7XHJcbiAgICAgICAgeW91bWUuc2V0VG9rZW4oc3RyVG9rZW4pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDog6K6+572uQXVkaW/nmoTkvKDovpPotKjph49cclxuICAgICAqICBAcGFyYW0gcXVhbGl0eTogMDogbG93IDE6IGhpZ2hcclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybiBOb25lXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldEF1ZGlvUXVhbGl0eSA9IGZ1bmN0aW9uIChxdWFsaXR5KSB7XHJcbiAgICAgICAgeW91bWUuc2V0QXVkaW9RdWFsaXR5KHF1YWxpdHkpO1xyXG4gICAgfTtcclxuICAgIC8v6K6+572u5LuW5Lq66bqm5YWL6aOO54q25oCBXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRPdGhlck1pY011dGUgPSBmdW5jdGlvbiAodXNlcmlkLCBtdXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldE90aGVyTWljTXV0ZSh1c2VyaWQsIG11dGUpO1xyXG4gICAgfTtcclxuICAgIC8v6K6+572u5LuW5Lq65oms5aOw5Zmo54q25oCBXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRPdGhlclNwZWFrZXJNdXRlID0gZnVuY3Rpb24gKHVzZXJpZCwgbXV0ZSkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRPdGhlclNwZWFrZXJNdXRlKHVzZXJpZCwgbXV0ZSk7XHJcbiAgICB9O1xyXG4gICAgLy/orr7nva7mmK/lkKblkKzmn5DkurrnmoTor63pn7PjgIJcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldExpc3Rlbk90aGVyVm9pY2UgPSBmdW5jdGlvbiAodXNlcmlkLCBpc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldExpc3Rlbk90aGVyVm9pY2UodXNlcmlkLCBpc29uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9ruaXpeW/l+etiee6p1xyXG4gICAgICogIEBwYXJhbSBjb25zb2xlTGV2ZWw6IOaOp+WItuWPsOaXpeW/l+etiee6p1xyXG4gICAgICogIEBwYXJhbSBmaWxlTGV2ZWw6IOaWh+S7tuaXpeW/l+etiee6p1xyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChjb25zb2xlTGV2ZWwsIGZpbGVMZXZlbCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRMb2dMZXZlbChjb25zb2xlTGV2ZWwsIGZpbGVMZXZlbCk7XHJcbiAgICB9O1xyXG4gICAgLy/orr7nva7mnI3liqHlmajljLrln59cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFNlcnZlclJlZ2lvbiA9IGZ1bmN0aW9uIChzZXJ2ZXJSZWdpb25JZCwgc3RyRXh0UmVnaW9uTmFtZSkge1xyXG4gICAgICAgIHlvdW1lLnNldFNlcnZlclJlZ2lvbihzZXJ2ZXJSZWdpb25JZCwgc3RyRXh0UmVnaW9uTmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy/mmK/lkKbmmK/mtYvor5XmqKHlvI8s5rWL6K+V5qih5byP5L2/55So5rWL6K+V5pyNXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRUZXN0Q29uZmlnID0gZnVuY3Rpb24gKGJUZXN0KSB7XHJcbiAgICAgICAgeW91bWUuc2V0VGVzdENvbmZpZyhiVGVzdCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOuWIh+aNouivremfs+i+k+WHuuiuvuWkh1xyXG4gICAgICogIOm7mOiupOi+k+WHuuWIsOaJrOWjsOWZqO+8jOWcqOWKoOWFpeaIv+mXtOaIkOWKn+WQjuiuvue9ru+8jOWmguaXoOWQrOetkui+k+WHuueahOmcgOaxguWwvemHj+S4jeimgeiwg+eUqOivpeaOpeWPo+OAglxyXG4gICAgICpcclxuICAgICAqICBAcGFyYW0gYk91dHB1dFRvU3BlYWtlcjp0cnVl4oCU4oCU5L2/55So5oms5aOw5Zmo77yMZmFsc2XigJTigJTkvb/nlKjlkKznrZJcclxuICAgICAqICBAcmV0dXJuIOmUmeivr+egge+8jOivpuingVlvdU1lQ29uc3REZWZpbmUuaOWumuS5iVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRPdXRwdXRUb1NwZWFrZXIgPSBmdW5jdGlvbiAoYk91dHB1dFRvU3BlYWtlcikge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRPdXRwdXRUb1NwZWFrZXIoYk91dHB1dFRvU3BlYWtlcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOuWQr+eUqC/npoHnlKjnp7vliqjnvZHnu5xcclxuICAgICAqXHJcbiAgICAgKiAgQHBhcmFtIGJFbmFibGVkOnRydWUt5Y+v5Lul5ZCv55So77yMZmFsc2Ut56aB55So77yM6buY6K6k56aB55SoXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4g5pegXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFVzZU1vYmlsZU5ldHdvcmtFbmFibGVkID0gZnVuY3Rpb24gKGJFbmFibGVkKSB7XHJcbiAgICAgICAgeW91bWUuc2V0VXNlTW9iaWxlTmV0d29ya0VuYWJsZWQoYkVuYWJsZWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDrmmK/lkKblj6/kvb/nlKjnp7vliqjnvZHnu5xcclxuICAgICAqXHJcbiAgICAgKiAgQHJldHVybiB0cnVlLeWPr+S7peS9v+eUqO+8jGZhbHNlLeemgeeUqFxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRVc2VNb2JpbGVOZXR3b3JrRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0VXNlTW9iaWxlTmV0d29ya0VuYWJsZWQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9rueUqOaIt+iHquWumuS5iUxvZ+i3r+W+hFxyXG4gICAgICogIEBwYXJhbSBzdHJGaWxlUGF0aCBMb2fmlofku7bnmoTot6/lvoRcclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRVc2VyTG9nUGF0aCA9IGZ1bmN0aW9uIChzdHJGaWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRVc2VyTG9nUGF0aChzdHJGaWxlUGF0aCk7XHJcbiAgICB9O1xyXG4gICAgLy8g5pKt5pS+6IOM5pmv6Z+z5LmQXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5wbGF5QmFja2dyb3VuZE11c2ljID0gZnVuY3Rpb24gKHN0ckZpbGVQYXRoLCBiUmVwZWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnBsYXlCYWNrZ3JvdW5kTXVzaWMoc3RyRmlsZVBhdGgsIGJSZXBlYXQpO1xyXG4gICAgfTtcclxuICAgIC8vIOaaguWBnOiDjOaZr+mfs+S5kFxyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUucGF1c2VCYWNrZ3JvdW5kTXVzaWMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnBhdXNlQmFja2dyb3VuZE11c2ljKCk7XHJcbiAgICB9O1xyXG4gICAgLy8g5oGi5aSN6IOM5pmv6Z+z5LmQXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5yZXN1bWVCYWNrZ3JvdW5kTXVzaWMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnJlc3VtZUJhY2tncm91bmRNdXNpYygpO1xyXG4gICAgfTtcclxuICAgIC8vIOWBnOatouiDjOaZr+mfs+S5kFxyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc3RvcEJhY2tncm91bmRNdXNpYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc3RvcEJhY2tncm91bmRNdXNpYygpO1xyXG4gICAgfTtcclxuICAgIC8vIOiuvue9ruiDjOaZr+mfs+S5kOmfs+mHj1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0QmFja2dyb3VuZE11c2ljVm9sdW1lID0gZnVuY3Rpb24gKHZvbCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRCYWNrZ3JvdW5kTXVzaWNWb2x1bWUodm9sKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7mmK/lkKblsIbpgJrov4fogLPmnLrnm5HlkKzoh6rlt7HnmoTlo7Dpn7NcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldEhlYWRzZXRNb25pdG9yT24gPSBmdW5jdGlvbiAobWljRW5hYmxlZCwgYmdtRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRIZWFkc2V0TW9uaXRvck9uKG1pY0VuYWJsZWQsIGJnbUVuYWJsZWQpO1xyXG4gICAgfTtcclxuICAgIC8vIOiuvue9ruaYr+WQpuiuvue9ruS4u+aSrea3t+WTjeaooeW8j1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0UmV2ZXJiRW5hYmxlZCA9IGZ1bmN0aW9uIChiRW5hYmxlZCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRSZXZlcmJFbmFibGVkKGJFbmFibGVkKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7mmK/lkKblkK/liqjor63pn7Pmo4DmtYvlm57osINcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFZhZENhbGxiYWNrRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldFZhZENhbGxiYWNrRW5hYmxlZChlbmFibGVkKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7mmK/lkKblkK/liqjorrLor53pn7Pph4/lm57osINcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldE1pY0xldmVsQ2FsbGJhY2sgPSBmdW5jdGlvbiAobWF4TGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0TWljTGV2ZWxDYWxsYmFjayhtYXhMZXZlbCk7XHJcbiAgICB9O1xyXG4gICAgLy8g6K6+572u5piv5ZCm5ZCv5Yqo6L+c56uv6K+t6Z+z6Z+z6YeP5Zue6LCDXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRGYXJlbmRWb2ljZUxldmVsQ2FsbGJhY2sgPSBmdW5jdGlvbiAobWF4TGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0RmFyZW5kVm9pY2VMZXZlbENhbGxiYWNrKG1heExldmVsKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7lvZPpuqblhYvpo47pnZnpn7Pml7bvvIzmmK/lkKbph4rmlL7puqblhYvpo47orr7lpIfvvIzlnKjliJ3lp4vljJbkuYvlkI7jgIHliqDlhaXmiL/pl7TkuYvliY3osIPnlKhcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFJlbGVhc2VNaWNXaGVuTXV0ZSA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnNldFJlbGVhc2VNaWNXaGVuTXV0ZShlbmFibGVkKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7lvZPliY3lvZXpn7PnmoTml7bpl7TmiLNcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFJlY29yZGluZ1RpbWVNcyA9IGZ1bmN0aW9uICh0aW1lTXMpIHtcclxuICAgICAgICB5b3VtZS5zZXRSZWNvcmRpbmdUaW1lTXModGltZU1zKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7lvZPliY3mkq3mlL7nmoTml7bpl7TmiLNcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFBsYXlpbmdUaW1lTXMgPSBmdW5jdGlvbiAodGltZU1zKSB7XHJcbiAgICAgICAgeW91bWUuc2V0UGxheWluZ1RpbWVNcyh0aW1lTXMpO1xyXG4gICAgfTtcclxuICAgIC8vIOiuvue9ruacjeWKoeWZqOaooeW8j1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0U2VydmVyTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XHJcbiAgICAgICAgeW91bWUuc2V0U2VydmVyTW9kZShtb2RlKTtcclxuICAgIH07XHJcbiAgICAvL1Jlc3RBcGnigJTigJTmlK/mjIHkuLvmkq3nm7jlhbPkv6Hmga/mn6Xor6JcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnJlcXVlc3RSZXN0QXBpID0gZnVuY3Rpb24gKHN0ckNvbW1hbmQsIHN0clF1ZXJ5Qm9keSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgaVJlcXVlc3RJZCA9IHJlZi5hbGxvYyhyZWYudHlwZXMudWxvbmdsb25nKTtcclxuICAgICAgICB2YXIgY29kZSA9IHlvdW1lLnJlcXVlc3RSZXN0QXBpKHN0ckNvbW1hbmQsIHN0clF1ZXJ5Qm9keSwgaVJlcXVlc3RJZCk7XHJcbiAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0UmVzdEFwaUNhbGxiYWNrW3JlZi5kZXJlZihpUmVxdWVzdElkKV0gPSBjYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZi5kZXJlZihpUmVxdWVzdElkKTtcclxuICAgIH07XHJcbiAgICAvL+afpeivoumikemBk+W9k+WJjeeahOeUqOaIt+WIl+ihqO+8jG1heENvdW506KGo5piO5pyA5aSa6I635Y+W5aSa5bCR77yMLTHooajnpLrojrflj5bmiYDmnIlcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmdldENoYW5uZWxVc2VyTGlzdCA9IGZ1bmN0aW9uIChzdHJDaGFubmVsSUQsIG1heENvdW50LCBub3RpZnlNZW1DaGFuZ2UpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0Q2hhbm5lbFVzZXJMaXN0KHN0ckNoYW5uZWxJRCwgbWF4Q291bnQsIG5vdGlmeU1lbUNoYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgLy8g6L+b5YWl5oi/6Ze05ZCO77yM5YiH5o2i6Lqr5Lu9XHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRVc2VyUm9sZSA9IGZ1bmN0aW9uICh1c2VyUm9sZSkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRVc2VyUm9sZSh1c2VyUm9sZSk7XHJcbiAgICB9O1xyXG4gICAgLy8g6I635Y+W6Lqr5Lu9XHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRVc2VyUm9sZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0VXNlclJvbGUoKTtcclxuICAgIH07XHJcbiAgICAvLyDog4zmma/pn7PkuZDmmK/lkKblnKjmkq3mlL5cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmlzQmFja2dyb3VuZE11c2ljUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuaXNCYWNrZ3JvdW5kTXVzaWNQbGF5aW5nKCk7XHJcbiAgICB9O1xyXG4gICAgLy8g5piv5ZCm5Yid5aeL5YyW5oiQ5YqfXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5pc0luaXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuaXNJbml0ZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyDmmK/lkKblnKjmn5DkuKror63pn7PmiL/pl7TlhoVcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmlzSW5DaGFubmVsID0gZnVuY3Rpb24gKHBDaGFubmVsSUQpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuaXNJbkNoYW5uZWwocENoYW5uZWxJRCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlip/og73mj4/ov7A6ICAg5ZCR5oi/6Ze05bm/5pKt5raI5oGvXHJcbiAgICAgKiBAcGFyYW0gcENoYW5uZWxJRDog5bm/5pKt5oi/6Ze0XHJcbiAgICAgKiBAcGFyYW0gcENvbnRlbnQ6IOW5v+aSreWGheWuuS3mlofmnKzkuLJcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0SUQ66L+U5Zue5raI5oGv5qCH6K+G77yM5Zue6LCD55qE5pe25YCZ5Lya5Zue5Lyg6K+l5YC8XHJcbiAgICAgKiBAcmV0dXJuICAgWU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gICAgICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKHBDaGFubmVsSUQsIHBDb250ZW50LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBpUmVxdWVzdElkID0gcmVmLmFsbG9jKHJlZi50eXBlcy51bG9uZ2xvbmcpO1xyXG4gICAgICAgIHZhciBjb2RlID0geW91bWUuc2VuZE1lc3NhZ2UocENoYW5uZWxJRCwgcENvbnRlbnQsIGlSZXF1ZXN0SWQpO1xyXG4gICAgICAgIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgc2VuZE1lc3NhZ2VDYWxsYmFja1tyZWYuZGVyZWYoaVJlcXVlc3RJZCldID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWYuZGVyZWYoaVJlcXVlc3RJZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDmiormn5DkurrouKLlh7rmiL/pl7RcclxuICAgICAqICBAcGFyYW0gIHBVc2VySUQ6IOiiq+i4oueahOeUqOaIt0lEXHJcbiAgICAgKiAgQHBhcmFtICBwQ2hhbm5lbElEOiDku47lk6rkuKrmiL/pl7TouKLlh7pcclxuICAgICAqICBAcGFyYW0gIGxhc3RUaW1lOiDouKLlh7rlkI7vvIzlpJrplb/ml7bpl7TlhoXkuI3lhYHorrjlho3mrKHov5vlhaVcclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5raWNrT3RoZXJGcm9tQ2hhbm5lbCA9IGZ1bmN0aW9uIChwVXNlcklELCBwQ2hhbm5lbElELCBsYXN0VGltZSkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5raWNrT3RoZXJGcm9tQ2hhbm5lbChwVXNlcklELCBwQ2hhbm5lbElELCBsYXN0VGltZSk7XHJcbiAgICB9O1xyXG4gICAgLy8g6K6+572u5byA5ZCv6KeG6aKR57yW56CB5ZmoXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5vcGVuVmlkZW9FbmNvZGVyID0gZnVuY3Rpb24gKHBGaWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5vcGVuVmlkZW9FbmNvZGVyKHBGaWxlUGF0aCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqICDlip/og73mj4/ov7A6ICjkuIPniZvmjqXlj6Mp5bCG5o+Q5L6b55qE6Z+z6aKR5pWw5o2u5re35ZCI5Yiw6bqm5YWL6aOO5oiW6ICF5oms5aOw5Zmo55qE6Z+z6L2o6YeM6Z2i44CCXHJcbiAgICAqICBAcGFyYW0gZGF0YSDmjIflkJFQQ03mlbDmja7nmoTnvJPlhrLljLpcclxuICAgICogIEBwYXJhbSBsZW4gIOmfs+mikeaVsOaNrueahOWkp+Wwj1xyXG4gICAgKiAgQHBhcmFtIHRpbWVzdGFtcCDml7bpl7TmiLNcclxuICAgICogIEByZXR1cm4gWU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gICAgKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5pbnB1dEF1ZGlvRnJhbWUgPSBmdW5jdGlvbiAoZGF0YSwgbGVuLCB0aW1lc3RhbXApIHtcclxuICAgICAgICByZXR1cm4geW91bWUuaW5wdXRBdWRpb0ZyYW1lKGRhdGEsIGxlbiwgdGltZXN0YW1wKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogIOWKn+iDveaPj+i/sDogKOS4g+eJm+aOpeWPoynlsIbmj5DkvpvnmoTop4bpopHmlbDmja7liLBwcm9kdWNlcuOAglxyXG4gICAgKiAgQHBhcmFtIGRhdGEg5oyH5ZCR6KeG6aKR5pWw5o2u55qE57yT5Yay5Yy6XHJcbiAgICAqICBAcGFyYW0gbGVuICDop4bpopHmlbDmja7nmoTlpKflsI9cclxuICAgICogQHBhcmFtIHdpZHRoICDop4bpopHlrr1cclxuICAgICogQHBhcmFtIGhlaWdodCAg6KeG6aKR6auYXHJcbiAgICAqIEBwYXJhbSBmbXQgIOinhumikeagvOW8j1xyXG4gICAgKiBAcGFyYW0gcm90YXRpb24gIOinhumikeinkuW6plxyXG4gICAgKiBAcGFyYW0gbWlycm9yICDplZzlg49cclxuICAgICogIEBwYXJhbSB0aW1lc3RhbXAg5pe26Ze05oizXHJcbiAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuaW5wdXRWaWRlb0ZyYW1lID0gZnVuY3Rpb24gKGRhdGEsIGxlbiwgd2lkdGgsIGhlaWdodCwgZm10LCByb3RhdGlvbiwgbWlycm9yLCB0aW1lc3RhbXApIHtcclxuICAgICAgICByZXR1cm4geW91bWUuaW5wdXRWaWRlb0ZyYW1lKGRhdGEsIGxlbiwgd2lkdGgsIGhlaWdodCwgZm10LCByb3RhdGlvbiwgbWlycm9yLCB0aW1lc3RhbXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yqf6IO95o+P6L+wOiBcYlxi5YGc5q2i6KeG6aKR5pWw5o2u6L6T5YWlKOS4g+eJm+aOpeWPo++8jOWcqGlucHV0VmlkZW9GcmFtZeS5i+WQjuiwg+eUqO+8jOaIv+mXtOWGheWFtuWug+eUqOaIt+S8muaUtuWIsFlPVU1FX0VWRU5UX09USEVSU19WSURFT19JTlBVVF9TVE9Q5LqL5Lu2KVxyXG4gICAgICogQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAgICAgKiAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zdG9wSW5wdXRWaWRlb0ZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zdG9wSW5wdXRWaWRlb0ZyYW1lKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDorr7nva7luKfnjodcclxuICAgICAqICBAcGFyYW0gIGZwczrluKfnjofvvIgxLTMw77yJ77yM6buY6K6kMTXluKfvvIzlv4XpobvlnKjorr7nva7liIbovqjnjofkuYvliY3osIPnlKhcclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRWaWRlb0ZwcyA9IGZ1bmN0aW9uIChmcHMpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0VmlkZW9GcHMoZnBzKTtcclxuICAgIH07XHJcbiAgICAvLyDliIfmjaLliY3lkI7mkYTlg4/lpLRcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnN3aXRjaENhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc3dpdGNoQ2FtZXJhKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDmnYPpmZDmo4DmtYvnu5PmnZ/lkI7ph43nva7mkYTlg4/lpLRcclxuICAgICAqICBAcGFyYW1cclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5yZXNldENhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUucmVzZXRDYW1lcmEoKTtcclxuICAgIH07XHJcbiAgICAvLyDorr7nva7mmK/lkKbliY3nva7mkYTlg4/lpLRcclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldENhcHR1cmVGcm9udENhbWVyYUVuYWJsZSA9IGZ1bmN0aW9uIChlbmFibGUpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0Q2FwdHVyZUZyb250Q2FtZXJhRW5hYmxlKGVuYWJsZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDorr7nva7lpJbpg6jovpPlhaXmqKHlvI/nmoTor63pn7Pph4fmoLfnjodcclxuICAgICAqICBAcGFyYW0gaW5wdXRTYW1wbGVSYXRlOiDovpPlhaXor63pn7Pph4fmoLfnjodcclxuICAgICAqICBAcGFyYW0gbWl4ZWRDYWxsYmFja1NhbXBsZVJhdGU6IG1peOWQjui+k+WHuuivremfs+mHh+agt+eOh1xyXG4gICAgICogIEByZXR1cm4gWU9VTUVfU1VDQ0VTUyAtIOaIkOWKn1xyXG4gICAgICogICAgICAgICAg5YW25LuWIC0g5YW35L2T6ZSZ6K+v56CBXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldEV4dGVybmFsSW5wdXRTYW1wbGVSYXRlID0gZnVuY3Rpb24gKGlucHV0U2FtcGxlUmF0ZSwgbWl4ZWRDYWxsYmFja1NhbXBsZVJhdGUpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0RXh0ZXJuYWxJbnB1dFNhbXBsZVJhdGUoaW5wdXRTYW1wbGVSYXRlLCBtaXhlZENhbGxiYWNrU2FtcGxlUmF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDorr7nva7op4bpopHmlbDmja7kuIrooYznmoTnoIHnjofnmoTkuIrkuIvpmZAs56ys5LqM6LevKOm7mOiupOS4jeS8oClcclxuICAgICAqICBAcGFyYW0gbWF4Qml0cmF0ZTog5pyA5aSn56CB546H77yM5Y2V5L2Na2JpdC9zLiAgMOaXoOaViFxyXG4gICAgICogIEBwYXJhbSBtaW5CaXRyYXRlOiDmnIDlsI/noIHnjofvvIzljZXkvY1rYml0L3MuICAw5peg5pWIXHJcbiAgICAgXHJcbiAgICAgKiAgQHJldHVybiBOb25lXHJcbiAgICAgKlxyXG4gICAgICogIEB3YXJuaW5nOumcgOimgeWcqOi/m+aIv+mXtOS5i+WJjeiuvue9rlxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRWaWRlb0NvZGVCaXRyYXRlRm9yU2Vjb25kID0gZnVuY3Rpb24gKG1heEJpdHJhdGUsIG1pbkJpdHJhdGUpIHtcclxuICAgICAgICB5b3VtZS5zZXRWaWRlb0NvZGVCaXRyYXRlRm9yU2Vjb25kKG1heEJpdHJhdGUsIG1pbkJpdHJhdGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDog6I635Y+W6KeG6aKR5pWw5o2u5LiK6KGM55qE5b2T5YmN56CB546H44CCXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4g6KeG6aKR5pWw5o2u5LiK6KGM55qE5b2T5YmN56CB546HXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLmdldEN1cnJlbnRWaWRlb0NvZGVCaXRyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5nZXRDdXJyZW50VmlkZW9Db2RlQml0cmF0ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDog6K6+572u6KeG6aKR5pWw5o2u5piv5ZCm5ZCM5oSP5byA5ZCv56Gs57yW56Gs6KejXHJcbiAgICAgKiAgQHBhcmFtIGJFbmFibGU6IHRydWU65byA5ZCv77yMZmFsc2U65LiN5byA5ZCvXHJcbiAgICAgKlxyXG4gICAgICogIEByZXR1cm4gTm9uZVxyXG4gICAgICpcclxuICAgICAqICBAbm90ZTog5a6e6ZmF5piv5ZCm5byA5ZCv56Gs6Kej77yM6L+Y6Lef5pyN5Yqh5Zmo6YWN572u5Y+K56Gs5Lu25piv5ZCm5pSv5oyB5pyJ5YWz77yM6KaB5YWo6YOo5pSv5oyB5byA5ZCv5omN5Lya5L2/55So56Gs6Kej44CC5bm25LiU5aaC5p6c56Gs57yW56Gs6Kej5aSx6LSl77yM5Lmf5Lya5YiH5o2i5Zue6L2v6Kej44CCXHJcbiAgICAgKiAgQHdhcm5pbmc66ZyA6KaB5Zyo6L+b5oi/6Ze05LmL5YmN6K6+572uXHJcbiAgICAgKi9cclxuICAgIFlvdU1lVmlkZW8ucHJvdG90eXBlLnNldFZpZGVvSGFyZHdhcmVDb2RlRW5hYmxlID0gZnVuY3Rpb24gKGJFbmFibGUpIHtcclxuICAgICAgICB5b3VtZS5zZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZShiRW5hYmxlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiOt+WPluinhumikeaVsOaNruaYr+WQpuWQjOaEj+W8gOWQr+ehrOe8luehrOino1xyXG4gICAgICogIEByZXR1cm4gdHJ1ZTrlvIDlkK/vvIxmYWxzZTrkuI3lvIDlkK/vvIwg6buY6K6k5Li6dHJ1ZTtcclxuICAgICAqXHJcbiAgICAgKiAgQG5vdGU6IOWunumZheaYr+WQpuW8gOWQr+ehrOino++8jOi/mOi3n+acjeWKoeWZqOmFjee9ruWPiuehrOS7tuaYr+WQpuaUr+aMgeacieWFs++8jOimgeWFqOmDqOaUr+aMgeW8gOWQr+aJjeS8muS9v+eUqOehrOino+OAguW5tuS4lOWmguaenOehrOe8luehrOino+Wksei0pe+8jOS5n+S8muWIh+aNouWbnui9r+ino+OAglxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5nZXRWaWRlb0hhcmR3YXJlQ29kZUVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuZ2V0VmlkZW9IYXJkd2FyZUNvZGVFbmFibGUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9ruinhumikeaXoOW4p+a4suafk+eahOetieW+hei2heaXtuaXtumXtO+8jOi2hei/h+i/meS4quaXtumXtOS8mue7meS4iuWxguWbnuiwg1xyXG4gICAgICogIEBwYXJhbSB0aW1lb3V0OiDotoXml7bml7bpl7TvvIzljZXkvY3kuLrmr6vnp5JcclxuICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zZXRWaWRlb05vRnJhbWVUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcclxuICAgICAgICByZXR1cm4geW91bWUuc2V0VmlkZW9Ob0ZyYW1lVGltZW91dCh0aW1lb3V0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOafpeivouWkmuS4queUqOaIt+inhumikeS/oeaBr++8iOaUr+aMgeWIhui+qOeOh++8iVxyXG4gICAgICogIEBwYXJhbSB1c2VyTGlzdDog55So5oi3SUTliJfooajnmoRqc29u5pWw57uEXHJcbiAgICAgKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAgICAgKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUucXVlcnlVc2Vyc1ZpZGVvSW5mbyA9IGZ1bmN0aW9uICh1c2VyTGlzdCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5xdWVyeVVzZXJzVmlkZW9JbmZvKHVzZXJMaXN0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiuvue9ruWkmuS4queUqOaIt+inhumikeS/oeaBr++8iOaUr+aMgeWIhui+qOeOh++8iVxyXG4gICAgICogIEBwYXJhbSB2aWRlb2luZm9MaXN0OiDnlKjmiLflr7nlupTliIbovqjnjofliJfooajnmoRqc29u5pWw57uEXHJcbiAgICAgKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAgICAgKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuc2V0VXNlcnNWaWRlb0luZm8gPSBmdW5jdGlvbiAodmlkZW9pbmZvTGlzdCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5zZXRVc2Vyc1ZpZGVvSW5mbyh2aWRlb2luZm9MaXN0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOe+juminOW8gOWFs++8jOm7mOiupOaYr+WFs+mXree+juminFxyXG4gICAgICogIEBwYXJhbSBvcGVuOiB0cnVl6KGo56S65byA5ZCv576O6aKc77yMZmFsc2XooajnpLrlhbPpl63nvo7popxcclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5vcGVuQmVhdXRpZnkgPSBmdW5jdGlvbiAob3Blbikge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5vcGVuQmVhdXRpZnkob3Blbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDnvo7popzlvLrluqblj4LmlbDorr7nva5cclxuICAgICAqICBAcGFyYW0gcGFyYW06IOe+juminOWPguaVsO+8jDAuMCAtIDEuMCDvvIzpu5jorqTkuLow77yM5Yeg5LmO5rKh5pyJ576O6aKc5pWI5p6c77yMMC415bem5Y+z5pWI5p6c5piO5pi+XHJcbiAgICAgKiAgQHJldHVybiBZT1VNRV9TVUNDRVNTIC0g5oiQ5YqfXHJcbiAgICAgKiAgICAgICAgICDlhbbku5YgLSDlhbfkvZPplJnor6/noIFcclxuICAgICAqL1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUuYmVhdXRpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLmJlYXV0aWZ5Q2hhbmdlZChwYXJhbSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiAg5Yqf6IO95o+P6L+wOiDnmKbohLjlvIDlhbNcclxuICAgICAqICBAcGFyYW0gcGFyYW06IHRydWUg5byA5ZCv55im6IS477yMZmFsc2XlhbPpl63vvIzpu5jorqQgZmFsc2VcclxuICAgICAqICBAcmV0dXJuIFlPVU1FX1NVQ0NFU1MgLSDmiJDlip9cclxuICAgICAqICAgICAgICAgIOWFtuS7liAtIOWFt+S9k+mUmeivr+eggVxyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5zdHJldGNoRmFjZSA9IGZ1bmN0aW9uIChzdHJldGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHlvdW1lLnN0cmV0Y2hGYWNlKHN0cmV0Y2gpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogIOWKn+iDveaPj+i/sDog6LCD55So5ZCO5ZCM5q2l5a6M5oiQ6bqm5YWL6aOO6YeK5pS+77yM5Y+q5piv5Li65LqG5pa55L6/5L2/55SoIElNIOeahOW9lemfs+aOpeWPo+aXtuWIh+aNoum6puWFi+mjjuS9v+eUqOadg+OAglxyXG4gICAgICogIEByZXR1cm4gYm9vbCAtIOaIkOWKn1xyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5yZWxlYXNlTWljU3luYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geW91bWUucmVsZWFzZU1pY1N5bmMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqICDlip/og73mj4/ov7A6IOiwg+eUqOWQjuaBouWkjem6puWFi+mjjuWIsOmHiuaUvuWJjeeahOeKtuaAge+8jOWPquaYr+S4uuS6huaWueS+v+S9v+eUqCBJTSDnmoTlvZXpn7PmjqXlj6Pml7bliIfmjaLpuqblhYvpo47kvb/nlKjmnYPjgIJcclxuICAgICAqICBAcmV0dXJuIGJvb2wgLSB0cnVlIOaIkOWKn1xyXG4gICAgICovXHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5yZXN1bWVNaWNTeW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB5b3VtZS5yZXN1bWVNaWNTeW5jKCk7XHJcbiAgICB9O1xyXG4gICAgWW91TWVWaWRlby5wcm90b3R5cGUudXBkYXRlQ2FudmFzID0gZnVuY3Rpb24gKHVzZXJpZCwgY2FudmFzaWQpIHtcclxuICAgICAgICB5b3VtZS51cGRhdGVDYW52YXModXNlcmlkLCBjYW52YXNpZCk7XHJcbiAgICB9O1xyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8g6ZyA6KaB5a+55aSW5pq06Zyy55qE5LqL5Lu2XHJcbiAgICBZb3VNZVZpZGVvLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0UoJ3BhcmFtIGVycm9yISBzZW5jb25kIHBhcmFtIHNob3VsZCBiZSBhIGZ1bmN0aW9uISwgcGxlYXNlIGNoZWNrIHlvdXIgY29kZScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlvdW1lLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX1JFQ09OTkVDVElORyc6ICAvLyDmlq3nvZHkuobvvIzmraPlnKjph43ov55cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9SRUNPTk5FQ1RFRCc6IC8vIOaWree9kemHjei/nuaIkOWKn1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX1JFQ19QRVJNSVNTSU9OX1NUQVRVUyc6IC8vIOmAmuefpeW9lemfs+adg+mZkOeKtuaAge+8jOaIkOWKn+iOt+WPluadg+mZkOaXtumUmeivr+eggeS4ullPVU1FX1NVQ0NFU1PvvIzojrflj5blpLHotKXkuLpZT1VNRV9FUlJPUl9SRUNfTk9fUEVSTUlTU0lPTu+8iOatpOaXtuS4jeeuoem6puWFi+mjjm11dGXnirbmgIHlpoLkvZXvvIzpg73msqHmnInlo7Dpn7PovpPlh7rvvIlcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9CR01fU1RPUFBFRCc6IC8vIOmAmuefpeiDjOaZr+mfs+S5kOaSreaUvue7k+adn1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX0JHTV9GQUlMRUQnOiAvLyDpgJrnn6Xog4zmma/pn7PkuZDmkq3mlL7lpLHotKVcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9PVEhFUlNfTUlDX09OJzogLy8g5YW25LuW55So5oi36bqm5YWL6aOO5omT5byAXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX01JQ19PRkYnOiAvLyDlhbbku5bnlKjmiLfpuqblhYvpo47lhbPpl61cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9PVEhFUlNfU1BFQUtFUl9PTic6IC8vIOWFtuS7lueUqOaIt+aJrOWjsOWZqOaJk+W8gFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19TUEVBS0VSX09GRic6IC8vIOWFtuS7lueUqOaIt+aJrOWjsOWZqOWFs+mXrVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19WT0lDRV9PTic6IC8vIOWFtuS7lueUqOaIt+i/m+WFpeiusuivneeKtuaAgVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19WT0lDRV9PRkYnOiAvLyDlhbbku5bnlKjmiLfov5vlhaXpnZnpu5jnirbmgIFcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9NWV9NSUNfTEVWRUwnOiAvLyDpuqblhYvpo47nmoTor63pn7PnuqfliKtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9NSUNfQ1RSX09OJzogLy8g6bqm5YWL6aOO6KKr5YW25LuW55So5oi35omT5byAXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfTUlDX0NUUl9PRkYnOiAvLyDpuqblhYvpo47ooqvlhbbku5bnlKjmiLflhbPpl61cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9TUEVBS0VSX0NUUl9PTic6IC8vIOaJrOWjsOWZqOiiq+WFtuS7lueUqOaIt+aJk+W8gFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX1NQRUFLRVJfQ1RSX09GRic6IC8vIOaJrOWjsOWZqOiiq+WFtuS7lueUqOaIt+WFs+mXrVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX0xJU1RFTl9PVEhFUl9PTic6IC8vIOWPlua2iOWxj+iUveafkOS6uuivremfs1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX0xJU1RFTl9PVEhFUl9PRkYnOiAvLyDlsY/olL3mn5Dkurror63pn7NcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9NRVNTQUdFX05PVElGWSc6IC8vIOaUtuWIsE1lc3NhZ2UsIHBhcmFt5Li6bWVzc2FnZeWGheWuuVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX0tJQ0tfUkVTVUxUJzogLy8g6Lii5Lq655qE5bqU562UXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfS0lDS19OT1RJRlknOiAvLyDooqvouKLpgJrnn6UgICAscGFyYW06IO+8iOi4ouS6uuiAhUlE77yM6KKr6Lii5Y6f5Zug77yM6KKr56aB5pe26Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfRkFSRU5EX1ZPSUNFX0xFVkVMJzogLy8g6L+c56uv6K+06K+d5Lq66Z+z6YeP5aSn5bCPXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX0JFX0tJQ0tFRCc6IC8vIOaIv+mXtOmHjOWFtuS7luS6uuiiq+i4ouWHuuaIv+mXtFxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19WSURFT19PTic6IC8vIOaUtuWIsOWFtuWug+eUqOaIt+eahOinhumikea1gVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX01BU0tfVklERU9fQllfT1RIRVJfVVNFUic6IC8vIOinhumikeiiq+WFtuS7lueUqOaIt+Wxj+iUvVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX1JFU1VNRV9WSURFT19CWV9PVEhFUl9VU0VSJzogLy8g6KeG6aKR6KKr5YW25LuW55So5oi35oGi5aSNXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX1ZJREVPX1NIVVRfRE9XTic6IC8vIOWFtuWug+eUqOaIt+eahOinhumikea1geaWreW8gO+8iOWMheWQq+e9kee7nOS4reaWreeahOaDheWGte+8iVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19WSURFT19JTlBVVF9TVEFSVCc6IC8vIOWFtuS7lueUqOaIt+inhumikei+k+WFpeW8gOWni++8iOWGhemDqOmHh+mbhuS4i+W8gOWQr+aRhOWDj+WktClcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9PVEhFUlNfVklERU9fSU5QVVRfU1RPUCc6IC8vIOWFtuS7lueUqOaIt+inhumikei+k+WFpeWBnOatou+8iOWGhemDqOmHh+mbhuS4i+WBnOatouaRhOWDj+WktClcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9NRURJQV9EQVRBX1JPQURfUEFTUyc6IC8vIOmfs+inhumikeaVsOaNrumAmui3r+i/numAmu+8jOWumuaXtuajgOa1i++8jOS4gOW8gOWni+aUtuWIsOaVsOaNruS8muaUtuWIsFBBU1Pkuovku7bvvIzkuYvlkI7lj5jljJbnmoTml7blgJnkvJrlj5HpgIFcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9NRURJQV9EQVRBX1JPQURfQkxPQ0snOiAvLyDpn7Pop4bpopHmlbDmja7pgJrot6/kuI3pgJpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9RVUVSWV9VU0VSU19WSURFT19JTkZPJzogLy8g5p+l6K+i55So5oi36KeG6aKR5L+h5oGv6L+U5ZueXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfU0VUX1VTRVJTX1ZJREVPX0lORk8nOiAvLyDorr7nva7nlKjmiLfmjqXmlLbop4bpopHkv6Hmga/ov5Tlm55cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9PVEhFUlNfREFUQV9FUlJPUic6IC8vIOaVsOaNrumUmeivr1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19ORVRXT1JLX0JBRCc6IC8vIOe9kee7nOS4jeWlvVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19CTEFDS19GVUxMJzogLy8g6buR5bGPXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX0dSRUVOX0ZVTEwnOiAvLyDnu7/lsY9cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9PVEhFUlNfQkxBQ0tfQk9SREVSJzogLy8g6buR6L65XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX0dSRUVOX0JPUkRFUic6IC8vIOe7v+i+uVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19CTFVSUkVEX1NDUkVFTic6IC8vIOiKseWxj1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lPVU1FX0VWRU5UX09USEVSU19FTkNPREVSX0VSUk9SJzogLy8g57yW56CB6ZSZ6K+vXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWU9VTUVfRVZFTlRfT1RIRVJTX0RFQ09ERVJfRVJST1InOiAvLyDop6PnoIHplJnor69cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9DQU1FUkFfREVWSUNFX0NPTk5FQ1QnOiAvLyDmkYTlg4/lpLTorr7lpIfmj5LlhaXvvIznp7vliqjnq6/ml6DmlYhcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZT1VNRV9FVkVOVF9DQU1FUkFfREVWSUNFX0RJU0NPTk5FQ1QnOiAvLyDmkYTlg4/lpLTorr7lpIfmi5Tlh7rvvIznp7vliqjnq6/ml6DmlYhcclxuICAgICAgICAgICAgICAgICAgICAgICAgeW91bWUuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0qL1xyXG4gICAgfTtcclxuICAgIHJldHVybiBZb3VNZVZpZGVvO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBZb3VNZVZpZGVvO1xyXG4vKipcclxuKiDliJ3lp4vljJbmiJDlip9cclxuKi9cclxueW91bWUuZW1pdHRlci5vbignWU9VTUVfRVZFTlRfSU5JVF9PSycsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ0lOSVRfT0snLCBvYmopO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24obG9naW5DYWxsYmFjaykpIHtcclxuICAgICAgICBsb2dpbkNhbGxiYWNrKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgbG9naW5DYWxsYmFjayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn0pO1xyXG4vKipcclxuKiDliJ3lp4vljJblpLHotKVcclxuKi9cclxueW91bWUuZW1pdHRlci5vbignWU9VTUVfRVZFTlRfSU5JVF9GQUlMRUQnLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBZTUxvZ1V0aWxzXzEuWU1Mb2dVdGlscy5MT0dJKCdJTklUX0ZBSUxFRCcsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihsb2dpbkNhbGxiYWNrKSkge1xyXG4gICAgICAgIGxvZ2luQ2FsbGJhY2sob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICBsb2dpbkNhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIOWKoOWFpeaIv+mXtOaIkOWKn1xyXG4qL1xyXG55b3VtZS5lbWl0dGVyLm9uKCdZT1VNRV9FVkVOVF9KT0lOX09LJywgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgWU1Mb2dVdGlsc18xLllNTG9nVXRpbHMuTE9HSSgnSk9JTl9PSycsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihqb2luUm9vbUNhbGxiYWNrKSkge1xyXG4gICAgICAgIGpvaW5Sb29tQ2FsbGJhY2sob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICBqb2luUm9vbUNhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIOWKoOWFpeaIv+mXtOWksei0pVxyXG4qL1xyXG55b3VtZS5lbWl0dGVyLm9uKCdZT1VNRV9FVkVOVF9KT0lOX0ZBSUxFRCcsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ0pPSU5fRkFJTEVEJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGpvaW5Sb29tQ2FsbGJhY2spKSB7XHJcbiAgICAgICAgam9pblJvb21DYWxsYmFjayhvYmouZXJyb3Jjb2RlLCBvYmopO1xyXG4gICAgICAgIGpvaW5Sb29tQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog56a75byA5oi/6Ze05oiQ5YqfXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX0xFQVZFRF9BTEwnLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBZTUxvZ1V0aWxzXzEuWU1Mb2dVdGlscy5MT0dJKCdMRUFWRURfQUxMJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGxlYXZlUm9vbUNhbGxiYWNrKSkge1xyXG4gICAgICAgIGxlYXZlUm9vbUNhbGxiYWNrKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgbGVhdmVSb29tQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog6Ieq5bex55qE6bqm5YWL6aOO5omT5byAXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX0xPQ0FMX01JQ19PTicsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ0xPQ0FMX01JQ19PTicsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihvcGVuTWljcm9QaG9uZUNhbGxiYWNrKSkge1xyXG4gICAgICAgIG9wZW5NaWNyb1Bob25lQ2FsbGJhY2sob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICBvcGVuTWljcm9QaG9uZUNhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIOiHquW3seeahOm6puWFi+mjjuWFs+mXrVxyXG4qL1xyXG55b3VtZS5lbWl0dGVyLm9uKCdZT1VNRV9FVkVOVF9MT0NBTF9NSUNfT0ZGJywgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgWU1Mb2dVdGlsc18xLllNTG9nVXRpbHMuTE9HSSgnTE9DQUxfTUlDX09GRicsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihjbG9zZU1pY3JvUGhvbmVDYWxsYmFjaykpIHtcclxuICAgICAgICBjbG9zZU1pY3JvUGhvbmVDYWxsYmFjayhvYmouZXJyb3Jjb2RlLCBvYmopO1xyXG4gICAgICAgIGNsb3NlTWljcm9QaG9uZUNhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIOiHquW3seeahOaJrOWjsOWZqOaJk+W8gFxyXG4qL1xyXG55b3VtZS5lbWl0dGVyLm9uKCdZT1VNRV9FVkVOVF9MT0NBTF9TUEVBS0VSX09OJywgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgWU1Mb2dVdGlsc18xLllNTG9nVXRpbHMuTE9HSSgnTE9DQUxfU1BFQUtFUl9PTicsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihvcGVuU3BlYWtlckNhbGxiYWNrKSkge1xyXG4gICAgICAgIG9wZW5TcGVha2VyQ2FsbGJhY2sob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICBvcGVuU3BlYWtlckNhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIOiHquW3seeahOaJrOWjsOWZqOWFs+mXrVxyXG4qL1xyXG55b3VtZS5lbWl0dGVyLm9uKCdZT1VNRV9FVkVOVF9MT0NBTF9TUEVBS0VSX09GRicsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ0xPQ0FMX1NQRUFLRVJfT0ZGJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGNsb3NlU3BlYWtlckNhbGxiYWNrKSkge1xyXG4gICAgICAgIGNsb3NlU3BlYWtlckNhbGxiYWNrKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgY2xvc2VTcGVha2VyQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog6Ieq5bex55qE5pGE5YOP5aS05byA5ZCvXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX0xPQ0FMX1ZJREVPX0lOUFVUX1NUQVJUJywgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgWU1Mb2dVdGlsc18xLllNTG9nVXRpbHMuTE9HSSgnVklERU9fSU5QVVRfU1RBUlQnLCBvYmopO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ob3BlbkNhbWVyYUNhbGxiYWNrKSkge1xyXG4gICAgICAgIG9wZW5DYW1lcmFDYWxsYmFjayhvYmouZXJyb3Jjb2RlLCBvYmopO1xyXG4gICAgICAgIG9wZW5DYW1lcmFDYWxsYmFjayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn0pO1xyXG4vKipcclxuKiDoh6rlt7HnmoTmkYTlg4/lpLTlhbPpl61cclxuKi9cclxueW91bWUuZW1pdHRlci5vbignWU9VTUVfRVZFTlRfTE9DQUxfVklERU9fSU5QVVRfU1RPUCcsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ1ZJREVPX0lOUFVUX1NUT1AnLCBvYmopO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oY2xvc2VDYW1lcmFDYWxsYmFjaykpIHtcclxuICAgICAgICBjbG9zZUNhbWVyYUNhbGxiYWNrKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgY2xvc2VDYW1lcmFDYWxsYmFjayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn0pO1xyXG4vKipcclxuKiDmmoLlgZzpopHpgZPlrozmiJBcclxuKi9cclxueW91bWUuZW1pdHRlci5vbignWU9VTUVfRVZFTlRfUEFVU0VEJywgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgWU1Mb2dVdGlsc18xLllNTG9nVXRpbHMuTE9HSSgnWU9VTUVfRVZFTlRfUEFVU0VEJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHBhdXNlQ2hhbm5lbENhbGxiYWNrKSkge1xyXG4gICAgICAgIHBhdXNlQ2hhbm5lbENhbGxiYWNrKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgcGF1c2VDaGFubmVsQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog5oGi5aSN6aKR6YGT5a6M5oiQXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX1JFU1VNRUQnLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBZTUxvZ1V0aWxzXzEuWU1Mb2dVdGlscy5MT0dJKCdZT1VNRV9FVkVOVF9SRVNVTUVEJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlc3VtZUNoYW5uZWxDYWxsYmFjaykpIHtcclxuICAgICAgICByZXN1bWVDaGFubmVsQ2FsbGJhY2sob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICByZXN1bWVDaGFubmVsQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog5bGP6JS95p+Q5Lq655qE6KeG6aKRXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX01BU0tfVklERU9fRk9SX1VTRVInLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBZTUxvZ1V0aWxzXzEuWU1Mb2dVdGlscy5MT0dJKCdNQVNLX1ZJREVPX0ZPUl9VU0VSJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKG1hc2tWaWRlb0ZvclVzZXJDYWxsYmFja1tvYmoucGFyYW1dKSkge1xyXG4gICAgICAgIG1hc2tWaWRlb0ZvclVzZXJDYWxsYmFja1tvYmoucGFyYW1dKG9iai5lcnJvcmNvZGUsIG9iaik7XHJcbiAgICAgICAgZGVsZXRlIG1hc2tWaWRlb0ZvclVzZXJDYWxsYmFja1tvYmoucGFyYW1dO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuLyoqXHJcbiog5oGi5aSN5p+Q5Lq655qE6KeG6aKRXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ1lPVU1FX0VWRU5UX1JFU1VNRV9WSURFT19GT1JfVVNFUicsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ1JFU1VNRV9WSURFT19GT1JfVVNFUicsIG9iaik7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihyZXN1bWVWaWRlb0ZvclVzZXJDYWxsYmFja1tvYmoucGFyYW1dKSkge1xyXG4gICAgICAgIHJlc3VtZVZpZGVvRm9yVXNlckNhbGxiYWNrW29iai5wYXJhbV0ob2JqLmVycm9yY29kZSwgb2JqKTtcclxuICAgICAgICBkZWxldGUgcmVzdW1lVmlkZW9Gb3JVc2VyQ2FsbGJhY2tbb2JqLnBhcmFtXTtcclxuICAgIH1cclxuICAgIDtcclxufSk7XHJcbi8qKlxyXG4qIHNlbmRNZXNzYWdl5oiQ5Yqf5LiO5ZCm55qE6YCa55+l77yMcGFyYW3kuLrlm57kvKDnmoRyZXF1ZXN0SURcclxuKi9cclxueW91bWUuZW1pdHRlci5vbignWU9VTUVfRVZFTlRfU0VORF9NRVNTQUdFX1JFU1VMVCcsIGZ1bmN0aW9uIChvYmopIHtcclxuICAgIFlNTG9nVXRpbHNfMS5ZTUxvZ1V0aWxzLkxPR0koJ1NFTkRfTUVTU0FHRV9SRVNVTFQnLCBvYmopO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZE1lc3NhZ2VDYWxsYmFja1tvYmoucGFyYW1dKSkge1xyXG4gICAgICAgIHNlbmRNZXNzYWdlQ2FsbGJhY2tbb2JqLnBhcmFtXShvYmouZXJyb3Jjb2RlLCBvYmopO1xyXG4gICAgICAgIGRlbGV0ZSBzZW5kTWVzc2FnZUNhbGxiYWNrW29iai5wYXJhbV07XHJcbiAgICB9XHJcbiAgICA7XHJcbn0pO1xyXG4vKipcclxuKiBvblJlcXVlc3RSZXN0QVBJ5Zue6LCDXHJcbiovXHJcbnlvdW1lLmVtaXR0ZXIub24oJ29uUmVxdWVzdFJlc3RBUEknLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBZTUxvZ1V0aWxzXzEuWU1Mb2dVdGlscy5MT0dJKCdvblJlcXVlc3RSZXN0QVBJJywgb2JqKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlcXVlc3RSZXN0QXBpQ2FsbGJhY2tbb2JqLnJlcXVlc3RpZF0pKSB7XHJcbiAgICAgICAgcmVxdWVzdFJlc3RBcGlDYWxsYmFja1tvYmoucmVxdWVzdGlkXShvYmouZXJyb3Jjb2RlLCBvYmopO1xyXG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0UmVzdEFwaUNhbGxiYWNrW29iai5yZXF1ZXN0aWRdO1xyXG4gICAgfVxyXG4gICAgO1xyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgUHJvZ3JhbSAgICAgPSByZXF1aXJlKCcuL1Byb2dyYW0nKTtcclxudmFyIFNpemUgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvU2l6ZScpO1xyXG52YXIgU2hhZGVyICAgICAgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xyXG52YXIgVGV4dHVyZSAgICAgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcclxudmFyIFNjcmlwdCAgICAgID0gcmVxdWlyZSgnLi9TY3JpcHQnKTtcclxudmFyIFdlYkdMQ2FudmFzID0gcmVxdWlyZSgnLi9XZWJHTENhbnZhcycpO1xyXG5cclxudmFyIENsYXNzICAgICAgID0gcmVxdWlyZSgndWNsYXNzJyk7XHJcblxyXG52YXIgdmVydGV4U2hhZGVyU2NyaXB0ID0gU2NyaXB0LmNyZWF0ZUZyb21Tb3VyY2UoXCJ4LXNoYWRlci94LXZlcnRleFwiLCBcIiBcXFxyXG4gIGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjsgXFxcclxuICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOyBcXFxyXG4gIHVuaWZvcm0gbWF0NCB1TVZNYXRyaXg7IFxcXHJcbiAgdW5pZm9ybSBtYXQ0IHVQTWF0cml4OyBcXFxyXG4gIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkOyBcXFxyXG4gIHZvaWQgbWFpbih2b2lkKSB7IFxcXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHVQTWF0cml4ICogdU1WTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7IFxcXHJcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsgXFxcclxuICB9IFxcXHJcblwiKTtcclxuXHJcblxyXG52YXIgZnJhZ21lbnRTaGFkZXJTY3JpcHQgPSBTY3JpcHQuY3JlYXRlRnJvbVNvdXJjZShcIngtc2hhZGVyL3gtZnJhZ21lbnRcIiwgXCIgXFxcclxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7IFxcXHJcbiAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7IFxcXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTsgXFxcclxuICB2b2lkIG1haW4odm9pZCkgeyBcXFxyXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXh0dXJlQ29vcmQpLmJncmE7IFxcXHJcbiAgfSBcXFxyXG5cIik7XHJcblxyXG5cclxuXHJcblxyXG52YXIgQkdSQVdlYkdMQ2FudmFzID0gbmV3IENsYXNzKHtcclxuICBFeHRlbmRzICA6IFdlYkdMQ2FudmFzLFxyXG4gIEJpbmRzIDogWydkZWNvZGUnXSxcclxuXHJcbiAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKGNhbnZhcywgc2l6ZSkge1xyXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHNpemUudztcclxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHNpemUuaDtcclxuICAgIHRoaXMuZm10ID0gMTtcclxuICB9LFxyXG5cclxuICByZXNpemUgOiBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHRoaXMuc2l6ZSAmJiB0aGlzLnNpemUudyA9PT0gc2l6ZS53ICYmIHRoaXMuc2l6ZS5oID09PSBzaXplLmgpIHJldHVybjtcclxuXHJcbiAgICBCR1JBV2ViR0xDYW52YXMucGFyZW50LmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLmNhbnZhcywgc2l6ZSk7XHJcbiAgfSxcclxuXHJcbiAgb25Jbml0U2hhZGVyczogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBuZXcgUHJvZ3JhbSh0aGlzLmdsKTtcclxuICAgIHRoaXMucHJvZ3JhbS5hdHRhY2gobmV3IFNoYWRlcih0aGlzLmdsLCB2ZXJ0ZXhTaGFkZXJTY3JpcHQpKTtcclxuICAgIHRoaXMucHJvZ3JhbS5hdHRhY2gobmV3IFNoYWRlcih0aGlzLmdsLCBmcmFnbWVudFNoYWRlclNjcmlwdCkpO1xyXG4gICAgdGhpcy5wcm9ncmFtLmxpbmsoKTtcclxuICAgIHRoaXMucHJvZ3JhbS51c2UoKTtcclxuICAgIHRoaXMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLnByb2dyYW0uZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhVmVydGV4UG9zaXRpb25cIik7XHJcbiAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xyXG4gICAgdGhpcy50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUgPSB0aGlzLnByb2dyYW0uZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhVGV4dHVyZUNvb3JkXCIpO1xyXG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XHJcbiAgfSxcclxuXHJcbiAgb25Jbml0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCwgdGhpcy5zaXplLCBnbC5SR0JBKTtcclxuICB9LFxyXG5cclxuICBvbkluaXRTY2VuZVRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnRleHR1cmUuYmluZCgwLCB0aGlzLnByb2dyYW0sIFwidGV4dHVyZVwiKTtcclxuICB9LFxyXG5cclxuICBmaWxsQkdSQVRleHR1cmVzOiBmdW5jdGlvbihiZ3JhKSB7XHJcbiAgICB0aGlzLnRleHR1cmUuZmlsbChiZ3JhKTtcclxuICB9LFxyXG5cclxuICBkZWNvZGU6IGZ1bmN0aW9uKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgIGlmICghYnVmZmVyKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5yZXNpemUobmV3IFNpemUod2lkdGgsIGhlaWdodCkpO1xyXG5cclxuICAgIHZhciBsdW1hU2l6ZSA9IHdpZHRoICogaGVpZ2h0ICogNDtcclxuXHJcbiAgICB0aGlzLnRleHR1cmUuZmlsbChidWZmZXIuc3ViYXJyYXkoMCwgbHVtYVNpemUpKTtcclxuICAgIHRoaXMuZHJhd1NjZW5lKCk7XHJcbiAgfSxcclxuXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiQlJHQUNhbnZhcyBTaXplOiBcIiArIHRoaXMuc2l6ZTtcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQkdSQVdlYkdMQ2FudmFzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4uL3V0aWxzL2Fzc2VydCcpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFByb2dyYW0oZ2wpIHtcclxuICB0aGlzLmdsID0gZ2w7XHJcbiAgdGhpcy5wcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbn1cclxuXHJcblByb2dyYW0ucHJvdG90eXBlID0ge1xyXG4gIGF0dGFjaDogZnVuY3Rpb24gKHNoYWRlcikge1xyXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCBzaGFkZXIuc2hhZGVyKTtcclxuICB9LCBcclxuICBsaW5rOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAvLyBJZiBjcmVhdGluZyB0aGUgc2hhZGVyIHByb2dyYW0gZmFpbGVkLCBhbGVydC5cclxuICAgIGFzc2VydCh0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSxcclxuICAgICAgICAgICBcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbS5cIik7XHJcbiAgfSxcclxuICB1c2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gIH0sXHJcbiAgZ2V0QXR0cmlidXRlTG9jYXRpb246IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XHJcbiAgfSxcclxuICBzZXRNYXRyaXhVbmlmb3JtOiBmdW5jdGlvbihuYW1lLCBhcnJheSkge1xyXG4gICAgdmFyIHVuaWZvcm0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xyXG4gICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm0sIGZhbHNlLCBhcnJheSk7XHJcbiAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyYW07XHJcblxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuLi91dGlscy9hc3NlcnQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgV2ViR0wgc2hhZGVyIHNjcmlwdC5cclxuICovXHJcblxyXG5mdW5jdGlvbiBTY3JpcHQoKSB7fVxyXG5cclxuU2NyaXB0LmNyZWF0ZUZyb21FbGVtZW50SWQgPSBmdW5jdGlvbihpZCkge1xyXG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgXHJcbiAgLy8gRGlkbid0IGZpbmQgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgSUQsIGFib3J0LlxyXG4gIGFzc2VydChzY3JpcHQgLCBcIkNvdWxkIG5vdCBmaW5kIHNoYWRlciB3aXRoIElEOiBcIiArIGlkKTtcclxuICBcclxuICAvLyBXYWxrIHRocm91Z2ggdGhlIHNvdXJjZSBlbGVtZW50J3MgY2hpbGRyZW4sIGJ1aWxkaW5nIHRoZSBzaGFkZXIgc291cmNlIHN0cmluZy5cclxuICB2YXIgc291cmNlID0gXCJcIjtcclxuICB2YXIgY3VycmVudENoaWxkID0gc2NyaXB0IC5maXJzdENoaWxkO1xyXG4gIHdoaWxlKGN1cnJlbnRDaGlsZCkge1xyXG4gICAgaWYgKGN1cnJlbnRDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XHJcbiAgICAgIHNvdXJjZSArPSBjdXJyZW50Q2hpbGQudGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQubmV4dFNpYmxpbmc7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciByZXMgPSBuZXcgU2NyaXB0b3IoKTtcclxuICByZXMudHlwZSA9IHNjcmlwdC50eXBlO1xyXG4gIHJlcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcblNjcmlwdC5jcmVhdGVGcm9tU291cmNlID0gZnVuY3Rpb24odHlwZSwgc291cmNlKSB7XHJcbiAgdmFyIHJlcyA9IG5ldyBTY3JpcHQoKTtcclxuICByZXMudHlwZSA9IHR5cGU7XHJcbiAgcmVzLnNvdXJjZSA9IHNvdXJjZTtcclxuICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgZXJyb3IgPSByZXF1aXJlKCcuLi91dGlscy9lcnJvcicpO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBXZWJHTCBzaGFkZXIgb2JqZWN0IGFuZCBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBsb2FkIHNoYWRlcnMgZnJvbSBIVE1MXHJcbiAqIHNjcmlwdCB0YWdzLlxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBTaGFkZXIoZ2wsIHNjcmlwdCkge1xyXG4gIFxyXG4gIC8vIE5vdyBmaWd1cmUgb3V0IHdoYXQgdHlwZSBvZiBzaGFkZXIgc2NyaXB0IHdlIGhhdmUsIGJhc2VkIG9uIGl0cyBNSU1FIHR5cGUuXHJcbiAgaWYgKHNjcmlwdC50eXBlID09IFwieC1zaGFkZXIveC1mcmFnbWVudFwiKSB7XHJcbiAgICB0aGlzLnNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gIH0gZWxzZSBpZiAoc2NyaXB0LnR5cGUgPT0gXCJ4LXNoYWRlci94LXZlcnRleFwiKSB7XHJcbiAgICB0aGlzLnNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZXJyb3IoXCJVbmtub3duIHNoYWRlciB0eXBlOiBcIiArIHNjcmlwdC50eXBlKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgXHJcbiAgLy8gU2VuZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgb2JqZWN0LlxyXG4gIGdsLnNoYWRlclNvdXJjZSh0aGlzLnNoYWRlciwgc2NyaXB0LnNvdXJjZSk7XHJcbiAgXHJcbiAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXHJcbiAgZ2wuY29tcGlsZVNoYWRlcih0aGlzLnNoYWRlcik7XHJcbiAgXHJcbiAgLy8gU2VlIGlmIGl0IGNvbXBpbGVkIHN1Y2Nlc3NmdWxseS5cclxuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih0aGlzLnNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICBlcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczogXCIgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHRoaXMuc2hhZGVyKSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyO1xyXG5cclxuXHJcblxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuLi91dGlscy9hc3NlcnQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgV2ViR0wgdGV4dHVyZSBvYmplY3QuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gVGV4dHVyZShnbCwgc2l6ZSwgZm9ybWF0KSB7XHJcbiAgdGhpcy5nbCA9IGdsO1xyXG4gIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgPyBmb3JtYXQgOiBnbC5MVU1JTkFOQ0U7IFxyXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHNpemUudywgc2l6ZS5oLCAwLCB0aGlzLmZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxufVxyXG5cclxudmFyIHRleHR1cmVJRHMgPSBudWxsO1xyXG5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuICBmaWxsOiBmdW5jdGlvbih0ZXh0dXJlRGF0YSwgdXNlVGV4U3ViSW1hZ2UyRCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIGFzc2VydCh0ZXh0dXJlRGF0YS5sZW5ndGggPj0gdGhpcy5zaXplLncgKiB0aGlzLnNpemUuaCwgXHJcbiAgICAgICAgICAgXCJUZXh0dXJlIHNpemUgbWlzbWF0Y2gsIGRhdGE6XCIgKyB0ZXh0dXJlRGF0YS5sZW5ndGggKyBcIiwgdGV4dHVyZTogXCIgKyB0aGlzLnNpemUudyAqIHRoaXMuc2l6ZS5oKTtcclxuICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xyXG4gICAgaWYgKDEpIHtcclxuXHJcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy5zaXplLncgLCB0aGlzLnNpemUuaCwgdGhpcy5mb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmVEYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHRleEltYWdlMkQgc2VlbXMgdG8gYmUgZmFzdGVyLCB0aHVzIGtlZXBpbmcgaXQgYXMgdGhlIGRlZmF1bHRcclxuXHJcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuc2l6ZS53LCB0aGlzLnNpemUuaCwgMCwgdGhpcy5mb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmVEYXRhKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGJpbmQ6IGZ1bmN0aW9uKG4sIHByb2dyYW0sIG5hbWUpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBpZiAoIXRleHR1cmVJRHMpIHtcclxuICAgICAgdGV4dHVyZUlEcyA9IFtnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRTEsIGdsLlRFWFRVUkUyXTtcclxuICAgIH1cclxuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZUlEc1tuXSk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xyXG4gICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLnByb2dyYW0sIG5hbWUpLCBuKTtcclxuICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyaWMgV2ViR0wgYmFja2VkIGNhbnZhcyB0aGF0IHNldHMgdXA6IGEgcXVhZCB0byBwYWludCBhIHRleHR1cmUgb24sIGFwcHJvcHJpYXRlIHZlcnRleC9mcmFnbWVudCBzaGFkZXJzLFxyXG4gKiBzY2VuZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB0aGluZ3MuIFNwZWNpYWxpemVkIHZlcnNpb25zIG9mIHRoaXMgY2xhc3MgY2FuIGJlIGNyZWF0ZWQgYnkgb3ZlcnJpZGluZyBzZXZlcmFsIFxyXG4gKiBpbml0aWFsaXphdGlvbiBtZXRob2RzLlxyXG5cclxuICovXHJcblxyXG52YXIgU2NyaXB0ID0gcmVxdWlyZSgnLi9TY3JpcHQnKTtcclxudmFyIGVycm9yICA9IHJlcXVpcmUoJy4uL3V0aWxzL2Vycm9yJyk7XHJcbnZhciBtYWtlUGVyc3BlY3RpdmUgID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2xVdGlscycpLm1ha2VQZXJzcGVjdGl2ZTtcclxudmFyIE1hdHJpeCA9IHJlcXVpcmUoJ3N5bHZlc3Rlci5qcycpLk1hdHJpeDtcclxudmFyIENsYXNzICA9IHJlcXVpcmUoJ3VjbGFzcycpO1xyXG52YXIgUHJvZ3JhbSA9IHJlcXVpcmUoJy4vUHJvZ3JhbScpO1xyXG52YXIgU2hhZGVyID0gcmVxdWlyZSgnLi9TaGFkZXInKTtcclxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL1RleHR1cmUnKTtcclxuXHJcbnZhciBmbXQgPSAwO1xyXG4gIFxyXG5cclxudmFyIHZlcnRleFNoYWRlclNjcmlwdCA9IFNjcmlwdC5jcmVhdGVGcm9tU291cmNlKFwieC1zaGFkZXIveC12ZXJ0ZXhcIiwgXCIgXFxcclxuICBhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247IFxcXHJcbiAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsgXFxcclxuICB1bmlmb3JtIG1hdDQgdU1WTWF0cml4OyBcXFxyXG4gIHVuaWZvcm0gbWF0NCB1UE1hdHJpeDsgXFxcclxuICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDsgXFxcclxuICB2b2lkIG1haW4odm9pZCkgeyBcXFxyXG4gICAgZ2xfUG9zaXRpb24gPSB1UE1hdHJpeCAqIHVNVk1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApOyBcXFxyXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7IFxcXHJcbiAgfSBcXFxyXG5cIik7XHJcblxyXG52YXIgZnJhZ21lbnRTaGFkZXJTY3JpcHQgPSBTY3JpcHQuY3JlYXRlRnJvbVNvdXJjZShcIngtc2hhZGVyL3gtZnJhZ21lbnRcIiwgXCIgXFxcclxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7IFxcXHJcbiAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7IFxcXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTsgXFxcclxuICB2b2lkIG1haW4odm9pZCkgeyBcXFxyXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXh0dXJlQ29vcmQpOyBcXFxyXG4gIH0gXFxcclxuXCIpO1xyXG5cclxudmFyIFdlYkdMQ2FudmFzID0gbmV3IENsYXNzKHtcclxuXHJcbiAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKGNhbnZhcywgc2l6ZSwgdXNlRnJhbWVCdWZmZXIpIHtcclxuXHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHNpemUudztcclxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHNpemUuaDtcclxuXHJcbiAgICB0aGlzLm9uSW5pdFdlYkdMKCk7XHJcblxyXG4gICAgdGhpcy5vbkluaXRTaGFkZXJzKCk7XHJcbiAgICB0aGlzLmluaXRCdWZmZXJzKCk7XHJcblxyXG4gICAgaWYgKHVzZUZyYW1lQnVmZmVyKVxyXG4gICAgICB0aGlzLmluaXRGcmFtZWJ1ZmZlcigpO1xyXG5cclxuICAgIHRoaXMub25Jbml0VGV4dHVyZXMoKTtcclxuICAgIHRoaXMuaW5pdFNjZW5lKCk7XHJcbiAgfSxcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgZnJhbWUgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIHJlbmRlciBvZmYtc2NyZWVuLlxyXG4gKi9cclxuICBpbml0RnJhbWVidWZmZXIgOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgIC8vIENyZWF0ZSBmcmFtZWJ1ZmZlciBvYmplY3QgYW5kIHRleHR1cmUuXHJcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTsgXHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xyXG4gICAgdGhpcy5mcmFtZWJ1ZmZlclRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNpemUsIGdsLlJHQkEpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgYWxsb2NhdGUgcmVuZGVyYnVmZmVyIGZvciBkZXB0aCBkYXRhLlxyXG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XHJcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuc2l6ZS53LCB0aGlzLnNpemUuaCk7XHJcblxyXG4gICAgLy8gQXR0YWNoIHRleHR1cmUgYW5kIHJlbmRlcmJ1ZmZlciB0byB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZnJhbWVidWZmZXJUZXh0dXJlLnRleHR1cmUsIDApO1xyXG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcclxuICB9LFxyXG5cclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSB2ZXJ0ZXggYW5kIHRleHR1cmUgY29vcmRpbmF0ZSBidWZmZXJzIGZvciBhIHBsYW5lLlxyXG4gKi9cclxuICBpbml0QnVmZmVycyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0bXA7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgdmVydGV4IHBvc2l0aW9uIGJ1ZmZlci5cclxuICAgIHRoaXMucXVhZFZQQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5xdWFkVlBCdWZmZXIpO1xyXG4gICAgdG1wID0gW1xyXG4gICAgICAgMS4wLCAgMS4wLCAwLjAsXHJcbiAgICAgIC0xLjAsICAxLjAsIDAuMCwgXHJcbiAgICAgICAxLjAsIC0xLjAsIDAuMCwgXHJcbiAgICAgIC0xLjAsIC0xLjAsIDAuMF07XHJcbiAgICBcclxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRtcCksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIHRoaXMucXVhZFZQQnVmZmVyLml0ZW1TaXplID0gMztcclxuICAgIHRoaXMucXVhZFZQQnVmZmVyLm51bUl0ZW1zID0gNDtcclxuICAgIFxyXG4gICAgLypcclxuICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0rIFxyXG4gICAgIHwgLTEsMSAoMSkgICAgICAgICAgIHwgMSwxICgwKVxyXG4gICAgIHwgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICB8ICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgfCAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgIHwgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICB8ICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgfCAtMSwtMSAoMykgICAgICAgICAgfCAxLC0xICgyKVxyXG4gICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLStcclxuICAgICAqL1xyXG4gICAgXHJcbiAgICB2YXIgc2NhbGVYID0gMS4wO1xyXG4gICAgdmFyIHNjYWxlWSA9IDEuMDtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHZlcnRleCB0ZXh0dXJlIGNvb3JkaW5hdGUgYnVmZmVyLlxyXG4gICAgdGhpcy5xdWFkVlRDQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5xdWFkVlRDQnVmZmVyKTtcclxuICAgIHRtcCA9IFtcclxuICAgICAgc2NhbGVYLCAwLjAsXHJcbiAgICAgIDAuMCwgMC4wLFxyXG4gICAgICBzY2FsZVgsIHNjYWxlWSxcclxuICAgICAgMC4wLCBzY2FsZVksXHJcbiAgICBdO1xyXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodG1wKSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gIH0sXHJcblxyXG5cclxuICBtdklkZW50aXR5IDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5tdk1hdHJpeCA9IE1hdHJpeC5JKDQpO1xyXG4gIH0sXHJcblxyXG4gIG12TXVsdGlwbHkgOiBmdW5jdGlvbihtKSB7XHJcbiAgICB0aGlzLm12TWF0cml4ID0gdGhpcy5tdk1hdHJpeC54KG0pO1xyXG4gIH0sXHJcblxyXG4gIG12VHJhbnNsYXRlIDogZnVuY3Rpb24gKG0pIHtcclxuICAgIHRoaXMubXZNdWx0aXBseShNYXRyaXguVHJhbnNsYXRpb24oJFYoW21bMF0sIG1bMV0sIG1bMl1dKSkuZW5zdXJlNHg0KCkpO1xyXG4gIH0sXHJcblxyXG4gIHNldE1hdHJpeFVuaWZvcm1zIDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5wcm9ncmFtLnNldE1hdHJpeFVuaWZvcm0oXCJ1UE1hdHJpeFwiLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMucGVyc3BlY3RpdmVNYXRyaXguZmxhdHRlbigpKSk7XHJcbiAgICB0aGlzLnByb2dyYW0uc2V0TWF0cml4VW5pZm9ybShcInVNVk1hdHJpeFwiLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMubXZNYXRyaXguZmxhdHRlbigpKSk7XHJcbiAgfSxcclxuXHJcbiAgaW5pdFNjZW5lIDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgXHJcbiAgICAvLyBFc3RhYmxpc2ggdGhlIHBlcnNwZWN0aXZlIHdpdGggd2hpY2ggd2Ugd2FudCB0byB2aWV3IHRoZVxyXG4gICAgLy8gc2NlbmUuIE91ciBmaWVsZCBvZiB2aWV3IGlzIDQ1IGRlZ3JlZXMsIHdpdGggYSB3aWR0aC9oZWlnaHRcclxuICAgIC8vIHJhdGlvIG9mIDY0MDo0ODAsIGFuZCB3ZSBvbmx5IHdhbnQgdG8gc2VlIG9iamVjdHMgYmV0d2VlbiAwLjEgdW5pdHNcclxuICAgIC8vIGFuZCAxMDAgdW5pdHMgYXdheSBmcm9tIHRoZSBjYW1lcmEuXHJcbiAgICBcclxuICAgIHRoaXMucGVyc3BlY3RpdmVNYXRyaXggPSBtYWtlUGVyc3BlY3RpdmUoNDUsIDEsIDAuMSwgMTAwLjApO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgdGhlIGRyYXdpbmcgcG9zaXRpb24gdG8gdGhlIFwiaWRlbnRpdHlcIiBwb2ludCwgd2hpY2ggaXNcclxuICAgIC8vIHRoZSBjZW50ZXIgb2YgdGhlIHNjZW5lLlxyXG4gICAgdGhpcy5tdklkZW50aXR5KCk7XHJcblxyXG4gICAgLy8gTm93IG1vdmUgdGhlIGRyYXdpbmcgcG9zaXRpb24gYSBiaXQgdG8gd2hlcmUgd2Ugd2FudCB0byBzdGFydFxyXG4gICAgLy8gZHJhd2luZyB0aGUgc3F1YXJlLlxyXG4gICAgdGhpcy5tdlRyYW5zbGF0ZShbMC4wLCAwLjAsIC0yLjRdKTtcclxuXHJcbiAgICAvLyBEcmF3IHRoZSBjdWJlIGJ5IGJpbmRpbmcgdGhlIGFycmF5IGJ1ZmZlciB0byB0aGUgY3ViZSdzIHZlcnRpY2VzXHJcbiAgICAvLyBhcnJheSwgc2V0dGluZyBhdHRyaWJ1dGVzLCBhbmQgcHVzaGluZyBpdCB0byBHTC5cclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnF1YWRWUEJ1ZmZlcik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUsIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICBcclxuICAgIC8vIFNldCB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBhdHRyaWJ1dGUgZm9yIHRoZSB2ZXJ0aWNlcy5cclxuICAgIFxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucXVhZFZUQ0J1ZmZlcik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudGV4dHVyZUNvb3JkQXR0cmlidXRlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApOyAgXHJcbiAgICBcclxuICAgIHRoaXMub25Jbml0U2NlbmVUZXh0dXJlcygpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNldE1hdHJpeFVuaWZvcm1zKCk7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmZyYW1lYnVmZmVyKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQm91bmQgRnJhbWUgQnVmZmVyXCIpO1xyXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG5cclxuXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiV2ViR0xDYW52YXMgU2l6ZTogXCIgKyB0aGlzLnNpemU7XHJcbiAgfSxcclxuXHJcbiAgY2hlY2tMYXN0RXJyb3I6IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuICAgIHZhciBlcnIgPSB0aGlzLmdsLmdldEVycm9yKCk7XHJcbiAgICBpZiAoZXJyICE9IHRoaXMuZ2wuTk9fRVJST1IpIHtcclxuICAgICAgdmFyIG5hbWUgPSB0aGlzLmdsTmFtZXNbZXJyXTtcclxuICAgICAgbmFtZSA9IChuYW1lICE9PSB1bmRlZmluZWQpID8gbmFtZSArIFwiKFwiICsgZXJyICsgXCIpXCI6XHJcbiAgICAgICAgICAoXCJVbmtub3duIFdlYkdMIEVOVU0gKDB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikgKyBcIilcIik7XHJcbiAgICAgIGlmIChvcGVyYXRpb24pIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIldlYkdMIEVycm9yOiAlcywgJXNcIiwgb3BlcmF0aW9uLCBuYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIldlYkdMIEVycm9yOiAlc1wiLCBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgb25Jbml0V2ViR0w6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZ2wgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XHJcbiAgICB9IGNhdGNoKGUpIHt9XHJcbiAgICBpZiAoIXRoaXMuZ2wpIHtcclxuICAgICAgZXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBXZWJHTC4gWW91ciBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBpdC5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5nbE5hbWVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZ2xOYW1lcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHRoaXMuZ2wpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmdsW3Byb3BlcnR5TmFtZV0gPT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aGlzLmdsTmFtZXNbdGhpcy5nbFtwcm9wZXJ0eU5hbWVdXSA9IHByb3BlcnR5TmFtZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIG9uSW5pdFNoYWRlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5wcm9ncmFtID0gbmV3IFByb2dyYW0odGhpcy5nbCk7XHJcbiAgICB0aGlzLnByb2dyYW0uYXR0YWNoKG5ldyBTaGFkZXIodGhpcy5nbCwgdmVydGV4U2hhZGVyU2NyaXB0KSk7XHJcbiAgICB0aGlzLnByb2dyYW0uYXR0YWNoKG5ldyBTaGFkZXIodGhpcy5nbCwgZnJhZ21lbnRTaGFkZXJTY3JpcHQpKTtcclxuICAgIHRoaXMucHJvZ3JhbS5saW5rKCk7XHJcbiAgICB0aGlzLnByb2dyYW0udXNlKCk7XHJcbiAgICB0aGlzLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5wcm9ncmFtLmdldEF0dHJpYnV0ZUxvY2F0aW9uKFwiYVZlcnRleFBvc2l0aW9uXCIpO1xyXG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlKTtcclxuICAgIHRoaXMudGV4dHVyZUNvb3JkQXR0cmlidXRlID0gdGhpcy5wcm9ncmFtLmdldEF0dHJpYnV0ZUxvY2F0aW9uKFwiYVRleHR1cmVDb29yZFwiKTs7XHJcbiAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMudGV4dHVyZUNvb3JkQXR0cmlidXRlKTtcclxuICB9LFxyXG5cclxuICBvbkluaXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCB0aGlzLnNpemUsIGdsLlJHQkEpO1xyXG4gIH0sXHJcblxyXG4gIG9uSW5pdFNjZW5lVGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudGV4dHVyZS5iaW5kKDAsIHRoaXMucHJvZ3JhbSwgXCJ0ZXh0dXJlXCIpO1xyXG4gIH0sXHJcblxyXG4gIGRyYXdTY2VuZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucXVhZFZQQnVmZmVyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgIFxyXG4gICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGF0dHJpYnV0ZSBmb3IgdGhlIHZlcnRpY2VzLlxyXG4gICAgXHJcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5xdWFkVlRDQnVmZmVyKTtcclxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7ICBcclxuICAgIFxyXG4gICAgdGhpcy5zZXRNYXRyaXhVbmlmb3JtcygpO1xyXG5cclxuICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuICB9LFxyXG5cclxuICByZWFkUGl4ZWxzOiBmdW5jdGlvbihidWZmZXIpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHRoaXMuc2l6ZS53LCB0aGlzLnNpemUuaCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgYnVmZmVyKTtcclxuICB9LFxyXG5cclxuICBiaW5kRnJhbWVCdWZmZXI6IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcclxuICB9LFxyXG5cclxufSk7XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xDYW52YXM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFByb2dyYW0gICAgID0gcmVxdWlyZSgnLi9Qcm9ncmFtJyk7XHJcbnZhciBTaXplICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL1NpemUnKTtcclxudmFyIFNoYWRlciAgICAgID0gcmVxdWlyZSgnLi9TaGFkZXInKTtcclxudmFyIFRleHR1cmUgICAgID0gcmVxdWlyZSgnLi9UZXh0dXJlJyk7XHJcbnZhciBTY3JpcHQgICAgICA9IHJlcXVpcmUoJy4vU2NyaXB0Jyk7XHJcbnZhciBXZWJHTENhbnZhcyA9IHJlcXVpcmUoJy4vV2ViR0xDYW52YXMnKTtcclxuXHJcbnZhciBDbGFzcyAgICAgICA9IHJlcXVpcmUoJ3VjbGFzcycpO1xyXG5cclxudmFyIHZlcnRleFNoYWRlclNjcmlwdCA9IFNjcmlwdC5jcmVhdGVGcm9tU291cmNlKFwieC1zaGFkZXIveC12ZXJ0ZXhcIiwgXCIgXFxcclxuICBhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247IFxcXHJcbiAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDsgXFxcclxuICB1bmlmb3JtIG1hdDQgdU1WTWF0cml4OyBcXFxyXG4gIHVuaWZvcm0gbWF0NCB1UE1hdHJpeDsgXFxcclxuICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDsgXFxcclxuICB2b2lkIG1haW4odm9pZCkgeyBcXFxyXG4gICAgZ2xfUG9zaXRpb24gPSB1UE1hdHJpeCAqIHVNVk1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApOyBcXFxyXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7IFxcXHJcbiAgfSBcXFxyXG5cIik7XHJcblxyXG5cclxudmFyIGZyYWdtZW50U2hhZGVyU2NyaXB0ID0gU2NyaXB0LmNyZWF0ZUZyb21Tb3VyY2UoXCJ4LXNoYWRlci94LWZyYWdtZW50XCIsIFwiIFxcXHJcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OyBcXFxyXG4gIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkOyBcXFxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIFlUZXh0dXJlOyBcXFxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIFVUZXh0dXJlOyBcXFxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIFZUZXh0dXJlOyBcXFxyXG4gIGNvbnN0IG1hdDQgWVVWMlJHQiA9IG1hdDQgXFxcclxuICAoIFxcXHJcbiAgIDEuMTY0MzgyODEyNSwgMCwgMS41OTYwMjczNDM3NSwgLS44NzA3ODUxNTYyNSwgXFxcclxuICAgMS4xNjQzODI4MTI1LCAtLjM5MTc2MTcxODc1LCAtLjgxMjk2ODc1LCAuNTI5NTkzNzUsIFxcXHJcbiAgIDEuMTY0MzgyODEyNSwgMi4wMTcyMzQzNzUsIDAsIC0xLjA4MTM5MDYyNSwgXFxcclxuICAgMCwgMCwgMCwgMSBcXFxyXG4gICk7IFxcXHJcbiAgdm9pZCBtYWluKHZvaWQpIHsgXFxcclxuICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKFlUZXh0dXJlLCAgdlRleHR1cmVDb29yZCkueCwgdGV4dHVyZTJEKFVUZXh0dXJlLCB2VGV4dHVyZUNvb3JkKS54LCB0ZXh0dXJlMkQoVlRleHR1cmUsIHZUZXh0dXJlQ29vcmQpLngsIDEpICogWVVWMlJHQjsgXFxcclxuICB9IFxcXHJcblwiKTtcclxuXHJcblxyXG5cclxuXHJcbnZhciBZVVZXZWJHTENhbnZhcyA9IG5ldyBDbGFzcyh7XHJcbiAgRXh0ZW5kcyAgOiBXZWJHTENhbnZhcyxcclxuICBCaW5kcyA6IFsnZGVjb2RlJ10sXHJcblxyXG4gIGluaXRpYWxpemUgOiBmdW5jdGlvbihjYW52YXMsIHNpemUpIHtcclxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBzaXplLnc7XHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBzaXplLmg7XHJcbiAgICB0aGlzLmZtdCA9IDA7XHJcbiAgfSxcclxuXHJcbiAgcmVzaXplIDogZnVuY3Rpb24gKHNpemUpIHtcclxuICAgIGlmICh0aGlzLnNpemUgJiYgdGhpcy5zaXplLncgPT09IHNpemUudyAmJiB0aGlzLnNpemUuaCA9PT0gc2l6ZS5oKVxyXG4gICAgcmV0dXJuO1xyXG4gICAgWVVWV2ViR0xDYW52YXMucGFyZW50LmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLmNhbnZhcywgc2l6ZSk7XHJcbiAgfSxcclxuXHJcbiAgb25Jbml0U2hhZGVyczogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnByb2dyYW0gPSBuZXcgUHJvZ3JhbSh0aGlzLmdsKTtcclxuICAgIHRoaXMucHJvZ3JhbS5hdHRhY2gobmV3IFNoYWRlcih0aGlzLmdsLCB2ZXJ0ZXhTaGFkZXJTY3JpcHQpKTtcclxuICAgIHRoaXMucHJvZ3JhbS5hdHRhY2gobmV3IFNoYWRlcih0aGlzLmdsLCBmcmFnbWVudFNoYWRlclNjcmlwdCkpO1xyXG4gICAgdGhpcy5wcm9ncmFtLmxpbmsoKTtcclxuICAgIHRoaXMucHJvZ3JhbS51c2UoKTtcclxuICAgIHRoaXMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLnByb2dyYW0uZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhVmVydGV4UG9zaXRpb25cIik7XHJcbiAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMudmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xyXG4gICAgdGhpcy50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUgPSB0aGlzLnByb2dyYW0uZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhVGV4dHVyZUNvb3JkXCIpO1xyXG4gICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XHJcbiAgfSxcclxuXHJcbiAgb25Jbml0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICB0aGlzLllUZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGhpcy5zaXplLCBmYWxzZSk7XHJcbiAgICB0aGlzLlVUZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGhpcy5zaXplLmdldEhhbGZTaXplKCksIGZhbHNlKTtcclxuICAgIHRoaXMuVlRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNpemUuZ2V0SGFsZlNpemUoKSwgZmFsc2UpO1xyXG4gIH0sXHJcblxyXG4gIG9uSW5pdFNjZW5lVGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuWVRleHR1cmUuYmluZCgwLCB0aGlzLnByb2dyYW0sIFwiWVRleHR1cmVcIik7XHJcbiAgICB0aGlzLlVUZXh0dXJlLmJpbmQoMSwgdGhpcy5wcm9ncmFtLCBcIlVUZXh0dXJlXCIpO1xyXG4gICAgdGhpcy5WVGV4dHVyZS5iaW5kKDIsIHRoaXMucHJvZ3JhbSwgXCJWVGV4dHVyZVwiKTtcclxuICB9LFxyXG5cclxuICBmaWxsWVVWVGV4dHVyZXM6IGZ1bmN0aW9uKHksIHUsIHYpIHtcclxuICAgIHRoaXMuWVRleHR1cmUuZmlsbCh5KTtcclxuICAgIHRoaXMuVVRleHR1cmUuZmlsbCh1KTtcclxuICAgIHRoaXMuVlRleHR1cmUuZmlsbCh2KTtcclxuICB9LFxyXG5cclxuICBkZWNvZGU6IGZ1bmN0aW9uKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgIGlmICghYnVmZmVyKVxyXG4gICAgICByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgdGhpcy5yZXNpemUobmV3IFNpemUod2lkdGgsIGhlaWdodCkpO1xyXG4gICAgdGhpcy5iaW5kRnJhbWVCdWZmZXIoKTtcclxuICAgIHZhciBsdW1hU2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xyXG4gICAgdmFyIGNocm9tYVNpemUgPSBsdW1hU2l6ZSA+PiAyO1xyXG5cclxuICAgIHRoaXMuWVRleHR1cmUuZmlsbChidWZmZXIuc3ViYXJyYXkoMCwgbHVtYVNpemUpKTtcclxuICAgIHRoaXMuVVRleHR1cmUuZmlsbChidWZmZXIuc3ViYXJyYXkobHVtYVNpemUsIGx1bWFTaXplICsgY2hyb21hU2l6ZSkpO1xyXG4gICAgdGhpcy5WVGV4dHVyZS5maWxsKGJ1ZmZlci5zdWJhcnJheShsdW1hU2l6ZSArIGNocm9tYVNpemUsIGx1bWFTaXplICsgMiAqIGNocm9tYVNpemUpKTtcclxuICAgIHRoaXMuZHJhd1NjZW5lKCk7XHJcbiAgfSxcclxuXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIFwiWVVWQ2FudmFzIFNpemU6IFwiICsgdGhpcy5zaXplO1xyXG4gIH1cclxufSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBZVVZXZWJHTENhbnZhcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIDItZGltZW5zaW9uYWwgc2l6ZSB2YWx1ZS4gXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gU2l6ZSh3LCBoKSB7XHJcbiAgdGhpcy53ID0gdztcclxuICB0aGlzLmggPSBoO1xyXG59XHJcblxyXG5TaXplLnByb3RvdHlwZSA9IHtcclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFwiKFwiICsgdGhpcy53ICsgXCIsIFwiICsgdGhpcy5oICsgXCIpXCI7XHJcbiAgfSxcclxuICBnZXRIYWxmU2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpemUodGhpcy53ID4+PiAxLCB0aGlzLmggPj4+IDEpO1xyXG4gIH0sXHJcbiAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLncgKiB0aGlzLmg7XHJcbiAgfVxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gU2l6ZTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBlcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKTtcclxuXHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgZXJyb3IobWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xyXG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XHJcbiAgY29uc29sZS50cmFjZSgpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVycm9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBNYXRyaXggPSByZXF1aXJlKCdzeWx2ZXN0ZXIuanMnKS5NYXRyaXg7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCdzeWx2ZXN0ZXIuanMnKS5WZWN0b3I7XHJcbnZhciAkTSAgICAgPSBNYXRyaXguY3JlYXRlO1xyXG5cclxuXHJcbi8vIGF1Z21lbnQgU3lsdmVzdGVyIHNvbWVcclxuTWF0cml4LlRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKHYpXHJcbntcclxuICBpZiAodi5lbGVtZW50cy5sZW5ndGggPT0gMikge1xyXG4gICAgdmFyIHIgPSBNYXRyaXguSSgzKTtcclxuICAgIHIuZWxlbWVudHNbMl1bMF0gPSB2LmVsZW1lbnRzWzBdO1xyXG4gICAgci5lbGVtZW50c1syXVsxXSA9IHYuZWxlbWVudHNbMV07XHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG4gIGlmICh2LmVsZW1lbnRzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICB2YXIgciA9IE1hdHJpeC5JKDQpO1xyXG4gICAgci5lbGVtZW50c1swXVszXSA9IHYuZWxlbWVudHNbMF07XHJcbiAgICByLmVsZW1lbnRzWzFdWzNdID0gdi5lbGVtZW50c1sxXTtcclxuICAgIHIuZWxlbWVudHNbMl1bM10gPSB2LmVsZW1lbnRzWzJdO1xyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuICB0aHJvdyBcIkludmFsaWQgbGVuZ3RoIGZvciBUcmFuc2xhdGlvblwiO1xyXG59XHJcblxyXG5NYXRyaXgucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiAoKVxyXG57XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gW107XHJcblxyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7IGorKylcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZWxlbWVudHNbaV1bal0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuTWF0cml4LnByb3RvdHlwZS5lbnN1cmU0eDQgPSBmdW5jdGlvbigpXHJcbntcclxuICAgIGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PSA0ICYmXHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXS5sZW5ndGggPT0gNClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggPiA0IHx8XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXS5sZW5ndGggPiA0KVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZvciAodmFyIGogPSB0aGlzLmVsZW1lbnRzW2ldLmxlbmd0aDsgaiA8IDQ7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSBqKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5wdXNoKDEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgIGlmIChpID09IDApXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChbMSwgMCwgMCwgMF0pO1xyXG4gICAgICAgIGVsc2UgaWYgKGkgPT0gMSlcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKFswLCAxLCAwLCAwXSk7XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PSAyKVxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goWzAsIDAsIDEsIDBdKTtcclxuICAgICAgICBlbHNlIGlmIChpID09IDMpXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChbMCwgMCwgMCwgMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcblZlY3Rvci5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpXHJcbntcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xyXG59O1xyXG5cclxuXHJcblxyXG4vL1xyXG4vLyBnbHVQZXJzcGVjdGl2ZVxyXG4vL1xyXG5mdW5jdGlvbiBtYWtlUGVyc3BlY3RpdmUoZm92eSwgYXNwZWN0LCB6bmVhciwgemZhcilcclxue1xyXG4gICAgdmFyIHltYXggPSB6bmVhciAqIE1hdGgudGFuKGZvdnkgKiBNYXRoLlBJIC8gMzYwLjApO1xyXG4gICAgdmFyIHltaW4gPSAteW1heDtcclxuICAgIHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcclxuICAgIHZhciB4bWF4ID0geW1heCAqIGFzcGVjdDtcclxuXHJcbiAgICByZXR1cm4gbWFrZUZydXN0dW0oeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgem5lYXIsIHpmYXIpO1xyXG59XHJcblxyXG4vL1xyXG4vLyBnbEZydXN0dW1cclxuLy9cclxuZnVuY3Rpb24gbWFrZUZydXN0dW0obGVmdCwgcmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSwgdG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICB6bmVhciwgemZhcilcclxue1xyXG4gICAgdmFyIFggPSAyKnpuZWFyLyhyaWdodC1sZWZ0KTtcclxuICAgIHZhciBZID0gMip6bmVhci8odG9wLWJvdHRvbSk7XHJcbiAgICB2YXIgQSA9IChyaWdodCtsZWZ0KS8ocmlnaHQtbGVmdCk7XHJcbiAgICB2YXIgQiA9ICh0b3ArYm90dG9tKS8odG9wLWJvdHRvbSk7XHJcbiAgICB2YXIgQyA9IC0oemZhcit6bmVhcikvKHpmYXItem5lYXIpO1xyXG4gICAgdmFyIEQgPSAtMip6ZmFyKnpuZWFyLyh6ZmFyLXpuZWFyKTtcclxuXHJcbiAgICByZXR1cm4gJE0oW1tYLCAwLCBBLCAwXSxcclxuICAgICAgICAgICAgICAgWzAsIFksIEIsIDBdLFxyXG4gICAgICAgICAgICAgICBbMCwgMCwgQywgRF0sXHJcbiAgICAgICAgICAgICAgIFswLCAwLCAtMSwgMF1dKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMubWFrZVBlcnNwZWN0aXZlID0gbWFrZVBlcnNwZWN0aXZlO1xyXG5cclxuIiwidmFyIGtpbmRPZiA9IHJlcXVpcmUoJy4va2luZE9mJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xudmFyIG1peEluID0gcmVxdWlyZSgnLi4vb2JqZWN0L21peEluJyk7XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSBuYXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsKXtcbiAgICAgICAgc3dpdGNoIChraW5kT2YodmFsKSkge1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVPYmplY3QodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheSh2YWwpO1xuICAgICAgICAgICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAodmFsKTtcbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGUodmFsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lT2JqZWN0KHNvdXJjZSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4SW4oe30sIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocikge1xuICAgICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5tdWx0aWxpbmUgPyAnbScgOiAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5nbG9iYWwgPyAnZycgOiAnJztcbiAgICAgICAgZmxhZ3MgKz0gci5pZ25vcmVDYXNlID8gJ2knIDogJyc7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHIuc291cmNlLCBmbGFncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCtkYXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuXG4iLCJ2YXIgbWl4SW4gPSByZXF1aXJlKCcuLi9vYmplY3QvbWl4SW4nKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBPYmplY3QgdXNpbmcgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgc2V0dGluZyBjdXN0b20gcHJvcGVydGllcy5cbiAgICAgKiAtIE1peCBiZXR3ZWVuIERvdWdsYXMgQ3JvY2tmb3JkIFByb3RvdHlwYWwgSW5oZXJpdGFuY2UgPGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vcHJvdG90eXBhbC5odG1sPiBhbmQgdGhlIEVjbWFTY3JpcHQgNSBgT2JqZWN0LmNyZWF0ZSgpYCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudCAgICBQYXJlbnQgT2JqZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdIE9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ3JlYXRlZCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0KHBhcmVudCwgcHJvcHMpe1xuICAgICAgICBmdW5jdGlvbiBGKCl7fVxuICAgICAgICBGLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG1peEluKG5ldyBGKCksIHByb3BzKTtcblxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU9iamVjdDtcblxuXG4iLCJ2YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG52YXIgZm9yT3duID0gcmVxdWlyZSgnLi4vb2JqZWN0L2Zvck93bicpO1xudmFyIGtpbmRPZiA9IHJlcXVpcmUoJy4va2luZE9mJyk7XG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgY2xvbmUgbmF0aXZlIHR5cGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZXBDbG9uZSh2YWwsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgc3dpdGNoICgga2luZE9mKHZhbCkgKSB7XG4gICAgICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZU9iamVjdCh2YWwsIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5KHZhbCwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVPYmplY3Qoc291cmNlLCBpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgIGZvck93bihzb3VyY2UsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENsb25lKHZhbCwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICB9LCBvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VDbG9uZShzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyLCBpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIG4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgdmFsO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgb3V0W2ldID0gZGVlcENsb25lKGFycltpXSwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZXBDbG9uZTtcblxuXG5cbiIsInZhciBraW5kT2YgPSByZXF1aXJlKCcuL2tpbmRPZicpO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGZyb20gYSBzcGVjaWZpYyBcImtpbmRcIi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tpbmQodmFsLCBraW5kKXtcbiAgICAgICAgcmV0dXJuIGtpbmRPZih2YWwpID09PSBraW5kO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzS2luZDtcblxuIiwidmFyIGlzS2luZCA9IHJlcXVpcmUoJy4vaXNLaW5kJyk7XG4gICAgLyoqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnT2JqZWN0Jyk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cbiIsIlxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuIiwiXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJraW5kXCIgb2YgdmFsdWUuIChlLmcuIFwiU3RyaW5nXCIsIFwiTnVtYmVyXCIsIGV0YylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ga2luZE9mO1xuXG4iLCJ2YXIgaGFzT3duID0gcmVxdWlyZSgnLi9oYXNPd24nKTtcblxuICAgIHZhciBfaGFzRG9udEVudW1CdWcsXG4gICAgICAgIF9kb250RW51bXM7XG5cbiAgICBmdW5jdGlvbiBjaGVja0RvbnRFbnVtKCl7XG4gICAgICAgIF9kb250RW51bXMgPSBbXG4gICAgICAgICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgX2hhc0RvbnRFbnVtQnVnID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4geyd0b1N0cmluZyc6IG51bGx9KSB7XG4gICAgICAgICAgICBfaGFzRG9udEVudW1CdWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gQXJyYXkvZm9yRWFjaCBidXQgd29ya3Mgb3ZlciBvYmplY3QgcHJvcGVydGllcyBhbmQgZml4ZXMgRG9uJ3RcbiAgICAgKiBFbnVtIGJ1ZyBvbiBJRS5cbiAgICAgKiBiYXNlZCBvbjogaHR0cDovL3doYXR0aGVoZWFkc2FpZC5jb20vMjAxMC8xMC9hLXNhZmVyLW9iamVjdC1rZXlzLWNvbXBhdGliaWxpdHktaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmosIGZuLCB0aGlzT2JqKXtcbiAgICAgICAgdmFyIGtleSwgaSA9IDA7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gY2hlY2sgaWYgYXJndW1lbnQgaXMgYSByZWFsIG9iamVjdCB0aGF0IHdheSB3ZSBjYW4gdXNlXG4gICAgICAgIC8vIGl0IGZvciBhcnJheXMsIGZ1bmN0aW9ucywgZGF0ZSwgZXRjLlxuXG4gICAgICAgIC8vcG9zdC1wb25lIGNoZWNrIHRpbGwgbmVlZGVkXG4gICAgICAgIGlmIChfaGFzRG9udEVudW1CdWcgPT0gbnVsbCkgY2hlY2tEb250RW51bSgpO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGV4ZWMoZm4sIG9iaiwga2V5LCB0aGlzT2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKF9oYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgdmFyIGN0b3IgPSBvYmouY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgaXNQcm90byA9ICEhY3RvciAmJiBvYmogPT09IGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgICB3aGlsZSAoa2V5ID0gX2RvbnRFbnVtc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbnN0cnVjdG9yLCBpZiBpdCBpcyBhIHByb3RvdHlwZSBvYmplY3QgdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLy8gaXMgYWx3YXlzIG5vbi1lbnVtZXJhYmxlIHVubGVzcyBkZWZpbmVkIG90aGVyd2lzZSAoYW5kXG4gICAgICAgICAgICAgICAgLy8gZW51bWVyYXRlZCBhYm92ZSkuICBGb3Igbm9uLXByb3RvdHlwZSBvYmplY3RzLCBpdCB3aWxsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyB0byBiZSBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0LCBzaW5jZSBpdCBjYW5ub3QgYmUgZGVmaW5lZCBvblxuICAgICAgICAgICAgICAgIC8vIGFueSBwcm90b3R5cGUgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZvciBvdGhlciBbW0RvbnRFbnVtXV0gcHJvcGVydGllcywgY2hlY2sgaWYgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IHRoYW4gT2JqZWN0IHByb3RvdHlwZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChrZXkgIT09ICdjb25zdHJ1Y3RvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICghaXNQcm90byAmJiBoYXNPd24ob2JqLCBrZXkpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gIT09IE9iamVjdC5wcm90b3R5cGVba2V5XVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlYyhmbiwgb2JqLCBrZXksIHRoaXNPYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjKGZuLCBvYmosIGtleSwgdGhpc09iail7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXNPYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmb3JJbjtcblxuXG4iLCJ2YXIgaGFzT3duID0gcmVxdWlyZSgnLi9oYXNPd24nKTtcbnZhciBmb3JJbiA9IHJlcXVpcmUoJy4vZm9ySW4nKTtcblxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gQXJyYXkvZm9yRWFjaCBidXQgd29ya3Mgb3ZlciBvYmplY3QgcHJvcGVydGllcyBhbmQgZml4ZXMgRG9uJ3RcbiAgICAgKiBFbnVtIGJ1ZyBvbiBJRS5cbiAgICAgKiBiYXNlZCBvbjogaHR0cDovL3doYXR0aGVoZWFkc2FpZC5jb20vMjAxMC8xMC9hLXNhZmVyLW9iamVjdC1rZXlzLWNvbXBhdGliaWxpdHktaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqLCBmbiwgdGhpc09iail7XG4gICAgICAgIGZvckluKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpe1xuICAgICAgICAgICAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzT2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZvck93bjtcblxuXG4iLCJcblxuICAgIC8qKlxuICAgICAqIFNhZmVyIE9iamVjdC5oYXNPd25Qcm9wZXJ0eVxuICAgICAqL1xuICAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBwcm9wKXtcbiAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbiAgICAgfVxuXG4gICAgIG1vZHVsZS5leHBvcnRzID0gaGFzT3duO1xuXG5cbiIsInZhciBoYXNPd24gPSByZXF1aXJlKCcuL2hhc093bicpO1xudmFyIGRlZXBDbG9uZSA9IHJlcXVpcmUoJy4uL2xhbmcvZGVlcENsb25lJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWVwIG1lcmdlIG9iamVjdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgICAgIHZhciBpID0gMSxcbiAgICAgICAgICAgIGtleSwgdmFsLCBvYmosIHRhcmdldDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgbW9kaWZ5IHNvdXJjZSBlbGVtZW50IGFuZCBpdCdzIHByb3BlcnRpZXNcbiAgICAgICAgLy8gb2JqZWN0cyBhcmUgcGFzc2VkIGJ5IHJlZmVyZW5jZVxuICAgICAgICB0YXJnZXQgPSBkZWVwQ2xvbmUoIGFyZ3VtZW50c1swXSApO1xuXG4gICAgICAgIHdoaWxlIChvYmogPSBhcmd1bWVudHNbaSsrXSkge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGhhc093bihvYmosIGtleSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBpc09iamVjdCh2YWwpICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSApe1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNlcHRpb24sIGRlZXAgbWVyZ2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFtrZXldLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhcnJheXMsIHJlZ2V4cCwgZGF0ZSwgb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZGVlcENsb25lKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG5cblxuIiwidmFyIGZvck93biA9IHJlcXVpcmUoJy4vZm9yT3duJyk7XG5cbiAgICAvKipcbiAgICAqIENvbWJpbmUgcHJvcGVydGllcyBmcm9tIGFsbCB0aGUgb2JqZWN0cyBpbnRvIGZpcnN0IG9uZS5cbiAgICAqIC0gVGhpcyBtZXRob2QgYWZmZWN0cyB0YXJnZXQgb2JqZWN0IGluIHBsYWNlLCBpZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBuZXcgT2JqZWN0IHBhc3MgYW4gZW1wdHkgb2JqZWN0IGFzIGZpcnN0IHBhcmFtLlxuICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAgICBUYXJnZXQgT2JqZWN0XG4gICAgKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0cyAgICBPYmplY3RzIHRvIGJlIGNvbWJpbmVkICgwLi4ubiBvYmplY3RzKS5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gVGFyZ2V0IE9iamVjdC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1peEluKHRhcmdldCwgb2JqZWN0cyl7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2JqO1xuICAgICAgICB3aGlsZSgrK2kgPCBuKXtcbiAgICAgICAgICAgIG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvck93bihvYmosIGNvcHlQcm9wLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVByb3AodmFsLCBrZXkpe1xuICAgICAgICB0aGlzW2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtaXhJbjtcblxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbFxuXG52YXIgZ2xvYmFsID0gKEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKSgpO1xuXG5leHBvcnRzLlZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG5nbG9iYWwuJFYgPSBleHBvcnRzLlZlY3Rvci5jcmVhdGU7XG5leHBvcnRzLk1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5nbG9iYWwuJE0gPSBleHBvcnRzLk1hdHJpeC5jcmVhdGU7XG5leHBvcnRzLkxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbmdsb2JhbC4kTCA9IGV4cG9ydHMuTGluZS5jcmVhdGU7XG5leHBvcnRzLlBsYW5lID0gcmVxdWlyZSgnLi9wbGFuZScpO1xuZ2xvYmFsLiRQID0gZXhwb3J0cy5QbGFuZS5jcmVhdGU7XG5leHBvcnRzLkxpbmUuU2VnbWVudCA9IHJlcXVpcmUoJy4vbGluZS5zZWdtZW50Jyk7XG5leHBvcnRzLlN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG52YXIgUGxhbmUgPSByZXF1aXJlKCcuL3BsYW5lJyk7XG52YXIgU3lsdmVzdGVyID0gcmVxdWlyZSgnLi9zeWx2ZXN0ZXInKTtcblxuLy8gTGluZSBjbGFzcyAtIGRlcGVuZHMgb24gVmVjdG9yLCBhbmQgc29tZSBtZXRob2RzIHJlcXVpcmUgTWF0cml4IGFuZCBQbGFuZS5cblxuZnVuY3Rpb24gTGluZSgpIHt9XG5MaW5lLnByb3RvdHlwZSA9IHtcblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IG9jY3VwaWVzIHRoZSBzYW1lIHNwYWNlIGFzIHRoZSBsaW5lXG4gIGVxbDogZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiAodGhpcy5pc1BhcmFsbGVsVG8obGluZSkgJiYgdGhpcy5jb250YWlucyhsaW5lLmFuY2hvcikpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lXG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIExpbmUuY3JlYXRlKHRoaXMuYW5jaG9yLCB0aGlzLmRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRyYW5zbGF0aW5nIHRoZSBsaW5lIGJ5IHRoZSBnaXZlbiB2ZWN0b3IvYXJyYXlcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XG4gICAgcmV0dXJuIExpbmUuY3JlYXRlKFtcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzBdICsgVlswXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzFdICsgVlsxXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzJdICsgKFZbMl0gfHwgMClcbiAgICBdLCB0aGlzLmRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBsaW5lIGlzIHBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudC4gSGVyZSwgJ3BhcmFsbGVsIHRvJ1xuICAvLyBtZWFucyB0aGF0IHRoZSBhcmd1bWVudCdzIGRpcmVjdGlvbiBpcyBlaXRoZXIgcGFyYWxsZWwgb3IgYW50aXBhcmFsbGVsIHRvXG4gIC8vIHRoZSBsaW5lJ3Mgb3duIGRpcmVjdGlvbi4gQSBsaW5lIGlzIHBhcmFsbGVsIHRvIGEgcGxhbmUgaWYgdGhlIHR3byBkbyBub3RcbiAgLy8gaGF2ZSBhIHVuaXF1ZSBpbnRlcnNlY3Rpb24uXG4gIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwgfHwgKG9iai5zdGFydCAmJiBvYmouZW5kKSkgeyByZXR1cm4gb2JqLmlzUGFyYWxsZWxUbyh0aGlzKTsgfVxuICAgIHZhciB0aGV0YSA9IHRoaXMuZGlyZWN0aW9uLmFuZ2xlRnJvbShvYmouZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gKE1hdGguYWJzKHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoZXRhIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgbGluZSdzIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgYXJndW1lbnQsXG4gIC8vIHdoaWNoIGNhbiBiZSBhIHBvaW50LCBhIGxpbmUgb3IgYSBwbGFuZVxuICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsIHx8IChvYmouc3RhcnQgJiYgb2JqLmVuZCkpIHsgcmV0dXJuIG9iai5kaXN0YW5jZUZyb20odGhpcyk7IH1cbiAgICBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgaWYgKHRoaXMuaXNQYXJhbGxlbFRvKG9iaikpIHsgcmV0dXJuIHRoaXMuZGlzdGFuY2VGcm9tKG9iai5hbmNob3IpOyB9XG4gICAgICB2YXIgTiA9IHRoaXMuZGlyZWN0aW9uLmNyb3NzKG9iai5kaXJlY3Rpb24pLnRvVW5pdFZlY3RvcigpLmVsZW1lbnRzO1xuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgQiA9IG9iai5hbmNob3IuZWxlbWVudHM7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoKEFbMF0gLSBCWzBdKSAqIE5bMF0gKyAoQVsxXSAtIEJbMV0pICogTlsxXSArIChBWzJdIC0gQlsyXSkgKiBOWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBQQTEgPSBQWzBdIC0gQVswXSwgUEEyID0gUFsxXSAtIEFbMV0sIFBBMyA9IChQWzJdIHx8IDApIC0gQVsyXTtcbiAgICAgIHZhciBtb2RQQSA9IE1hdGguc3FydChQQTEqUEExICsgUEEyKlBBMiArIFBBMypQQTMpO1xuICAgICAgaWYgKG1vZFBBID09PSAwKSByZXR1cm4gMDtcbiAgICAgIC8vIEFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvciBpcyBub3JtYWxpemVkXG4gICAgICB2YXIgY29zVGhldGEgPSAoUEExICogRFswXSArIFBBMiAqIERbMV0gKyBQQTMgKiBEWzJdKSAvIG1vZFBBO1xuICAgICAgdmFyIHNpbjIgPSAxIC0gY29zVGhldGEqY29zVGhldGE7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobW9kUEEgKiBNYXRoLnNxcnQoc2luMiA8IDAgPyAwIDogc2luMikpO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBhcmd1bWVudCBpcyBhIHBvaW50IG9uIHRoZSBsaW5lLCBvciBpZiB0aGUgYXJndW1lbnRcbiAgLy8gaXMgYSBsaW5lIHNlZ21lbnQgbHlpbmcgd2l0aGluIHRoZSByZWNlaXZlclxuICBjb250YWluczogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5zdGFydCAmJiBvYmouZW5kKSB7IHJldHVybiB0aGlzLmNvbnRhaW5zKG9iai5zdGFydCkgJiYgdGhpcy5jb250YWlucyhvYmouZW5kKTsgfVxuICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZUZyb20ob2JqKTtcbiAgICByZXR1cm4gKGRpc3QgIT09IG51bGwgJiYgZGlzdCA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3Igb2YgdGhlIGdpdmVuIHBvaW50LiBOZWdhdGl2ZSB2YWx1ZXMgYXJlXG4gIC8vIHJldHVybmVkIGZvciBwb2ludHMgdGhhdCBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byB0aGUgbGluZSdzIGRpcmVjdGlvbiBmcm9tXG4gIC8vIHRoZSBsaW5lJ3MgYW5jaG9yIHBvaW50LlxuICBwb3NpdGlvbk9mOiBmdW5jdGlvbihwb2ludCkge1xuICAgIGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgUCA9IHBvaW50LmVsZW1lbnRzIHx8IHBvaW50O1xuICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICByZXR1cm4gKFBbMF0gLSBBWzBdKSAqIERbMF0gKyAoUFsxXSAtIEFbMV0pICogRFsxXSArICgoUFsyXSB8fCAwKSAtIEFbMl0pICogRFsyXTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIGxpZXMgaW4gdGhlIGdpdmVuIHBsYW5lXG4gIGxpZXNJbjogZnVuY3Rpb24ocGxhbmUpIHtcbiAgICByZXR1cm4gcGxhbmUuY29udGFpbnModGhpcyk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbGluZSBoYXMgYSB1bmlxdWUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGFyZ3VtZW50XG4gIGludGVyc2VjdHM6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7IHJldHVybiBvYmouaW50ZXJzZWN0cyh0aGlzKTsgfVxuICAgIHJldHVybiAoIXRoaXMuaXNQYXJhbGxlbFRvKG9iaikgJiYgdGhpcy5kaXN0YW5jZUZyb20ob2JqKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgaW50ZXJzZWN0aW9uIHBvaW50IHdpdGggdGhlIGFyZ3VtZW50LCBpZiBvbmUgZXhpc3RzXG4gIGludGVyc2VjdGlvbldpdGg6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsIHx8IChvYmouc3RhcnQgJiYgb2JqLmVuZCkpIHsgcmV0dXJuIG9iai5pbnRlcnNlY3Rpb25XaXRoKHRoaXMpOyB9XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdHMob2JqKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBQID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIFggPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cyxcbiAgICAgICAgUSA9IG9iai5hbmNob3IuZWxlbWVudHMsIFkgPSBvYmouZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgIHZhciBYMSA9IFhbMF0sIFgyID0gWFsxXSwgWDMgPSBYWzJdLCBZMSA9IFlbMF0sIFkyID0gWVsxXSwgWTMgPSBZWzJdO1xuICAgIHZhciBQc3ViUTEgPSBQWzBdIC0gUVswXSwgUHN1YlEyID0gUFsxXSAtIFFbMV0sIFBzdWJRMyA9IFBbMl0gLSBRWzJdO1xuICAgIHZhciBYZG90UXN1YlAgPSAtIFgxKlBzdWJRMSAtIFgyKlBzdWJRMiAtIFgzKlBzdWJRMztcbiAgICB2YXIgWWRvdFBzdWJRID0gWTEqUHN1YlExICsgWTIqUHN1YlEyICsgWTMqUHN1YlEzO1xuICAgIHZhciBYZG90WCA9IFgxKlgxICsgWDIqWDIgKyBYMypYMztcbiAgICB2YXIgWWRvdFkgPSBZMSpZMSArIFkyKlkyICsgWTMqWTM7XG4gICAgdmFyIFhkb3RZID0gWDEqWTEgKyBYMipZMiArIFgzKlkzO1xuICAgIHZhciBrID0gKFhkb3RRc3ViUCAqIFlkb3RZIC8gWGRvdFggKyBYZG90WSAqIFlkb3RQc3ViUSkgLyAoWWRvdFkgLSBYZG90WSAqIFhkb3RZKTtcbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbUFswXSArIGsqWDEsIFBbMV0gKyBrKlgyLCBQWzJdICsgaypYM10pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gcG9pbnQgb3IgbGluZS9saW5lIHNlZ21lbnRcbiAgcG9pbnRDbG9zZXN0VG86IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouc3RhcnQgJiYgb2JqLmVuZCkge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZSBzZWdtZW50XG4gICAgICB2YXIgUCA9IG9iai5wb2ludENsb3Nlc3RUbyh0aGlzKTtcbiAgICAgIHJldHVybiAoUCA9PT0gbnVsbCkgPyBudWxsIDogdGhpcy5wb2ludENsb3Nlc3RUbyhQKTtcbiAgICB9IGVsc2UgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmVcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHMob2JqKSkgeyByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25XaXRoKG9iaik7IH1cbiAgICAgIGlmICh0aGlzLmlzUGFyYWxsZWxUbyhvYmopKSB7IHJldHVybiBudWxsOyB9XG4gICAgICB2YXIgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzLCBFID0gb2JqLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBEMSA9IERbMF0sIEQyID0gRFsxXSwgRDMgPSBEWzJdLCBFMSA9IEVbMF0sIEUyID0gRVsxXSwgRTMgPSBFWzJdO1xuICAgICAgLy8gQ3JlYXRlIHBsYW5lIGNvbnRhaW5pbmcgb2JqIGFuZCB0aGUgc2hhcmVkIG5vcm1hbCBhbmQgaW50ZXJzZWN0IHRoaXMgd2l0aCBpdFxuICAgICAgLy8gVGhhbmsgeW91OiBodHRwOi8vd3d3LmNnYWZhcS5pbmZvL3dpa2kvTGluZS1saW5lX2Rpc3RhbmNlXG4gICAgICB2YXIgeCA9IChEMyAqIEUxIC0gRDEgKiBFMyksIHkgPSAoRDEgKiBFMiAtIEQyICogRTEpLCB6ID0gKEQyICogRTMgLSBEMyAqIEUyKTtcbiAgICAgIHZhciBOID0gW3ggKiBFMyAtIHkgKiBFMiwgeSAqIEUxIC0geiAqIEUzLCB6ICogRTIgLSB4ICogRTFdO1xuICAgICAgdmFyIFAgPSBQbGFuZS5jcmVhdGUob2JqLmFuY2hvciwgTik7XG4gICAgICByZXR1cm4gUC5pbnRlcnNlY3Rpb25XaXRoKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvYmogaXMgYSBwb2ludFxuICAgICAgdmFyIFAgPSBvYmouZWxlbWVudHMgfHwgb2JqO1xuICAgICAgaWYgKHRoaXMuY29udGFpbnMoUCkpIHsgcmV0dXJuIFZlY3Rvci5jcmVhdGUoUCk7IH1cbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBEMSA9IERbMF0sIEQyID0gRFsxXSwgRDMgPSBEWzJdLCBBMSA9IEFbMF0sIEEyID0gQVsxXSwgQTMgPSBBWzJdO1xuICAgICAgdmFyIHggPSBEMSAqIChQWzFdLUEyKSAtIEQyICogKFBbMF0tQTEpLCB5ID0gRDIgKiAoKFBbMl0gfHwgMCkgLSBBMykgLSBEMyAqIChQWzFdLUEyKSxcbiAgICAgICAgICB6ID0gRDMgKiAoUFswXS1BMSkgLSBEMSAqICgoUFsyXSB8fCAwKSAtIEEzKTtcbiAgICAgIHZhciBWID0gVmVjdG9yLmNyZWF0ZShbRDIgKiB4IC0gRDMgKiB6LCBEMyAqIHkgLSBEMSAqIHgsIEQxICogeiAtIEQyICogeV0pO1xuICAgICAgdmFyIGsgPSB0aGlzLmRpc3RhbmNlRnJvbShQKSAvIFYubW9kdWx1cygpO1xuICAgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUoW1xuICAgICAgICBQWzBdICsgVi5lbGVtZW50c1swXSAqIGssXG4gICAgICAgIFBbMV0gKyBWLmVsZW1lbnRzWzFdICogayxcbiAgICAgICAgKFBbMl0gfHwgMCkgKyBWLmVsZW1lbnRzWzJdICoga1xuICAgICAgXSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lIHJvdGF0ZWQgYnkgdCByYWRpYW5zIGFib3V0IHRoZSBnaXZlbiBsaW5lLiBXb3JrcyBieVxuICAvLyBmaW5kaW5nIHRoZSBhcmd1bWVudCdzIGNsb3Nlc3QgcG9pbnQgdG8gdGhpcyBsaW5lJ3MgYW5jaG9yIHBvaW50IChjYWxsIHRoaXMgQykgYW5kXG4gIC8vIHJvdGF0aW5nIHRoZSBhbmNob3IgYWJvdXQgQy4gQWxzbyByb3RhdGVzIHRoZSBsaW5lJ3MgZGlyZWN0aW9uIGFib3V0IHRoZSBhcmd1bWVudCdzLlxuICAvLyBCZSBjYXJlZnVsIHdpdGggdGhpcyAtIHRoZSByb3RhdGlvbiBheGlzJyBkaXJlY3Rpb24gYWZmZWN0cyB0aGUgb3V0Y29tZSFcbiAgcm90YXRlOiBmdW5jdGlvbih0LCBsaW5lKSB7XG4gICAgLy8gSWYgd2UncmUgd29ya2luZyBpbiAyRFxuICAgIGlmICh0eXBlb2YobGluZS5kaXJlY3Rpb24pID09ICd1bmRlZmluZWQnKSB7IGxpbmUgPSBMaW5lLmNyZWF0ZShsaW5lLnRvM0QoKSwgVmVjdG9yLmspOyB9XG4gICAgdmFyIFIgPSBNYXRyaXguUm90YXRpb24odCwgbGluZS5kaXJlY3Rpb24pLmVsZW1lbnRzO1xuICAgIHZhciBDID0gbGluZS5wb2ludENsb3Nlc3RUbyh0aGlzLmFuY2hvcikuZWxlbWVudHM7XG4gICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgIHZhciBDMSA9IENbMF0sIEMyID0gQ1sxXSwgQzMgPSBDWzJdLCBBMSA9IEFbMF0sIEEyID0gQVsxXSwgQTMgPSBBWzJdO1xuICAgIHZhciB4ID0gQTEgLSBDMSwgeSA9IEEyIC0gQzIsIHogPSBBMyAtIEMzO1xuICAgIHJldHVybiBMaW5lLmNyZWF0ZShbXG4gICAgICBDMSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcbiAgICAgIEMyICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuICAgICAgQzMgKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICBdLCBbXG4gICAgICBSWzBdWzBdICogRFswXSArIFJbMF1bMV0gKiBEWzFdICsgUlswXVsyXSAqIERbMl0sXG4gICAgICBSWzFdWzBdICogRFswXSArIFJbMV1bMV0gKiBEWzFdICsgUlsxXVsyXSAqIERbMl0sXG4gICAgICBSWzJdWzBdICogRFswXSArIFJbMl1bMV0gKiBEWzFdICsgUlsyXVsyXSAqIERbMl1cbiAgICBdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGluZSB3aXRoIGl0cyBkaXJlY3Rpb24gdmVjdG9yIHJldmVyc2VkLlxuICAvLyBVc2VmdWwgd2hlbiB1c2luZyBsaW5lcyBmb3Igcm90YXRpb25zLlxuICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTGluZS5jcmVhdGUodGhpcy5hbmNob3IsIHRoaXMuZGlyZWN0aW9uLngoLTEpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBsaW5lJ3MgcmVmbGVjdGlvbiBpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgbGluZVxuICByZWZsZWN0aW9uSW46IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZVxuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgICAgdmFyIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl0sIEQxID0gRFswXSwgRDIgPSBEWzFdLCBEMyA9IERbMl07XG4gICAgICB2YXIgbmV3QSA9IHRoaXMuYW5jaG9yLnJlZmxlY3Rpb25JbihvYmopLmVsZW1lbnRzO1xuICAgICAgLy8gQWRkIHRoZSBsaW5lJ3MgZGlyZWN0aW9uIHZlY3RvciB0byBpdHMgYW5jaG9yLCB0aGVuIG1pcnJvciB0aGF0IGluIHRoZSBwbGFuZVxuICAgICAgdmFyIEFEMSA9IEExICsgRDEsIEFEMiA9IEEyICsgRDIsIEFEMyA9IEEzICsgRDM7XG4gICAgICB2YXIgUSA9IG9iai5wb2ludENsb3Nlc3RUbyhbQUQxLCBBRDIsIEFEM10pLmVsZW1lbnRzO1xuICAgICAgdmFyIG5ld0QgPSBbUVswXSArIChRWzBdIC0gQUQxKSAtIG5ld0FbMF0sIFFbMV0gKyAoUVsxXSAtIEFEMikgLSBuZXdBWzFdLCBRWzJdICsgKFFbMl0gLSBBRDMpIC0gbmV3QVsyXV07XG4gICAgICByZXR1cm4gTGluZS5jcmVhdGUobmV3QSwgbmV3RCk7XG4gICAgfSBlbHNlIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lIC0gcmVmbGVjdGlvbiBvYnRhaW5lZCBieSByb3RhdGluZyBQSSByYWRpYW5zIGFib3V0IG9ialxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlKE1hdGguUEksIG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBvaW50IC0ganVzdCByZWZsZWN0IHRoZSBsaW5lJ3MgYW5jaG9yIGluIGl0XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICByZXR1cm4gTGluZS5jcmVhdGUodGhpcy5hbmNob3IucmVmbGVjdGlvbkluKFtQWzBdLCBQWzFdLCAoUFsyXSB8fCAwKV0pLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNldCB0aGUgbGluZSdzIGFuY2hvciBwb2ludCBhbmQgZGlyZWN0aW9uLlxuICBzZXRWZWN0b3JzOiBmdW5jdGlvbihhbmNob3IsIGRpcmVjdGlvbikge1xuICAgIC8vIE5lZWQgdG8gZG8gdGhpcyBzbyB0aGF0IGxpbmUncyBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgICAvLyByZWZlcmVuY2VzIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gICAgYW5jaG9yID0gVmVjdG9yLmNyZWF0ZShhbmNob3IpO1xuICAgIGRpcmVjdGlvbiA9IFZlY3Rvci5jcmVhdGUoZGlyZWN0aW9uKTtcbiAgICBpZiAoYW5jaG9yLmVsZW1lbnRzLmxlbmd0aCA9PSAyKSB7YW5jaG9yLmVsZW1lbnRzLnB1c2goMCk7IH1cbiAgICBpZiAoZGlyZWN0aW9uLmVsZW1lbnRzLmxlbmd0aCA9PSAyKSB7IGRpcmVjdGlvbi5lbGVtZW50cy5wdXNoKDApOyB9XG4gICAgaWYgKGFuY2hvci5lbGVtZW50cy5sZW5ndGggPiAzIHx8IGRpcmVjdGlvbi5lbGVtZW50cy5sZW5ndGggPiAzKSB7IHJldHVybiBudWxsOyB9XG4gICAgdmFyIG1vZCA9IGRpcmVjdGlvbi5tb2R1bHVzKCk7XG4gICAgaWYgKG1vZCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gVmVjdG9yLmNyZWF0ZShbXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMF0gLyBtb2QsXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMV0gLyBtb2QsXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMl0gLyBtb2RcbiAgICBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbkxpbmUuY3JlYXRlID0gZnVuY3Rpb24oYW5jaG9yLCBkaXJlY3Rpb24pIHtcbiAgdmFyIEwgPSBuZXcgTGluZSgpO1xuICByZXR1cm4gTC5zZXRWZWN0b3JzKGFuY2hvciwgZGlyZWN0aW9uKTtcbn07XG5cbi8vIEF4ZXNcbkxpbmUuWCA9IExpbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3IuaSk7XG5MaW5lLlkgPSBMaW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmopO1xuTGluZS5aID0gTGluZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5rKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBMaW5lLlNlZ21lbnQgY2xhc3MgLSBkZXBlbmRzIG9uIExpbmUgYW5kIGl0cyBkZXBlbmRlbmNpZXMuXG5cbnZhciBMaW5lID0gcmVxdWlyZSgnLi9saW5lJyk7XG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcblxuTGluZS5TZWdtZW50ID0gZnVuY3Rpb24oKSB7fTtcbkxpbmUuU2VnbWVudC5wcm90b3R5cGUgPSB7XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbGluZSBzZWdtZW50IGlzIGVxdWFsIHRvIHRoZSBhcmd1bWVudFxuICBlcWw6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gKHRoaXMuc3RhcnQuZXFsKHNlZ21lbnQuc3RhcnQpICYmIHRoaXMuZW5kLmVxbChzZWdtZW50LmVuZCkpIHx8XG4gICAgICAgICh0aGlzLnN0YXJ0LmVxbChzZWdtZW50LmVuZCkgJiYgdGhpcy5lbmQuZXFsKHNlZ21lbnQuc3RhcnQpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGluZSBzZWdtZW50XG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIExpbmUuU2VnbWVudC5jcmVhdGUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50XG4gIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEEgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzLCBCID0gdGhpcy5lbmQuZWxlbWVudHM7XG4gICAgdmFyIEMxID0gQlswXSAtIEFbMF0sIEMyID0gQlsxXSAtIEFbMV0sIEMzID0gQlsyXSAtIEFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydChDMSpDMSArIEMyKkMyICsgQzMqQzMpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGxpbmUgc2VnbWVudCBhcyBhIHZlY3RvciBlcXVhbCB0byBpdHNcbiAgLy8gZW5kIHBvaW50IHJlbGF0aXZlIHRvIGl0cyBlbmRwb2ludFxuICB0b1ZlY3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEEgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzLCBCID0gdGhpcy5lbmQuZWxlbWVudHM7XG4gICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUoW0JbMF0gLSBBWzBdLCBCWzFdIC0gQVsxXSwgQlsyXSAtIEFbMl1dKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBzZWdtZW50J3MgbWlkcG9pbnQgYXMgYSB2ZWN0b3JcbiAgbWlkcG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBBID0gdGhpcy5zdGFydC5lbGVtZW50cywgQiA9IHRoaXMuZW5kLmVsZW1lbnRzO1xuICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFsoQlswXSArIEFbMF0pLzIsIChCWzFdICsgQVsxXSkvMiwgKEJbMl0gKyBBWzJdKS8yXSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcGxhbmUgdGhhdCBiaXNlY3RzIHRoZSBzZWdtZW50XG4gIGJpc2VjdGluZ1BsYW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKHRoaXMubWlkcG9pbnQoKSwgdGhpcy50b1ZlY3RvcigpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdHJhbnNsYXRpbmcgdGhlIGxpbmUgYnkgdGhlIGdpdmVuIHZlY3Rvci9hcnJheVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICB2YXIgUyA9IHRoaXMuc3RhcnQuZWxlbWVudHMsIEUgPSB0aGlzLmVuZC5lbGVtZW50cztcbiAgICByZXR1cm4gTGluZS5TZWdtZW50LmNyZWF0ZShcbiAgICAgIFtTWzBdICsgVlswXSwgU1sxXSArIFZbMV0sIFNbMl0gKyAoVlsyXSB8fCAwKV0sXG4gICAgICBbRVswXSArIFZbMF0sIEVbMV0gKyBWWzFdLCBFWzJdICsgKFZbMl0gfHwgMCldXG4gICAgKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIHNlZ21lbnQgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50LiBJdCBzaW1wbHkgZm9yd2FyZHNcbiAgLy8gdGhlIG1ldGhvZCBjYWxsIG9udG8gaXRzIGxpbmUgcHJvcGVydHkuXG4gIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZS5pc1BhcmFsbGVsVG8ob2JqKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBhcmd1bWVudCBhbmQgdGhlIGxpbmUgc2VnbWVudCdzIGNsb3Nlc3QgcG9pbnQgdG8gdGhlIGFyZ3VtZW50XG4gIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIFAgPSB0aGlzLnBvaW50Q2xvc2VzdFRvKG9iaik7XG4gICAgcmV0dXJuIChQID09PSBudWxsKSA/IG51bGwgOiBQLmRpc3RhbmNlRnJvbShvYmopO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGdpdmVuIHBvaW50IGxpZXMgb24gdGhlIHNlZ21lbnRcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouc3RhcnQgJiYgb2JqLmVuZCkgeyByZXR1cm4gdGhpcy5jb250YWlucyhvYmouc3RhcnQpICYmIHRoaXMuY29udGFpbnMob2JqLmVuZCk7IH1cbiAgICB2YXIgUCA9IChvYmouZWxlbWVudHMgfHwgb2JqKS5zbGljZSgpO1xuICAgIGlmIChQLmxlbmd0aCA9PSAyKSB7IFAucHVzaCgwKTsgfVxuICAgIGlmICh0aGlzLnN0YXJ0LmVxbChQKSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHZhciBTID0gdGhpcy5zdGFydC5lbGVtZW50cztcbiAgICB2YXIgViA9IFZlY3Rvci5jcmVhdGUoW1NbMF0gLSBQWzBdLCBTWzFdIC0gUFsxXSwgU1syXSAtIChQWzJdIHx8IDApXSk7XG4gICAgdmFyIHZlY3QgPSB0aGlzLnRvVmVjdG9yKCk7XG4gICAgcmV0dXJuIFYuaXNBbnRpcGFyYWxsZWxUbyh2ZWN0KSAmJiBWLm1vZHVsdXMoKSA8PSB2ZWN0Lm1vZHVsdXMoKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgYXJndW1lbnRcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICh0aGlzLmludGVyc2VjdGlvbldpdGgob2JqKSAhPT0gbnVsbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIHBvaW50IG9mIGludGVyc2VjdGlvbiB3aXRoIHRoZSBhcmd1bWVudFxuICBpbnRlcnNlY3Rpb25XaXRoOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMubGluZS5pbnRlcnNlY3RzKG9iaikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgUCA9IHRoaXMubGluZS5pbnRlcnNlY3Rpb25XaXRoKG9iaik7XG4gICAgcmV0dXJuICh0aGlzLmNvbnRhaW5zKFApID8gUCA6IG51bGwpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnQgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gb2JqZWN0XG4gIHBvaW50Q2xvc2VzdFRvOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHZhciBWID0gdGhpcy5saW5lLmludGVyc2VjdGlvbldpdGgob2JqKTtcbiAgICAgIGlmIChWID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICByZXR1cm4gdGhpcy5wb2ludENsb3Nlc3RUbyhWKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZSAoc2VnbWVudCkgb3IgcG9pbnRcbiAgICAgIHZhciBQID0gdGhpcy5saW5lLnBvaW50Q2xvc2VzdFRvKG9iaik7XG4gICAgICBpZiAoUCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgaWYgKHRoaXMuY29udGFpbnMoUCkpIHsgcmV0dXJuIFA7IH1cbiAgICAgIHJldHVybiAodGhpcy5saW5lLnBvc2l0aW9uT2YoUCkgPCAwID8gdGhpcy5zdGFydCA6IHRoaXMuZW5kKS5kdXAoKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2V0IHRoZSBzdGFydCBhbmQgZW5kLXBvaW50cyBvZiB0aGUgc2VnbWVudFxuICBzZXRQb2ludHM6IGZ1bmN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgc3RhcnRQb2ludCA9IFZlY3Rvci5jcmVhdGUoc3RhcnRQb2ludCkudG8zRCgpO1xuICAgIGVuZFBvaW50ID0gVmVjdG9yLmNyZWF0ZShlbmRQb2ludCkudG8zRCgpO1xuICAgIGlmIChzdGFydFBvaW50ID09PSBudWxsIHx8IGVuZFBvaW50ID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgdGhpcy5saW5lID0gTGluZS5jcmVhdGUoc3RhcnRQb2ludCwgZW5kUG9pbnQuc3VidHJhY3Qoc3RhcnRQb2ludCkpO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydFBvaW50O1xuICAgIHRoaXMuZW5kID0gZW5kUG9pbnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5MaW5lLlNlZ21lbnQuY3JlYXRlID0gZnVuY3Rpb24odjEsIHYyKSB7XG4gIHZhciBTID0gbmV3IExpbmUuU2VnbWVudCgpO1xuICByZXR1cm4gUy5zZXRQb2ludHModjEsIHYyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZS5TZWdtZW50O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBNYXRyaXggY2xhc3MgLSBkZXBlbmRzIG9uIFZlY3Rvci5cblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcblxuLy8gYXVnbWVudCBhIG1hdHJpeCBNIHdpdGggaWRlbnRpdHkgcm93cy9jb2xzXG5mdW5jdGlvbiBpZGVudFNpemUoTSwgbSwgbiwgaykge1xuICAgIHZhciBlID0gTS5lbGVtZW50cztcbiAgICB2YXIgaSA9IGsgLSAxO1xuXG4gICAgd2hpbGUoaS0tKSB7XG5cdHZhciByb3cgPSBbXTtcblx0XG5cdGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKyspXG5cdCAgICByb3cucHVzaChqID09IGkgPyAxIDogMCk7XG5cdFxuICAgICAgICBlLnVuc2hpZnQocm93KTtcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBpID0gayAtIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgd2hpbGUoZVtpXS5sZW5ndGggPCBuKVxuICAgICAgICAgICAgZVtpXS51bnNoaWZ0KDApO1xuICAgIH1cblxuICAgIHJldHVybiAkTShlKTtcbn1cblxuZnVuY3Rpb24gcGNhKFgpIHtcbiAgICB2YXIgU2lnbWEgPSBYLnRyYW5zcG9zZSgpLngoWCkueCgxIC8gWC5yb3dzKCkpO1xuICAgIHZhciBzdmQgPSBTaWdtYS5zdmQoKTtcbiAgICByZXR1cm4ge1U6IHN2ZC5VLCBTOiBzdmQuU307XG59XG5cbi8vIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gaW4gcHVyZSBqYXZhc2NyaXB0XG5mdW5jdGlvbiBzdmRKcygpIHtcbiAgICB2YXIgQSA9IHRoaXM7XG4gICAgdmFyIFYgPSBNYXRyaXguSShBLnJvd3MoKSk7XG4gICAgdmFyIFMgPSBBLnRyYW5zcG9zZSgpO1xuICAgIHZhciBVID0gTWF0cml4LkkoQS5jb2xzKCkpO1xuICAgIHZhciBlcnIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbWF4TG9vcCA9IDEwMDtcblxuICAgIHdoaWxlKGVyciA+IDIuMjczN2UtMTMgJiYgaSA8IG1heExvb3ApIHtcbiAgICAgICAgdmFyIHFyID0gUy50cmFuc3Bvc2UoKS5xckpzKCk7XG4gICAgICAgIFMgPSBxci5SO1xuICAgICAgICBWID0gVi54KHFyLlEpO1xuICAgICAgICBxciA9IFMudHJhbnNwb3NlKCkucXJKcygpO1xuICAgICAgICBVID0gVS54KHFyLlEpO1xuICAgICAgICBTID0gcXIuUjtcblxuICAgICAgICB2YXIgZSA9IFMudHJpdSgxKS51bnJvbGwoKS5ub3JtKCk7XG4gICAgICAgIHZhciBmID0gUy5kaWFnb25hbCgpLm5vcm0oKTtcblxuICAgICAgICBpZihmID09IDApXG4gICAgICAgICAgICBmID0gMTtcblxuICAgICAgICBlcnIgPSBlIC8gZjtcblxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgdmFyIHNzID0gUy5kaWFnb25hbCgpO1xuICAgIHZhciBzID0gW107XG5cbiAgICBmb3IodmFyIGkgPSAxOyBpIDw9IHNzLmNvbHMoKTsgaSsrKSB7XG4gICAgICAgIHZhciBzc24gPSBzcy5lKGkpO1xuICAgICAgICBzLnB1c2goTWF0aC5hYnMoc3NuKSk7XG5cbiAgICAgICAgaWYoc3NuIDwgMCkge1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IFUucm93cygpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBWLmVsZW1lbnRzW2pdW2kgLSAxXSA9IC0oVi5lbGVtZW50c1tqXVtpIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtVOiBVLCBTOiAkVihzKS50b0RpYWdvbmFsTWF0cml4KCksIFY6IFZ9O1xufVxuXG5cblxuLy8gUVIgZGVjb21wb3NpdGlvbiBpbiBwdXJlIGphdmFzY3JpcHRcbmZ1bmN0aW9uIHFySnMoKSB7XG4gICAgdmFyIG0gPSB0aGlzLnJvd3MoKTtcbiAgICB2YXIgbiA9IHRoaXMuY29scygpO1xuICAgIHZhciBRID0gTWF0cml4LkkobSk7XG4gICAgdmFyIEEgPSB0aGlzO1xuICAgIFxuICAgIGZvcih2YXIgayA9IDE7IGsgPCBNYXRoLm1pbihtLCBuKTsgaysrKSB7XG5cdHZhciBhayA9IEEuc2xpY2UoaywgMCwgaywgaykuY29sKDEpO1xuXHR2YXIgb25lWmVybyA9IFsxXTtcblx0XG5cdHdoaWxlKG9uZVplcm8ubGVuZ3RoIDw9ICBtIC0gaylcblx0ICAgIG9uZVplcm8ucHVzaCgwKTtcblx0XG5cdG9uZVplcm8gPSAkVihvbmVaZXJvKTtcblx0dmFyIHZrID0gYWsuYWRkKG9uZVplcm8ueChhay5ub3JtKCkgKiBNYXRoLnNpZ24oYWsuZSgxKSkpKTtcblx0dmFyIFZrID0gJE0odmspO1xuXHR2YXIgSGsgPSBNYXRyaXguSShtIC0gayArIDEpLnN1YnRyYWN0KFZrLngoMikueChWay50cmFuc3Bvc2UoKSkuZGl2KFZrLnRyYW5zcG9zZSgpLngoVmspLmUoMSwgMSkpKTtcblx0dmFyIFFrID0gaWRlbnRTaXplKEhrLCBtLCBuLCBrKTtcblx0QSA9IFFrLngoQSk7XG5cdC8vIHNsb3cgd2F5IHRvIGNvbXB1dGUgUVxuXHRRID0gUS54KFFrKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtROiBRLCBSOiBBfTtcbn1cblxuXG5cblxuZnVuY3Rpb24gTWF0cml4KCkge31cbk1hdHJpeC5wcm90b3R5cGUgPSB7XG4gICAgLy8gc29sdmUgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyAod29yayBpbiBwcm9ncmVzcylcbiAgICBzb2x2ZTogZnVuY3Rpb24oYikge1xuXHR2YXIgbHUgPSB0aGlzLmx1KCk7XG5cdGIgPSBsdS5QLngoYik7XG5cdHZhciB5ID0gbHUuTC5mb3J3YXJkU3Vic3RpdHV0ZShiKTtcblx0dmFyIHggPSBsdS5VLmJhY2tTdWJzdGl0dXRlKHkpO1xuXHRyZXR1cm4gbHUuUC54KHgpO1xuXHQvL3JldHVybiB0aGlzLmludigpLngoYik7XG4gICAgfSxcblxuICAgIC8vIHByb2plY3QgYSBtYXRyaXggb250byBhIGxvd2VyIGRpbVxuICAgIHBjYVByb2plY3Q6IGZ1bmN0aW9uKGssIFUpIHtcblx0dmFyIFUgPSBVIHx8IHBjYSh0aGlzKS5VO1xuXHR2YXIgVXJlZHVjZT0gVS5zbGljZSgxLCBVLnJvd3MoKSwgMSwgayk7XG5cdHJldHVybiB7WjogdGhpcy54KFVyZWR1Y2UpLCBVOiBVfTtcbiAgICB9LFxuXG4gICAgLy8gcmVjb3ZlciBhIG1hdHJpeCB0byBhIGhpZ2hlciBkaW1lbnNpb25cbiAgICBwY2FSZWNvdmVyOiBmdW5jdGlvbihVKSB7XG5cdHZhciBrID0gdGhpcy5jb2xzKCk7XG5cdHZhciBVcmVkdWNlID0gVS5zbGljZSgxLCBVLnJvd3MoKSwgMSwgayk7XG5cdHJldHVybiB0aGlzLngoVXJlZHVjZS50cmFuc3Bvc2UoKSk7XG4gICAgfSwgICAgXG5cbiAgICAvLyBncmFiIHRoZSB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgdGhlIG1hdHJpeFxuICAgIHRyaXU6IGZ1bmN0aW9uKGspIHtcblx0aWYoIWspXG5cdCAgICBrID0gMDtcblx0XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpLCBqKSB7XG5cdCAgICByZXR1cm4gaiAtIGkgPj0gayA/IHggOiAwO1xuXHR9KTtcbiAgICB9LFxuXG4gICAgLy8gdW5yb2xsIGEgbWF0cml4IGludG8gYSB2ZWN0b3JcbiAgICB1bnJvbGw6IGZ1bmN0aW9uKCkge1xuXHR2YXIgdiA9IFtdO1xuXHRcblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLmNvbHMoKTsgaSsrKSB7XG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMucm93cygpOyBqKyspIHtcblx0XHR2LnB1c2godGhpcy5lKGosIGkpKTtcblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiAkVih2KTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIGEgc3ViLWJsb2NrIG9mIHRoZSBtYXRyaXhcbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2wsIGVuZENvbCkge1xuXHR2YXIgeCA9IFtdO1xuXHRcblx0aWYoZW5kUm93ID09IDApXG5cdCAgICBlbmRSb3cgPSB0aGlzLnJvd3MoKTtcblx0XG5cdGlmKGVuZENvbCA9PSAwKVxuXHQgICAgZW5kQ29sID0gdGhpcy5jb2xzKCk7XG5cblx0Zm9yKGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKykge1xuXHQgICAgdmFyIHJvdyA9IFtdO1xuXG5cdCAgICBmb3IoaiA9IHN0YXJ0Q29sOyBqIDw9IGVuZENvbDsgaisrKSB7XG5cdFx0cm93LnB1c2godGhpcy5lKGksIGopKTtcblx0ICAgIH1cblxuXHQgICAgeC5wdXNoKHJvdyk7XG5cdH1cblxuXHRyZXR1cm4gJE0oeCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZWxlbWVudCAoaSxqKSBvZiB0aGUgbWF0cml4XG4gICAgZTogZnVuY3Rpb24oaSxqKSB7XG5cdGlmIChpIDwgMSB8fCBpID4gdGhpcy5lbGVtZW50cy5sZW5ndGggfHwgaiA8IDEgfHwgaiA+IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiB0aGlzLmVsZW1lbnRzW2kgLSAxXVtqIC0gMV07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcm93IGsgb2YgdGhlIG1hdHJpeCBhcyBhIHZlY3RvclxuICAgIHJvdzogZnVuY3Rpb24oaSkge1xuXHRpZiAoaSA+IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiAkVih0aGlzLmVsZW1lbnRzW2kgLSAxXSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgY29sdW1uIGsgb2YgdGhlIG1hdHJpeCBhcyBhIHZlY3RvclxuICAgIGNvbDogZnVuY3Rpb24oaikge1xuXHRpZiAoaiA+IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBjb2wgPSBbXSwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBjb2wucHVzaCh0aGlzLmVsZW1lbnRzW2ldW2ogLSAxXSk7IH1cblx0cmV0dXJuICRWKGNvbCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzL2NvbHVtbnMgdGhlIG1hdHJpeCBoYXNcbiAgICBkaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtyb3dzOiB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgY29sczogdGhpcy5lbGVtZW50c1swXS5sZW5ndGh9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XG4gICAgcm93czogZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeFxuICAgIGNvbHM6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGFwcHJveEVxbDogZnVuY3Rpb24obWF0cml4KSB7XG5cdHJldHVybiB0aGlzLmVxbChtYXRyaXgsIFN5bHZlc3Rlci5hcHByb3hQcmVjaXNpb24pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBtYXRyaXggaXMgZXF1YWwgdG8gdGhlIGFyZ3VtZW50LiBZb3UgY2FuIHN1cHBseVxuICAgIC8vIGEgdmVjdG9yIGFzIHRoZSBhcmd1bWVudCwgaW4gd2hpY2ggY2FzZSB0aGUgcmVjZWl2ZXIgbXVzdCBiZSBhXG4gICAgLy8gb25lLWNvbHVtbiBtYXRyaXggZXF1YWwgdG8gdGhlIHZlY3Rvci5cbiAgICBlcWw6IGZ1bmN0aW9uKG1hdHJpeCwgcHJlY2lzaW9uKSB7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHRpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gTS5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoICE9IE1bMF0ubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBuaiA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHR3aGlsZSAoaS0tKSB7IGogPSBuajtcblx0XHQgICAgICB3aGlsZSAoai0tKSB7XG5cdFx0XHQgIGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW2ldW2pdIC0gTVtpXVtqXSkgPiAocHJlY2lzaW9uIHx8IFN5bHZlc3Rlci5wcmVjaXNpb24pKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRyZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeFxuICAgIGR1cDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKHRoaXMuZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBNYXBzIHRoZSBtYXRyaXggdG8gYW5vdGhlciBtYXRyaXggKG9mIHRoZSBzYW1lIGRpbWVuc2lvbnMpIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICBtYXA6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGVscyA9IFtdLCBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHdoaWxlIChpLS0pIHsgaiA9IG5qO1xuXHRcdCAgICAgIGVsc1tpXSA9IFtdO1xuXHRcdCAgICAgIHdoaWxlIChqLS0pIHtcblx0XHRcdCAgZWxzW2ldW2pdID0gZm4odGhpcy5lbGVtZW50c1tpXVtqXSwgaSArIDEsIGogKyAxKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgYXJndW1lbnQgaGFzIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIG1hdHJpeFxuICAgIGlzU2FtZVNpemVBczogZnVuY3Rpb24obWF0cml4KSB7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHRyZXR1cm4gKHRoaXMuZWxlbWVudHMubGVuZ3RoID09IE0ubGVuZ3RoICYmXG5cdFx0dGhpcy5lbGVtZW50c1swXS5sZW5ndGggPT0gTVswXS5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaW5nIHRoZSBhcmd1bWVudCB0byB0aGUgbWF0cml4XG4gICAgYWRkOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0aWYodHlwZW9mKG1hdHJpeCkgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpLCBqKSB7IHJldHVybiB4ICsgbWF0cml4fSk7XG5cdH0gZWxzZSB7XG5cdCAgICB2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdCAgICBpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdCAgICBpZiAoIXRoaXMuaXNTYW1lU2l6ZUFzKE0pKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikgeyByZXR1cm4geCArIE1baSAtIDFdW2ogLSAxXTsgfSk7XG5cdH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIHRoZSBhcmd1bWVudCBmcm9tIHRoZSBtYXRyaXhcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24obWF0cml4KSB7XG5cdGlmKHR5cGVvZihtYXRyaXgpID09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikgeyByZXR1cm4geCAtIG1hdHJpeH0pO1xuXHR9IGVsc2Uge1xuXHQgICAgdmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHQgICAgaWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHQgICAgaWYgKCF0aGlzLmlzU2FtZVNpemVBcyhNKSkgeyByZXR1cm4gbnVsbDsgfVxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGksIGopIHsgcmV0dXJuIHggLSBNW2kgLSAxXVtqIC0gMV07IH0pO1xuXHR9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1hdHJpeCBjYW4gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGZyb20gdGhlIGxlZnRcbiAgICBjYW5NdWx0aXBseUZyb21MZWZ0OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0dmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHRpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdC8vIHRoaXMuY29sdW1ucyBzaG91bGQgZXF1YWwgbWF0cml4LnJvd3Ncblx0cmV0dXJuICh0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCA9PSBNLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIG11bHRpcGxpY2F0aW9uLXN0eWxlIG9wZXJhdGlvbiB0aGUgbWF0cml4IGZyb20gdGhlIHJpZ2h0IGJ5IHRoZSBhcmd1bWVudC5cbiAgICAvLyBJZiB0aGUgYXJndW1lbnQgaXMgYSBzY2FsYXIgdGhlbiBqdXN0IG9wZXJhdGUgb24gYWxsIHRoZSBlbGVtZW50cy4gSWYgdGhlIGFyZ3VtZW50IGlzXG4gICAgLy8gYSB2ZWN0b3IsIGEgdmVjdG9yIGlzIHJldHVybmVkLCB3aGljaCBzYXZlcyB5b3UgaGF2aW5nIHRvIHJlbWVtYmVyIGNhbGxpbmdcbiAgICAvLyBjb2woMSkgb24gdGhlIHJlc3VsdC5cbiAgICBtdWxPcDogZnVuY3Rpb24obWF0cml4LCBvcCkge1xuXHRpZiAoIW1hdHJpeC5lbGVtZW50cykge1xuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIG9wKHgsIG1hdHJpeCk7IH0pO1xuXHR9XG5cblx0dmFyIHJldHVyblZlY3RvciA9IG1hdHJpeC5tb2R1bHVzID8gdHJ1ZSA6IGZhbHNlO1xuXHR2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdGlmICh0eXBlb2YoTVswXVswXSkgPT0gJ3VuZGVmaW5lZCcpIFxuXHQgICAgTSA9IE1hdHJpeC5jcmVhdGUoTSkuZWxlbWVudHM7XG5cdGlmICghdGhpcy5jYW5NdWx0aXBseUZyb21MZWZ0KE0pKSBcblx0ICAgIHJldHVybiBudWxsOyBcblx0dmFyIGUgPSB0aGlzLmVsZW1lbnRzLCByb3dUaGlzLCByb3dFbGVtLCBlbGVtZW50cyA9IFtdLFxuICAgICAgICBzdW0sIG0gPSBlLmxlbmd0aCwgbiA9IE1bMF0ubGVuZ3RoLCBvID0gZVswXS5sZW5ndGgsIGkgPSBtLCBqLCBrO1xuXG5cdHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJvd0VsZW0gPSBbXTtcbiAgICAgICAgICAgIHJvd1RoaXMgPSBlW2ldO1xuICAgICAgICAgICAgaiA9IG47XG5cbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcblx0XHRzdW0gPSAwO1xuXHRcdGsgPSBvO1xuXG5cdFx0d2hpbGUgKGstLSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gb3Aocm93VGhpc1trXSwgTVtrXVtqXSk7XG5cdFx0fVxuXG5cdFx0cm93RWxlbVtqXSA9IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHNbaV0gPSByb3dFbGVtO1xuXHR9XG5cblx0dmFyIE0gPSBNYXRyaXguY3JlYXRlKGVsZW1lbnRzKTtcblx0cmV0dXJuIHJldHVyblZlY3RvciA/IE0uY29sKDEpIDogTTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlkaW5nIHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQgYnkgdGhlIGFyZ3VtZW50LlxuICAgIC8vIElmIHRoZSBhcmd1bWVudCBpcyBhIHNjYWxhciB0aGVuIGp1c3QgZGl2aWRlIGFsbCB0aGUgZWxlbWVudHMuIElmIHRoZSBhcmd1bWVudCBpc1xuICAgIC8vIGEgdmVjdG9yLCBhIHZlY3RvciBpcyByZXR1cm5lZCwgd2hpY2ggc2F2ZXMgeW91IGhhdmluZyB0byByZW1lbWJlciBjYWxsaW5nXG4gICAgLy8gY29sKDEpIG9uIHRoZSByZXN1bHQuXG4gICAgZGl2OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0cmV0dXJuIHRoaXMubXVsT3AobWF0cml4LCBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4IC8geX0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbHlpbmcgdGhlIG1hdHJpeCBmcm9tIHRoZSByaWdodCBieSB0aGUgYXJndW1lbnQuXG4gICAgLy8gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc2NhbGFyIHRoZW4ganVzdCBtdWx0aXBseSBhbGwgdGhlIGVsZW1lbnRzLiBJZiB0aGUgYXJndW1lbnQgaXNcbiAgICAvLyBhIHZlY3RvciwgYSB2ZWN0b3IgaXMgcmV0dXJuZWQsIHdoaWNoIHNhdmVzIHlvdSBoYXZpbmcgdG8gcmVtZW1iZXIgY2FsbGluZ1xuICAgIC8vIGNvbCgxKSBvbiB0aGUgcmVzdWx0LlxuICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0cmV0dXJuIHRoaXMubXVsT3AobWF0cml4LCBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4ICogeX0pO1xuICAgIH0sXG5cbiAgICB4OiBmdW5jdGlvbihtYXRyaXgpIHsgcmV0dXJuIHRoaXMubXVsdGlwbHkobWF0cml4KTsgfSxcblxuICAgIGVsZW1lbnRNdWx0aXBseTogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaywgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIHYuZShpLCBqKSAqIGs7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBzdW0gYWxsIGVsZW1lbnRzIGluIHRoZSBtYXRyaXhcbiAgICBzdW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHN1bSArPSB4O30pO1xuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBWZWN0b3Igb2YgZWFjaCBjb2x1bSBhdmVyYWdlZC5cbiAgICBtZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmRpbWVuc2lvbnMoKTtcbiAgICAgIHZhciByID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkaW0uY29sczsgaSsrKSB7XG4gICAgICAgIHIucHVzaCh0aGlzLmNvbChpKS5zdW0oKSAvIGRpbS5yb3dzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkVihyKTtcbiAgICB9LFxuXG4gICAgY29sdW1uOiBmdW5jdGlvbihuKSB7XG5cdHJldHVybiB0aGlzLmNvbChuKTtcbiAgICB9LFxuXG4gICAgLy8gZWxlbWVudC13aXNlIGxvZ1xuICAgIGxvZzogZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBzdWJtYXRyaXggdGFrZW4gZnJvbSB0aGUgbWF0cml4XG4gICAgLy8gQXJndW1lbnQgb3JkZXIgaXM6IHN0YXJ0IHJvdywgc3RhcnQgY29sLCBucm93cywgbmNvbHNcbiAgICAvLyBFbGVtZW50IHNlbGVjdGlvbiB3cmFwcyBpZiB0aGUgcmVxdWlyZWQgaW5kZXggaXMgb3V0c2lkZSB0aGUgbWF0cml4J3MgYm91bmRzLCBzbyB5b3UgY291bGRcbiAgICAvLyB1c2UgdGhpcyB0byBwZXJmb3JtIHJvdy9jb2x1bW4gY3ljbGluZyBvciBjb3B5LWF1Z21lbnRpbmcuXG4gICAgbWlub3I6IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0dmFyIGVsZW1lbnRzID0gW10sIG5pID0gYywgaSwgbmosIGo7XG5cdHZhciByb3dzID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGNvbHMgPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aDtcblx0d2hpbGUgKG5pLS0pIHtcblx0ICAgIGkgPSBjIC0gbmkgLSAxO1xuXHQgICAgZWxlbWVudHNbaV0gPSBbXTtcblx0ICAgIG5qID0gZDtcblx0ICAgIHdoaWxlIChuai0tKSB7XG5cdFx0aiA9IGQgLSBuaiAtIDE7XG5cdFx0ZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzWyhhICsgaSAtIDEpICUgcm93c11bKGIgKyBqIC0gMSkgJSBjb2xzXTtcblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHRyYW5zcG9zZSBvZiB0aGUgbWF0cml4XG4gICAgdHJhbnNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm93cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBpLCBjb2xzID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHZhciBlbGVtZW50cyA9IFtdLCBpID0gY29scztcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaiA9IHJvd3M7XG5cdCAgICBlbGVtZW50c1tpXSA9IFtdO1xuXHQgICAgd2hpbGUgKGotLSkge1xuXHRcdGVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tqXVtpXTtcblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1hdHJpeCBpcyBzcXVhcmVcbiAgICBpc1NxdWFyZTogZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5lbGVtZW50cy5sZW5ndGggPT0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSAoYWJzb2x1dGUpIGxhcmdlc3QgZWxlbWVudCBvZiB0aGUgbWF0cml4XG4gICAgbWF4OiBmdW5jdGlvbigpIHtcblx0dmFyIG0gPSAwLCBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHdoaWxlIChpLS0pIHtcblx0ICAgIGogPSBuajtcblx0ICAgIHdoaWxlIChqLS0pIHtcblx0XHRpZiAoTWF0aC5hYnModGhpcy5lbGVtZW50c1tpXVtqXSkgPiBNYXRoLmFicyhtKSkgeyBtID0gdGhpcy5lbGVtZW50c1tpXVtqXTsgfVxuXHQgICAgfVxuXHR9XG5cdHJldHVybiBtO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRlY2VzIG9mIHRoZSBmaXJzdCBtYXRjaCBmb3VuZCBieSByZWFkaW5nIHJvdy1ieS1yb3cgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgaW5kZXhPZjogZnVuY3Rpb24oeCkge1xuXHR2YXIgaW5kZXggPSBudWxsLCBuaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBpLCBuaiA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHRmb3IgKGkgPSAwOyBpIDwgbmk7IGkrKykge1xuXHQgICAgZm9yIChqID0gMDsgaiA8IG5qOyBqKyspIHtcblx0XHRpZiAodGhpcy5lbGVtZW50c1tpXVtqXSA9PSB4KSB7IHJldHVybiB7aTogaSArIDEsIGo6IGogKyAxfTsgfVxuXHQgICAgfVxuXHR9XG5cdHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBJZiB0aGUgbWF0cml4IGlzIHNxdWFyZSwgcmV0dXJucyB0aGUgZGlhZ29uYWwgZWxlbWVudHMgYXMgYSB2ZWN0b3IuXG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gICAgZGlhZ29uYWw6IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNTcXVhcmUpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIGVscyA9IFtdLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBlbHMucHVzaCh0aGlzLmVsZW1lbnRzW2ldW2ldKTtcblx0fVxuXHRyZXR1cm4gJFYoZWxzKTtcbiAgICB9LFxuXG4gICAgLy8gTWFrZSB0aGUgbWF0cml4IHVwcGVyIChyaWdodCkgdHJpYW5ndWxhciBieSBHYXVzc2lhbiBlbGltaW5hdGlvbi5cbiAgICAvLyBUaGlzIG1ldGhvZCBvbmx5IGFkZHMgbXVsdGlwbGVzIG9mIHJvd3MgdG8gb3RoZXIgcm93cy4gTm8gcm93cyBhcmVcbiAgICAvLyBzY2FsZWQgdXAgb3Igc3dpdGNoZWQsIGFuZCB0aGUgZGV0ZXJtaW5hbnQgaXMgcHJlc2VydmVkLlxuICAgIHRvUmlnaHRUcmlhbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0dmFyIE0gPSB0aGlzLmR1cCgpLCBlbHM7XG5cdHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGksIGosIG5wID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIHA7XG5cdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmIChNLmVsZW1lbnRzW2ldW2ldID09IDApIHtcblx0XHRmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuXHRcdCAgICBpZiAoTS5lbGVtZW50c1tqXVtpXSAhPSAwKSB7XG5cdFx0XHRlbHMgPSBbXTtcblx0XHRcdGZvciAocCA9IDA7IHAgPCBucDsgcCsrKSB7IGVscy5wdXNoKE0uZWxlbWVudHNbaV1bcF0gKyBNLmVsZW1lbnRzW2pdW3BdKTsgfVxuXHRcdFx0TS5lbGVtZW50c1tpXSA9IGVscztcblx0XHRcdGJyZWFrO1xuXHRcdCAgICB9XG5cdFx0fVxuXHQgICAgfVxuXHQgICAgaWYgKE0uZWxlbWVudHNbaV1baV0gIT0gMCkge1xuXHRcdGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG5cdFx0ICAgIHZhciBtdWx0aXBsaWVyID0gTS5lbGVtZW50c1tqXVtpXSAvIE0uZWxlbWVudHNbaV1baV07XG5cdFx0ICAgIGVscyA9IFtdO1xuXHRcdCAgICBmb3IgKHAgPSAwOyBwIDwgbnA7IHArKykge1xuXHRcdFx0Ly8gRWxlbWVudHMgd2l0aCBjb2x1bW4gbnVtYmVycyB1cCB0byBhbiBpbmNsdWRpbmcgdGhlIG51bWJlclxuXHRcdFx0Ly8gb2YgdGhlIHJvdyB0aGF0IHdlJ3JlIHN1YnRyYWN0aW5nIGNhbiBzYWZlbHkgYmUgc2V0IHN0cmFpZ2h0IHRvXG5cdFx0XHQvLyB6ZXJvLCBzaW5jZSB0aGF0J3MgdGhlIHBvaW50IG9mIHRoaXMgcm91dGluZSBhbmQgaXQgYXZvaWRzIGhhdmluZ1xuXHRcdFx0Ly8gdG8gbG9vcCBvdmVyIGFuZCBjb3JyZWN0IHJvdW5kaW5nIGVycm9ycyBsYXRlclxuXHRcdFx0ZWxzLnB1c2gocCA8PSBpID8gMCA6IE0uZWxlbWVudHNbal1bcF0gLSBNLmVsZW1lbnRzW2ldW3BdICogbXVsdGlwbGllcik7XG5cdFx0ICAgIH1cblx0XHQgICAgTS5lbGVtZW50c1tqXSA9IGVscztcblx0XHR9XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIE07XG4gICAgfSxcblxuICAgIHRvVXBwZXJUcmlhbmd1bGFyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudG9SaWdodFRyaWFuZ3VsYXIoKTsgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGRldGVybWluYW50IGZvciBzcXVhcmUgbWF0cmljZXNcbiAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1NxdWFyZSgpKSB7IHJldHVybiBudWxsOyB9XG5cdGlmICh0aGlzLmNvbHMgPT0gMSAmJiB0aGlzLnJvd3MgPT0gMSkgeyByZXR1cm4gdGhpcy5yb3coMSk7IH1cblx0aWYgKHRoaXMuY29scyA9PSAwICYmIHRoaXMucm93cyA9PSAwKSB7IHJldHVybiAxOyB9XG5cdHZhciBNID0gdGhpcy50b1JpZ2h0VHJpYW5ndWxhcigpO1xuXHR2YXIgZGV0ID0gTS5lbGVtZW50c1swXVswXSwgbiA9IE0uZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHQgICAgZGV0ID0gZGV0ICogTS5lbGVtZW50c1tpXVtpXTtcblx0fVxuXHRyZXR1cm4gZGV0O1xuICAgIH0sXG4gICAgZGV0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGV0ZXJtaW5hbnQoKTsgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gKHRoaXMuaXNTcXVhcmUoKSAmJiB0aGlzLmRldGVybWluYW50KCkgPT09IDApO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB0cmFjZSBmb3Igc3F1YXJlIG1hdHJpY2VzXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNTcXVhcmUoKSkgeyByZXR1cm4gbnVsbDsgfVxuXHR2YXIgdHIgPSB0aGlzLmVsZW1lbnRzWzBdWzBdLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB0ciArPSB0aGlzLmVsZW1lbnRzW2ldW2ldO1xuXHR9XG5cdHJldHVybiB0cjtcbiAgICB9LFxuXG4gICAgdHI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFjZSgpOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmFuayBvZiB0aGUgbWF0cml4XG4gICAgcmFuazogZnVuY3Rpb24oKSB7XG5cdHZhciBNID0gdGhpcy50b1JpZ2h0VHJpYW5ndWxhcigpLCByYW5rID0gMDtcblx0dmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgbmogPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgajtcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaiA9IG5qO1xuXHQgICAgd2hpbGUgKGotLSkge1xuXHRcdGlmIChNYXRoLmFicyhNLmVsZW1lbnRzW2ldW2pdKSA+IFN5bHZlc3Rlci5wcmVjaXNpb24pIHsgcmFuaysrOyBicmVhazsgfVxuXHQgICAgfVxuXHR9XG5cdHJldHVybiByYW5rO1xuICAgIH0sXG5cbiAgICByazogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnJhbmsoKTsgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhdHRhY2hpbmcgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIG1hdHJpeFxuICAgIGF1Z21lbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHR2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdGlmICh0eXBlb2YoTVswXVswXSkgPT0gJ3VuZGVmaW5lZCcpIHsgTSA9IE1hdHJpeC5jcmVhdGUoTSkuZWxlbWVudHM7IH1cblx0dmFyIFQgPSB0aGlzLmR1cCgpLCBjb2xzID0gVC5lbGVtZW50c1swXS5sZW5ndGg7XG5cdHZhciBpID0gVC5lbGVtZW50cy5sZW5ndGgsIG5qID0gTVswXS5sZW5ndGgsIGo7XG5cdGlmIChpICE9IE0ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHdoaWxlIChpLS0pIHtcblx0ICAgIGogPSBuajtcblx0ICAgIHdoaWxlIChqLS0pIHtcblx0XHRULmVsZW1lbnRzW2ldW2NvbHMgKyBqXSA9IE1baV1bal07XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIFQ7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGludmVyc2UgKGlmIG9uZSBleGlzdHMpIHVzaW5nIEdhdXNzLUpvcmRhblxuICAgIGludmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNTcXVhcmUoKSB8fCB0aGlzLmlzU2luZ3VsYXIoKSkgeyByZXR1cm4gbnVsbDsgfVxuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBpID0gbiwgajtcblx0dmFyIE0gPSB0aGlzLmF1Z21lbnQoTWF0cml4LkkobikpLnRvUmlnaHRUcmlhbmd1bGFyKCk7XG5cdHZhciBucCA9IE0uZWxlbWVudHNbMF0ubGVuZ3RoLCBwLCBlbHMsIGRpdmlzb3I7XG5cdHZhciBpbnZlcnNlX2VsZW1lbnRzID0gW10sIG5ld19lbGVtZW50O1xuXHQvLyBNYXRyaXggaXMgbm9uLXNpbmd1bGFyIHNvIHRoZXJlIHdpbGwgYmUgbm8gemVyb3Mgb24gdGhlIGRpYWdvbmFsXG5cdC8vIEN5Y2xlIHRocm91Z2ggcm93cyBmcm9tIGxhc3QgdG8gZmlyc3Rcblx0d2hpbGUgKGktLSkge1xuXHQgICAgLy8gRmlyc3QsIG5vcm1hbGlzZSBkaWFnb25hbCBlbGVtZW50cyB0byAxXG5cdCAgICBlbHMgPSBbXTtcblx0ICAgIGludmVyc2VfZWxlbWVudHNbaV0gPSBbXTtcblx0ICAgIGRpdmlzb3IgPSBNLmVsZW1lbnRzW2ldW2ldO1xuXHQgICAgZm9yIChwID0gMDsgcCA8IG5wOyBwKyspIHtcbiAgICAgICAgbmV3X2VsZW1lbnQgPSBNLmVsZW1lbnRzW2ldW3BdIC8gZGl2aXNvcjtcblx0XHRlbHMucHVzaChuZXdfZWxlbWVudCk7XG5cdFx0Ly8gU2h1ZmZsZSBvZmYgdGhlIGN1cnJlbnQgcm93IG9mIHRoZSByaWdodCBoYW5kIHNpZGUgaW50byB0aGUgcmVzdWx0c1xuXHRcdC8vIGFycmF5IGFzIGl0IHdpbGwgbm90IGJlIG1vZGlmaWVkIGJ5IGxhdGVyIHJ1bnMgdGhyb3VnaCB0aGlzIGxvb3Bcblx0XHRpZiAocCA+PSBuKSB7IGludmVyc2VfZWxlbWVudHNbaV0ucHVzaChuZXdfZWxlbWVudCk7IH1cblx0ICAgIH1cblx0ICAgIE0uZWxlbWVudHNbaV0gPSBlbHM7XG5cdCAgICAvLyBUaGVuLCBzdWJ0cmFjdCB0aGlzIHJvdyBmcm9tIHRob3NlIGFib3ZlIGl0IHRvXG5cdCAgICAvLyBnaXZlIHRoZSBpZGVudGl0eSBtYXRyaXggb24gdGhlIGxlZnQgaGFuZCBzaWRlXG5cdCAgICBqID0gaTtcblx0ICAgIHdoaWxlIChqLS0pIHtcblx0XHRlbHMgPSBbXTtcblx0XHRmb3IgKHAgPSAwOyBwIDwgbnA7IHArKykge1xuXHRcdCAgICBlbHMucHVzaChNLmVsZW1lbnRzW2pdW3BdIC0gTS5lbGVtZW50c1tpXVtwXSAqIE0uZWxlbWVudHNbal1baV0pO1xuXHRcdH1cblx0XHRNLmVsZW1lbnRzW2pdID0gZWxzO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKGludmVyc2VfZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICBpbnY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbnZlcnNlKCk7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygcm91bmRpbmcgYWxsIHRoZSBlbGVtZW50c1xuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWF0cml4IHdpdGggZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZSBpZiB0aGV5XG4gICAgLy8gZGlmZmVyIGZyb20gaXQgYnkgbGVzcyB0aGFuIFN5bHZlc3Rlci5wcmVjaXNpb25cbiAgICBzbmFwVG86IGZ1bmN0aW9uKHgpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHApIHtcblx0ICAgIHJldHVybiAoTWF0aC5hYnMocCAtIHgpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pID8geCA6IHA7XG5cdH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHtcblx0dmFyIG1hdHJpeF9yb3dzID0gW107XG5cdHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBtYXRyaXhfcm93cy5wdXNoKCRWKHRoaXMuZWxlbWVudHNbaV0pLmluc3BlY3QoKSk7XG5cdH1cblx0cmV0dXJuIG1hdHJpeF9yb3dzLmpvaW4oJ1xcbicpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgIFx0dmFyIG1hdHJpeF9yb3dzID0gW107XG4gICAgXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbWF0cml4X3Jvd3MucHVzaCh0aGlzLmVsZW1lbnRzW2ldKTtcbiAgICBcdH1cbiAgICAgIHJldHVybiBtYXRyaXhfcm93cztcbiAgICB9LFxuXG5cbiAgICAvLyBTZXQgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkuIElmIHRoZSBhcmd1bWVudCBwYXNzZWRcbiAgICAvLyBpcyBhIHZlY3RvciwgdGhlIHJlc3VsdGluZyBtYXRyaXggd2lsbCBiZSBhIHNpbmdsZSBjb2x1bW4uXG4gICAgc2V0RWxlbWVudHM6IGZ1bmN0aW9uKGVscykge1xuXHR2YXIgaSwgaiwgZWxlbWVudHMgPSBlbHMuZWxlbWVudHMgfHwgZWxzO1xuXHRpZiAodHlwZW9mKGVsZW1lbnRzWzBdWzBdKSAhPSAndW5kZWZpbmVkJykge1xuXHQgICAgaSA9IGVsZW1lbnRzLmxlbmd0aDtcblx0ICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0XHRqID0gZWxlbWVudHNbaV0ubGVuZ3RoO1xuXHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcblx0XHR3aGlsZSAoai0tKSB7XG5cdFx0ICAgIHRoaXMuZWxlbWVudHNbaV1bal0gPSBlbGVtZW50c1tpXVtqXTtcblx0XHR9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0fVxuXHR2YXIgbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB0aGlzLmVsZW1lbnRzLnB1c2goW2VsZW1lbnRzW2ldXSk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgaW5kZXhlcyBvZiB0aGUgY29sdW1ucyB3aXRoIHRoZSBsYXJnZXN0IHZhbHVlXG4gICAgLy8gZm9yIGVhY2ggcm93XG4gICAgbWF4Q29sdW1uSW5kZXhlczogZnVuY3Rpb24oKSB7XG5cdHZhciBtYXhlcyA9IFtdO1xuXG5cdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5yb3dzKCk7IGkrKykge1xuXHQgICAgdmFyIG1heCA9IG51bGw7XG5cdCAgICB2YXIgbWF4SW5kZXggPSAtMTtcblxuXHQgICAgZm9yKHZhciBqID0gMTsgaiA8PSB0aGlzLmNvbHMoKTsgaisrKSB7XG5cdFx0aWYobWF4ID09PSBudWxsIHx8IHRoaXMuZShpLCBqKSA+IG1heCkge1xuXHRcdCAgICBtYXggPSB0aGlzLmUoaSwgaik7XG5cdFx0ICAgIG1heEluZGV4ID0gajtcblx0XHR9XG5cdCAgICB9XG5cblx0ICAgIG1heGVzLnB1c2gobWF4SW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuICRWKG1heGVzKTtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIHRoZSBsYXJnZXN0IHZhbHVlcyBpbiBlYWNoIHJvd1xuICAgIG1heENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWF4ZXMgPSBbXTtcblxuXHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMucm93cygpOyBpKyspIHtcblx0ICAgIHZhciBtYXggPSBudWxsO1xuXG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMuY29scygpOyBqKyspIHtcblx0XHRpZihtYXggPT09IG51bGwgfHwgdGhpcy5lKGksIGopID4gbWF4KSB7XG5cdFx0ICAgIG1heCA9IHRoaXMuZShpLCBqKTtcblx0XHR9XG5cdCAgICB9XG5cblx0ICAgIG1heGVzLnB1c2gobWF4KTtcblx0fVxuXG5cdHJldHVybiAkVihtYXhlcyk7XG4gICAgfSxcblxuICAgIC8vIHJldHVybiB0aGUgaW5kZXhlcyBvZiB0aGUgY29sdW1ucyB3aXRoIHRoZSBzbWFsbGVzdCB2YWx1ZXNcbiAgICAvLyBmb3IgZWFjaCByb3dcbiAgICBtaW5Db2x1bW5JbmRleGVzOiBmdW5jdGlvbigpIHtcblx0dmFyIG1pbnMgPSBbXTtcblxuXHRmb3IodmFyIGkgPSAxOyBpIDw9IHRoaXMucm93cygpOyBpKyspIHtcblx0ICAgIHZhciBtaW4gPSBudWxsO1xuXHQgICAgdmFyIG1pbkluZGV4ID0gLTE7XG5cblx0ICAgIGZvcih2YXIgaiA9IDE7IGogPD0gdGhpcy5jb2xzKCk7IGorKykge1xuXHRcdGlmKG1pbiA9PT0gbnVsbCB8fCB0aGlzLmUoaSwgaikgPCBtaW4pIHtcblx0XHQgICAgbWluID0gdGhpcy5lKGksIGopO1xuXHRcdCAgICBtaW5JbmRleCA9IGo7XG5cdFx0fVxuXHQgICAgfVxuXG5cdCAgICBtaW5zLnB1c2gobWluSW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuICRWKG1pbnMpO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gdGhlIHNtYWxsZXN0IHZhbHVlcyBpbiBlYWNoIHJvd1xuICAgIG1pbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWlucyA9IFtdO1xuXG5cdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5yb3dzKCk7IGkrKykge1xuXHQgICAgdmFyIG1pbiA9IG51bGw7XG5cblx0ICAgIGZvcih2YXIgaiA9IDE7IGogPD0gdGhpcy5jb2xzKCk7IGorKykge1xuXHRcdGlmKG1pbiA9PT0gbnVsbCB8fCB0aGlzLmUoaSwgaikgPCBtaW4pIHtcblx0XHQgICAgbWluID0gdGhpcy5lKGksIGopO1xuXHRcdH1cblx0ICAgIH1cblxuXHQgICAgbWlucy5wdXNoKG1pbik7XG5cdH1cblxuXHRyZXR1cm4gJFYobWlucyk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBwZXJvcm0gYSBwYXJ0aWFsIHBpdm90IG9uIHRoZSBtYXRyaXguIGVzc2VudGlhbGx5IG1vdmUgdGhlIGxhcmdlc3RcbiAgICAvLyByb3cgYmVsb3ctb3ItaW5jbHVkaW5nIHRoZSBwaXZvdCBhbmQgcmVwbGFjZSB0aGUgcGl2b3QncyByb3cgd2l0aCBpdC5cbiAgICAvLyBhIHBpdm90IG1hdHJpeCBpcyByZXR1cm5lZCBzbyBtdWx0aXBsaWNhdGlvbiBjYW4gcGVyZm9ybSB0aGUgdHJhbnNmb3JtLlxuICAgIHBhcnRpYWxQaXZvdDogZnVuY3Rpb24oaywgaiwgUCwgQSwgTCkge1xuXHR2YXIgbWF4SW5kZXggPSAwO1xuXHR2YXIgbWF4VmFsdWUgPSAwO1xuXG5cdGZvcih2YXIgaSA9IGs7IGkgPD0gQS5yb3dzKCk7IGkrKykge1xuXHQgICAgaWYoTWF0aC5hYnMoQS5lKGksIGopKSA+IG1heFZhbHVlKSB7XG5cdFx0bWF4VmFsdWUgPSBNYXRoLmFicyhBLmUoaywgaikpO1xuXHRcdG1heEluZGV4ID0gaTtcblx0ICAgIH1cblx0fVxuXG5cdGlmKG1heEluZGV4ICE9IGspIHtcblx0ICAgIHZhciB0bXAgPSBBLmVsZW1lbnRzW2sgLSAxXTtcblx0ICAgIEEuZWxlbWVudHNbayAtIDFdID0gQS5lbGVtZW50c1ttYXhJbmRleCAtIDFdO1xuXHQgICAgQS5lbGVtZW50c1ttYXhJbmRleCAtIDFdID0gdG1wO1xuXHQgICAgXG5cdCAgICBQLmVsZW1lbnRzW2sgLSAxXVtrIC0gMV0gPSAwO1xuXHQgICAgUC5lbGVtZW50c1trIC0gMV1bbWF4SW5kZXggLSAxXSA9IDE7XG5cdCAgICBQLmVsZW1lbnRzW21heEluZGV4IC0gMV1bbWF4SW5kZXggLSAxXSA9IDA7XG5cdCAgICBQLmVsZW1lbnRzW21heEluZGV4IC0gMV1bayAtIDFdID0gMTtcblx0fVxuXHRcblx0cmV0dXJuIFA7XG4gICAgfSxcblxuICAgIC8vIHNvbHZlIGxvd2VyLXRyaWFuZ3VsYXIgbWF0cml4ICogeCA9IGIgdmlhIGZvcndhcmQgc3Vic3RpdHV0aW9uXG4gICAgZm9yd2FyZFN1YnN0aXR1dGU6IGZ1bmN0aW9uKGIpIHtcblx0dmFyIHhhID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvd3MoKTsgaSsrKSB7XG5cdCAgICB2YXIgdyA9IDA7XG5cblx0ICAgIGZvcih2YXIgaiA9IDE7IGogPCBpOyBqKyspIHtcblx0XHR3ICs9IHRoaXMuZShpLCBqKSAqIHhhW2ogLSAxXTtcblx0ICAgIH1cblxuXHQgICAgeGEucHVzaCgoYi5lKGkpIC0gdykgLyB0aGlzLmUoaSwgaSkpO1xuXHR9XG5cblx0cmV0dXJuICRWKHhhKTtcbiAgICB9LFxuXG4gICAgLy8gc29sdmUgYW4gdXBwZXItdHJpYW5ndWxhciBtYXRyaXggKiB4ID0gYiB2aWEgYmFjayBzdWJzdGl0dXRpb25cbiAgICBiYWNrU3Vic3RpdHV0ZTogZnVuY3Rpb24oYikge1xuXHR2YXIgeGEgPSBbXTtcblxuXHRmb3IodmFyIGkgPSB0aGlzLnJvd3MoKTsgaSA+IDA7IGktLSkge1xuXHQgICAgdmFyIHcgPSAwO1xuXG5cdCAgICBmb3IodmFyIGogPSB0aGlzLmNvbHMoKTsgaiA+IGk7IGotLSkge1xuXHRcdHcgKz0gdGhpcy5lKGksIGopICogeGFbdGhpcy5yb3dzKCkgLSBqXTtcblx0ICAgIH1cblxuXHQgICAgeGEucHVzaCgoYi5lKGkpIC0gdykgLyB0aGlzLmUoaSwgaSkpO1xuXHR9XG5cblx0cmV0dXJuICRWKHhhLnJldmVyc2UoKSk7XG4gICAgfSxcbiAgICBcbiAgICBsdUpzOiBsdUpzLFxuICAgIHN2ZEpzOiBzdmRKcyxcbiAgICBxckpzOiBxckpzLFxufTtcblxuXG52YXIgdG9sZXJhbmNlID0gIDEuNDkwMWUtMDg7XG5cbi8vIHB1cmUgSmF2YXNjcmlwdCBMVSBmYWN0b3JpemF0aW9uXG5mdW5jdGlvbiBsdUpzKCkge1xuICAgIHZhciBBID0gdGhpcy5kdXAoKTtcbiAgICB2YXIgTCA9IE1hdHJpeC5JKEEucm93cygpKTtcbiAgICB2YXIgUCA9IE1hdHJpeC5JKEEucm93cygpKTtcbiAgICB2YXIgVSA9IE1hdHJpeC5aZXJvcyhBLnJvd3MoKSwgQS5jb2xzKCkpO1xuICAgIHZhciBwID0gMTtcblxuICAgIGZvcih2YXIgayA9IDE7IGsgPD0gTWF0aC5taW4oQS5jb2xzKCksIEEucm93cygpKTsgaysrKSB7XG5cdFAgPSBBLnBhcnRpYWxQaXZvdChrLCBwLCBQLCBBLCBMKTtcblx0XG5cdGZvcih2YXIgaSA9IGsgKyAxOyBpIDw9IEEucm93cygpOyBpKyspIHtcblx0ICAgIHZhciBsID0gQS5lKGksIHApIC8gQS5lKGssIHApO1xuXHQgICAgTC5lbGVtZW50c1tpIC0gMV1bayAtIDFdID0gbDtcblx0ICAgIFxuXHQgICAgZm9yKHZhciBqID0gayArIDEgOyBqIDw9IEEuY29scygpOyBqKyspIHtcblx0XHRBLmVsZW1lbnRzW2kgLSAxXVtqIC0gMV0gLT0gQS5lKGssIGopICogbDtcblx0ICAgIH1cblx0fVxuXHRcblx0Zm9yKHZhciBqID0gazsgaiA8PSBBLmNvbHMoKTsgaisrKSB7XG5cdCAgICBVLmVsZW1lbnRzW2sgLSAxXVtqIC0gMV0gPSBBLmUoaywgaik7XG5cdH1cblxuXHRpZihwIDwgQS5jb2xzKCkpXG5cdCAgICBwKys7XG4gICAgfSAgICBcbiAgICBcbiAgICByZXR1cm4ge0w6IEwsIFU6IFUsIFA6IFB9O1xufVxuXG5cblxuTWF0cml4LnByb3RvdHlwZS5zdmQgPSBzdmRKcztcbk1hdHJpeC5wcm90b3R5cGUucXIgPSBxckpzO1xuTWF0cml4LnByb3RvdHlwZS5sdSA9IGx1SnM7XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5NYXRyaXguY3JlYXRlID0gZnVuY3Rpb24oYUVsZW1lbnRzKSB7XG4gICAgdmFyIE0gPSBuZXcgTWF0cml4KCkuc2V0RWxlbWVudHMoYUVsZW1lbnRzKTtcbiAgICByZXR1cm4gTTtcbn07XG5cbi8vIElkZW50aXR5IG1hdHJpeCBvZiBzaXplIG5cbk1hdHJpeC5JID0gZnVuY3Rpb24obikge1xuICAgIHZhciBlbHMgPSBbXSwgaSA9IG4sIGo7XG4gICAgd2hpbGUgKGktLSkge1xuXHRqID0gbjtcblx0ZWxzW2ldID0gW107XG5cdHdoaWxlIChqLS0pIHtcblx0ICAgIGVsc1tpXVtqXSA9IChpID09IGopID8gMSA6IDA7XG5cdH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxzKTtcbn07XG5cbk1hdHJpeC5sb2FkRmlsZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIHZhciBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmLTgnKTtcbiAgICB2YXIgbWF0cml4ID0gW107XG5cbiAgICB2YXIgcm93QXJyYXkgPSBjb250ZW50cy5zcGxpdCgnXFxuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dBcnJheS5sZW5ndGg7IGkrKykge1xuXHR2YXIgZCA9IHJvd0FycmF5W2ldLnNwbGl0KCcsJyk7XG5cdGlmIChkLmxlbmd0aCA+IDEpIHtcblx0ICAgIG1hdHJpeC5wdXNoKGQpO1xuXHR9XG4gICAgfVxuXG4gICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIE0uc2V0RWxlbWVudHMobWF0cml4KTtcbn07XG5cbi8vIERpYWdvbmFsIG1hdHJpeCAtIGFsbCBvZmYtZGlhZ29uYWwgZWxlbWVudHMgYXJlIHplcm9cbk1hdHJpeC5EaWFnb25hbCA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIE0gPSBNYXRyaXguSShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG5cdE0uZWxlbWVudHNbaV1baV0gPSBlbGVtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIE07XG59O1xuXG4vLyBSb3RhdGlvbiBtYXRyaXggYWJvdXQgc29tZSBheGlzLiBJZiBubyBheGlzIGlzXG4vLyBzdXBwbGllZCwgYXNzdW1lIHdlJ3JlIGFmdGVyIGEgMkQgdHJhbnNmb3JtXG5NYXRyaXguUm90YXRpb24gPSBmdW5jdGlvbih0aGV0YSwgYSkge1xuICAgIGlmICghYSkge1xuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdCAgICBbTWF0aC5jb3ModGhldGEpLCAtTWF0aC5zaW4odGhldGEpXSxcblx0ICAgIFtNYXRoLnNpbih0aGV0YSksIE1hdGguY29zKHRoZXRhKV1cblx0XSk7XG4gICAgfVxuICAgIHZhciBheGlzID0gYS5kdXAoKTtcbiAgICBpZiAoYXhpcy5lbGVtZW50cy5sZW5ndGggIT0gMykgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBtb2QgPSBheGlzLm1vZHVsdXMoKTtcbiAgICB2YXIgeCA9IGF4aXMuZWxlbWVudHNbMF0gLyBtb2QsIHkgPSBheGlzLmVsZW1lbnRzWzFdIC8gbW9kLCB6ID0gYXhpcy5lbGVtZW50c1syXSAvIG1vZDtcbiAgICB2YXIgcyA9IE1hdGguc2luKHRoZXRhKSwgYyA9IE1hdGguY29zKHRoZXRhKSwgdCA9IDEgLSBjO1xuICAgIC8vIEZvcm11bGEgZGVyaXZlZCBoZXJlOiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcbiAgICAvLyBUaGF0IHByb29mIHJvdGF0ZXMgdGhlIGNvLW9yZGluYXRlIHN5c3RlbSBzbyB0aGV0YVxuICAgIC8vIGJlY29tZXMgLXRoZXRhIGFuZCBzaW4gYmVjb21lcyAtc2luIGhlcmUuXG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoW1xuXHRbdCAqIHggKiB4ICsgYywgdCAqIHggKiB5IC0gcyAqIHosIHQgKiB4ICogeiArIHMgKiB5XSxcblx0W3QgKiB4ICogeSArIHMgKiB6LCB0ICogeSAqIHkgKyBjLCB0ICogeSAqIHogLSBzICogeF0sXG5cdFt0ICogeCAqIHogLSBzICogeSwgdCAqIHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGNdXG4gICAgXSk7XG59O1xuXG4vLyBTcGVjaWFsIGNhc2Ugcm90YXRpb25zXG5NYXRyaXguUm90YXRpb25YID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFsxLCAwLCAwXSxcblx0WzAsIGMsIC1zXSxcblx0WzAsIHMsIGNdXG4gICAgXSk7XG59O1xuXG5NYXRyaXguUm90YXRpb25ZID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFtjLCAwLCBzXSxcblx0WzAsIDEsIDBdLFxuXHRbLXMsIDAsIGNdXG4gICAgXSk7XG59O1xuXG5NYXRyaXguUm90YXRpb25aID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBjID0gTWF0aC5jb3ModCksIHMgPSBNYXRoLnNpbih0KTtcbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdFtjLCAtcywgMF0sXG5cdFtzLCBjLCAwXSxcblx0WzAsIDAsIDFdXG4gICAgXSk7XG59O1xuXG4vLyBSYW5kb20gbWF0cml4IG9mIG4gcm93cywgbSBjb2x1bW5zXG5NYXRyaXguUmFuZG9tID0gZnVuY3Rpb24obiwgbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBtID0gbjtcbiAgICByZXR1cm4gTWF0cml4Llplcm8obiwgbSkubWFwKFxuXHRmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucmFuZG9tKCk7IH1cbiAgKTtcbn07XG5cbk1hdHJpeC5GaWxsID0gZnVuY3Rpb24obiwgbSwgdikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG5cdHYgPSBtO1xuXHRtID0gbjtcbiAgICB9XG5cbiAgICB2YXIgZWxzID0gW10sIGkgPSBuLCBqO1xuXG4gICAgd2hpbGUgKGktLSkge1xuXHRqID0gbTtcblx0ZWxzW2ldID0gW107XG5cblx0d2hpbGUgKGotLSkge1xuXHQgICAgZWxzW2ldW2pdID0gdjtcblx0fVxuICAgIH1cblxuICAgIHJldHVybiBNYXRyaXguY3JlYXRlKGVscyk7XG59O1xuXG4vLyBNYXRyaXggZmlsbGVkIHdpdGggemVyb3Ncbk1hdHJpeC5aZXJvID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguRmlsbChuLCBtLCAwKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCB6ZXJvc1xuTWF0cml4Llplcm9zID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguWmVybyhuLCBtKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzXG5NYXRyaXguT25lID0gZnVuY3Rpb24obiwgbSkge1xuICAgIHJldHVybiBNYXRyaXguRmlsbChuLCBtLCAxKTtcbn07XG5cbi8vIE1hdHJpeCBmaWxsZWQgd2l0aCBvbmVzXG5NYXRyaXguT25lcyA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICByZXR1cm4gTWF0cml4Lk9uZShuLCBtKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBQbGFuZSBjbGFzcyAtIGRlcGVuZHMgb24gVmVjdG9yLiBTb21lIG1ldGhvZHMgcmVxdWlyZSBNYXRyaXggYW5kIExpbmUuXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xudmFyIExpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG5cbmZ1bmN0aW9uIFBsYW5lKCkge31cblBsYW5lLnByb3RvdHlwZSA9IHtcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBwbGFuZSBvY2N1cGllcyB0aGUgc2FtZSBzcGFjZSBhcyB0aGUgYXJndW1lbnRcbiAgZXFsOiBmdW5jdGlvbihwbGFuZSkge1xuICAgIHJldHVybiAodGhpcy5jb250YWlucyhwbGFuZS5hbmNob3IpICYmIHRoaXMuaXNQYXJhbGxlbFRvKHBsYW5lKSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHBsYW5lXG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBsYW5lLmNyZWF0ZSh0aGlzLmFuY2hvciwgdGhpcy5ub3JtYWwpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0cmFuc2xhdGluZyB0aGUgcGxhbmUgYnkgdGhlIGdpdmVuIHZlY3RvclxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKFtcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzBdICsgVlswXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzFdICsgVlsxXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzJdICsgKFZbMl0gfHwgMClcbiAgICBdLCB0aGlzLm5vcm1hbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgcGxhbmUgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50LiBXaWxsIHJldHVybiB0cnVlXG4gIC8vIGlmIHRoZSBwbGFuZXMgYXJlIGVxdWFsLCBvciBpZiB5b3UgZ2l2ZSBhIGxpbmUgYW5kIGl0IGxpZXMgaW4gdGhlIHBsYW5lLlxuICBpc1BhcmFsbGVsVG86IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0aGV0YTtcbiAgICBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHRoZXRhID0gdGhpcy5ub3JtYWwuYW5nbGVGcm9tKG9iai5ub3JtYWwpO1xuICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGV0YSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbiB8fCBNYXRoLmFicyhNYXRoLlBJIC0gdGhldGEpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICAgIH0gZWxzZSBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsLmlzUGVycGVuZGljdWxhclRvKG9iai5kaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSByZWNlaXZlciBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhcmd1bWVudFxuICBpc1BlcnBlbmRpY3VsYXJUbzogZnVuY3Rpb24ocGxhbmUpIHtcbiAgICB2YXIgdGhldGEgPSB0aGlzLm5vcm1hbC5hbmdsZUZyb20ocGxhbmUubm9ybWFsKTtcbiAgICByZXR1cm4gKE1hdGguYWJzKE1hdGguUEkvMiAtIHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBwbGFuZSdzIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIG9iamVjdCAocG9pbnQsIGxpbmUgb3IgcGxhbmUpXG4gIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJzZWN0cyhvYmopIHx8IHRoaXMuY29udGFpbnMob2JqKSkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChvYmouYW5jaG9yKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZSBvciBsaW5lXG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBCID0gb2JqLmFuY2hvci5lbGVtZW50cywgTiA9IHRoaXMubm9ybWFsLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKChBWzBdIC0gQlswXSkgKiBOWzBdICsgKEFbMV0gLSBCWzFdKSAqIE5bMV0gKyAoQVsyXSAtIEJbMl0pICogTlsyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBvaW50XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoKEFbMF0gLSBQWzBdKSAqIE5bMF0gKyAoQVsxXSAtIFBbMV0pICogTlsxXSArIChBWzJdIC0gKFBbMl0gfHwgMCkpICogTlsyXSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHBsYW5lIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludCBvciBsaW5lXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gKHRoaXMuY29udGFpbnMob2JqLmFuY2hvcikgJiYgdGhpcy5jb250YWlucyhvYmouYW5jaG9yLmFkZChvYmouZGlyZWN0aW9uKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKE5bMF0qKEFbMF0gLSBQWzBdKSArIE5bMV0qKEFbMV0gLSBQWzFdKSArIE5bMl0qKEFbMl0gLSAoUFsyXSB8fCAwKSkpO1xuICAgICAgcmV0dXJuIChkaWZmIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBwbGFuZSBoYXMgYSB1bmlxdWUgcG9pbnQvbGluZSBvZiBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgYXJndW1lbnRcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHR5cGVvZihvYmouZGlyZWN0aW9uKSA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Yob2JqLm5vcm1hbCkgPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gIXRoaXMuaXNQYXJhbGxlbFRvKG9iaik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIGludGVyc2VjdGlvbiB3aXRoIHRoZSBhcmd1bWVudCwgaWYgb25lIGV4aXN0cy4gVGhlIHJlc3VsdFxuICAvLyB3aWxsIGJlIGEgdmVjdG9yIGlmIGEgbGluZSBpcyBzdXBwbGllZCwgYW5kIGEgbGluZSBpZiBhIHBsYW5lIGlzIHN1cHBsaWVkLlxuICBpbnRlcnNlY3Rpb25XaXRoOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvYmopKSB7IHJldHVybiBudWxsOyB9XG4gICAgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmVcbiAgICAgIHZhciBBID0gb2JqLmFuY2hvci5lbGVtZW50cywgRCA9IG9iai5kaXJlY3Rpb24uZWxlbWVudHMsXG4gICAgICAgICAgUCA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IChOWzBdKihQWzBdLUFbMF0pICsgTlsxXSooUFsxXS1BWzFdKSArIE5bMl0qKFBbMl0tQVsyXSkpIC8gKE5bMF0qRFswXSArIE5bMV0qRFsxXSArIE5bMl0qRFsyXSk7XG4gICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQVswXSArIERbMF0qbXVsdGlwbGllciwgQVsxXSArIERbMV0qbXVsdGlwbGllciwgQVsyXSArIERbMl0qbXVsdGlwbGllcl0pO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm5vcm1hbC5jcm9zcyhvYmoubm9ybWFsKS50b1VuaXRWZWN0b3IoKTtcbiAgICAgIC8vIFRvIGZpbmQgYW4gYW5jaG9yIHBvaW50LCB3ZSBmaW5kIG9uZSBjby1vcmRpbmF0ZSB0aGF0IGhhcyBhIHZhbHVlXG4gICAgICAvLyBvZiB6ZXJvIHNvbWV3aGVyZSBvbiB0aGUgaW50ZXJzZWN0aW9uLCBhbmQgcmVtZW1iZXIgd2hpY2ggb25lIHdlIHBpY2tlZFxuICAgICAgdmFyIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cywgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLFxuICAgICAgICAgIE8gPSBvYmoubm9ybWFsLmVsZW1lbnRzLCBCID0gb2JqLmFuY2hvci5lbGVtZW50cztcbiAgICAgIHZhciBzb2x2ZXIgPSBNYXRyaXguWmVybygyLDIpLCBpID0gMDtcbiAgICAgIHdoaWxlIChzb2x2ZXIuaXNTaW5ndWxhcigpKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgc29sdmVyID0gTWF0cml4LmNyZWF0ZShbXG4gICAgICAgICAgWyBOW2klM10sIE5bKGkrMSklM10gXSxcbiAgICAgICAgICBbIE9baSUzXSwgT1soaSsxKSUzXSAgXVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZW4gd2Ugc29sdmUgdGhlIHNpbXVsdGFuZW91cyBlcXVhdGlvbnMgaW4gdGhlIHJlbWFpbmluZyBkaW1lbnNpb25zXG4gICAgICB2YXIgaW52ZXJzZSA9IHNvbHZlci5pbnZlcnNlKCkuZWxlbWVudHM7XG4gICAgICB2YXIgeCA9IE5bMF0qQVswXSArIE5bMV0qQVsxXSArIE5bMl0qQVsyXTtcbiAgICAgIHZhciB5ID0gT1swXSpCWzBdICsgT1sxXSpCWzFdICsgT1syXSpCWzJdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IFtcbiAgICAgICAgaW52ZXJzZVswXVswXSAqIHggKyBpbnZlcnNlWzBdWzFdICogeSxcbiAgICAgICAgaW52ZXJzZVsxXVswXSAqIHggKyBpbnZlcnNlWzFdWzFdICogeVxuICAgICAgXTtcbiAgICAgIHZhciBhbmNob3IgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDM7IGorKykge1xuICAgICAgICAvLyBUaGlzIGZvcm11bGEgcGlja3MgdGhlIHJpZ2h0IGVsZW1lbnQgZnJvbSBpbnRlcnNlY3Rpb24gYnlcbiAgICAgICAgLy8gY3ljbGluZyBkZXBlbmRpbmcgb24gd2hpY2ggZWxlbWVudCB3ZSBzZXQgdG8gemVybyBhYm92ZVxuICAgICAgICBhbmNob3IucHVzaCgoaSA9PSBqKSA/IDAgOiBpbnRlcnNlY3Rpb25bKGogKyAoNSAtIGkpJTMpJTNdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBMaW5lLmNyZWF0ZShhbmNob3IsIGRpcmVjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IGluIHRoZSBwbGFuZSBjbG9zZXN0IHRvIHRoZSBnaXZlbiBwb2ludFxuICBwb2ludENsb3Nlc3RUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgUCA9IHBvaW50LmVsZW1lbnRzIHx8IHBvaW50O1xuICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICB2YXIgZG90ID0gKEFbMF0gLSBQWzBdKSAqIE5bMF0gKyAoQVsxXSAtIFBbMV0pICogTlsxXSArIChBWzJdIC0gKFBbMl0gfHwgMCkpICogTlsyXTtcbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbUFswXSArIE5bMF0gKiBkb3QsIFBbMV0gKyBOWzFdICogZG90LCAoUFsyXSB8fCAwKSArIE5bMl0gKiBkb3RdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgcGxhbmUsIHJvdGF0ZWQgYnkgdCByYWRpYW5zIGFib3V0IHRoZSBnaXZlbiBsaW5lXG4gIC8vIFNlZSBub3RlcyBvbiBMaW5lI3JvdGF0ZS5cbiAgcm90YXRlOiBmdW5jdGlvbih0LCBsaW5lKSB7XG4gICAgdmFyIFIgPSB0LmRldGVybWluYW50ID8gdC5lbGVtZW50cyA6IE1hdHJpeC5Sb3RhdGlvbih0LCBsaW5lLmRpcmVjdGlvbikuZWxlbWVudHM7XG4gICAgdmFyIEMgPSBsaW5lLnBvaW50Q2xvc2VzdFRvKHRoaXMuYW5jaG9yKS5lbGVtZW50cztcbiAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgdmFyIEMxID0gQ1swXSwgQzIgPSBDWzFdLCBDMyA9IENbMl0sIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl07XG4gICAgdmFyIHggPSBBMSAtIEMxLCB5ID0gQTIgLSBDMiwgeiA9IEEzIC0gQzM7XG4gICAgcmV0dXJuIFBsYW5lLmNyZWF0ZShbXG4gICAgICBDMSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcbiAgICAgIEMyICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuICAgICAgQzMgKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICBdLCBbXG4gICAgICBSWzBdWzBdICogTlswXSArIFJbMF1bMV0gKiBOWzFdICsgUlswXVsyXSAqIE5bMl0sXG4gICAgICBSWzFdWzBdICogTlswXSArIFJbMV1bMV0gKiBOWzFdICsgUlsxXVsyXSAqIE5bMl0sXG4gICAgICBSWzJdWzBdICogTlswXSArIFJbMl1bMV0gKiBOWzFdICsgUlsyXVsyXSAqIE5bMl1cbiAgICBdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBwbGFuZSBpbiB0aGUgZ2l2ZW4gcG9pbnQsIGxpbmUgb3IgcGxhbmUuXG4gIHJlZmxlY3Rpb25JbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwpIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBsYW5lXG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgQTEgPSBBWzBdLCBBMiA9IEFbMV0sIEEzID0gQVsyXSwgTjEgPSBOWzBdLCBOMiA9IE5bMV0sIE4zID0gTlsyXTtcbiAgICAgIHZhciBuZXdBID0gdGhpcy5hbmNob3IucmVmbGVjdGlvbkluKG9iaikuZWxlbWVudHM7XG4gICAgICAvLyBBZGQgdGhlIHBsYW5lJ3Mgbm9ybWFsIHRvIGl0cyBhbmNob3IsIHRoZW4gbWlycm9yIHRoYXQgaW4gdGhlIG90aGVyIHBsYW5lXG4gICAgICB2YXIgQU4xID0gQTEgKyBOMSwgQU4yID0gQTIgKyBOMiwgQU4zID0gQTMgKyBOMztcbiAgICAgIHZhciBRID0gb2JqLnBvaW50Q2xvc2VzdFRvKFtBTjEsIEFOMiwgQU4zXSkuZWxlbWVudHM7XG4gICAgICB2YXIgbmV3TiA9IFtRWzBdICsgKFFbMF0gLSBBTjEpIC0gbmV3QVswXSwgUVsxXSArIChRWzFdIC0gQU4yKSAtIG5ld0FbMV0sIFFbMl0gKyAoUVsyXSAtIEFOMykgLSBuZXdBWzJdXTtcbiAgICAgIHJldHVybiBQbGFuZS5jcmVhdGUobmV3QSwgbmV3Tik7XG4gICAgfSBlbHNlIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lXG4gICAgICByZXR1cm4gdGhpcy5yb3RhdGUoTWF0aC5QSSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHJldHVybiBQbGFuZS5jcmVhdGUodGhpcy5hbmNob3IucmVmbGVjdGlvbkluKFtQWzBdLCBQWzFdLCAoUFsyXSB8fCAwKV0pLCB0aGlzLm5vcm1hbCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNldHMgdGhlIGFuY2hvciBwb2ludCBhbmQgbm9ybWFsIHRvIHRoZSBwbGFuZS4gSWYgdGhyZWUgYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQsXG4gIC8vIHRoZSBub3JtYWwgaXMgY2FsY3VsYXRlZCBieSBhc3N1bWluZyB0aGUgdGhyZWUgcG9pbnRzIHNob3VsZCBsaWUgaW4gdGhlIHNhbWUgcGxhbmUuXG4gIC8vIElmIG9ubHkgdHdvIGFyZSBzZXBjaWZpZWQsIHRoZSBzZWNvbmQgaXMgdGFrZW4gdG8gYmUgdGhlIG5vcm1hbC4gTm9ybWFsIHZlY3RvciBpc1xuICAvLyBub3JtYWxpc2VkIGJlZm9yZSBzdG9yYWdlLlxuICBzZXRWZWN0b3JzOiBmdW5jdGlvbihhbmNob3IsIHYxLCB2Mikge1xuICAgIGFuY2hvciA9IFZlY3Rvci5jcmVhdGUoYW5jaG9yKTtcbiAgICBhbmNob3IgPSBhbmNob3IudG8zRCgpOyBpZiAoYW5jaG9yID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgdjEgPSBWZWN0b3IuY3JlYXRlKHYxKTtcbiAgICB2MSA9IHYxLnRvM0QoKTsgaWYgKHYxID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgaWYgKHR5cGVvZih2MikgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHYyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdjIgPSBWZWN0b3IuY3JlYXRlKHYyKTtcbiAgICAgIHYyID0gdjIudG8zRCgpOyBpZiAodjIgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB9XG4gICAgdmFyIEExID0gYW5jaG9yLmVsZW1lbnRzWzBdLCBBMiA9IGFuY2hvci5lbGVtZW50c1sxXSwgQTMgPSBhbmNob3IuZWxlbWVudHNbMl07XG4gICAgdmFyIHYxMSA9IHYxLmVsZW1lbnRzWzBdLCB2MTIgPSB2MS5lbGVtZW50c1sxXSwgdjEzID0gdjEuZWxlbWVudHNbMl07XG4gICAgdmFyIG5vcm1hbCwgbW9kO1xuICAgIGlmICh2MiAhPT0gbnVsbCkge1xuICAgICAgdmFyIHYyMSA9IHYyLmVsZW1lbnRzWzBdLCB2MjIgPSB2Mi5lbGVtZW50c1sxXSwgdjIzID0gdjIuZWxlbWVudHNbMl07XG4gICAgICBub3JtYWwgPSBWZWN0b3IuY3JlYXRlKFtcbiAgICAgICAgKHYxMiAtIEEyKSAqICh2MjMgLSBBMykgLSAodjEzIC0gQTMpICogKHYyMiAtIEEyKSxcbiAgICAgICAgKHYxMyAtIEEzKSAqICh2MjEgLSBBMSkgLSAodjExIC0gQTEpICogKHYyMyAtIEEzKSxcbiAgICAgICAgKHYxMSAtIEExKSAqICh2MjIgLSBBMikgLSAodjEyIC0gQTIpICogKHYyMSAtIEExKVxuICAgICAgXSk7XG4gICAgICBtb2QgPSBub3JtYWwubW9kdWx1cygpO1xuICAgICAgaWYgKG1vZCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgbm9ybWFsID0gVmVjdG9yLmNyZWF0ZShbbm9ybWFsLmVsZW1lbnRzWzBdIC8gbW9kLCBub3JtYWwuZWxlbWVudHNbMV0gLyBtb2QsIG5vcm1hbC5lbGVtZW50c1syXSAvIG1vZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2QgPSBNYXRoLnNxcnQodjExKnYxMSArIHYxMip2MTIgKyB2MTMqdjEzKTtcbiAgICAgIGlmIChtb2QgPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIG5vcm1hbCA9IFZlY3Rvci5jcmVhdGUoW3YxLmVsZW1lbnRzWzBdIC8gbW9kLCB2MS5lbGVtZW50c1sxXSAvIG1vZCwgdjEuZWxlbWVudHNbMl0gLyBtb2RdKTtcbiAgICB9XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5QbGFuZS5jcmVhdGUgPSBmdW5jdGlvbihhbmNob3IsIHYxLCB2Mikge1xuICB2YXIgUCA9IG5ldyBQbGFuZSgpO1xuICByZXR1cm4gUC5zZXRWZWN0b3JzKGFuY2hvciwgdjEsIHYyKTtcbn07XG5cbi8vIFgtWS1aIHBsYW5lc1xuUGxhbmUuWFkgPSBQbGFuZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5rKTtcblBsYW5lLllaID0gUGxhbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3IuaSk7XG5QbGFuZS5aWCA9IFBsYW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmopO1xuUGxhbmUuWVggPSBQbGFuZS5YWTsgUGxhbmUuWlkgPSBQbGFuZS5ZWjsgUGxhbmUuWFogPSBQbGFuZS5aWDtcblxuLy8gUmV0dXJucyB0aGUgcGxhbmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gcG9pbnRzIChjYW4gYmUgYXJyYXlzIGFzXG4vLyB3ZWxsIGFzIHZlY3RvcnMpLiBJZiB0aGUgcG9pbnRzIGFyZSBub3QgY29wbGFuYXIsIHJldHVybnMgbnVsbC5cblBsYW5lLmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aCwgbGlzdCA9IFtdLCBpLCBQLCBuLCBOLCBBLCBCLCBDLCBELCB0aGV0YSwgcHJldk4sIHRvdGFsTiA9IFZlY3Rvci5aZXJvKDMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbnA7IGkrKykge1xuICAgIFAgPSBWZWN0b3IuY3JlYXRlKHBvaW50c1tpXSkudG8zRCgpO1xuICAgIGlmIChQID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGlzdC5wdXNoKFApO1xuICAgIG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobiA+IDIpIHtcbiAgICAgIC8vIENvbXB1dGUgcGxhbmUgbm9ybWFsIGZvciB0aGUgbGF0ZXN0IHRocmVlIHBvaW50c1xuICAgICAgQSA9IGxpc3Rbbi0xXS5lbGVtZW50czsgQiA9IGxpc3Rbbi0yXS5lbGVtZW50czsgQyA9IGxpc3Rbbi0zXS5lbGVtZW50cztcbiAgICAgIE4gPSBWZWN0b3IuY3JlYXRlKFtcbiAgICAgICAgKEFbMV0gLSBCWzFdKSAqIChDWzJdIC0gQlsyXSkgLSAoQVsyXSAtIEJbMl0pICogKENbMV0gLSBCWzFdKSxcbiAgICAgICAgKEFbMl0gLSBCWzJdKSAqIChDWzBdIC0gQlswXSkgLSAoQVswXSAtIEJbMF0pICogKENbMl0gLSBCWzJdKSxcbiAgICAgICAgKEFbMF0gLSBCWzBdKSAqIChDWzFdIC0gQlsxXSkgLSAoQVsxXSAtIEJbMV0pICogKENbMF0gLSBCWzBdKVxuICAgICAgXSkudG9Vbml0VmVjdG9yKCk7XG4gICAgICBpZiAobiA+IDMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhdGVzdCBub3JtYWwgaXMgbm90IChhbnRpKXBhcmFsbGVsIHRvIHRoZSBwcmV2aW91cyBvbmUsIHdlJ3ZlIHN0cmF5ZWQgb2ZmIHRoZSBwbGFuZS5cbiAgICAgICAgLy8gVGhpcyBtaWdodCBiZSBhIHNsaWdodGx5IGxvbmctd2luZGVkIHdheSBvZiBkb2luZyB0aGluZ3MsIGJ1dCB3ZSBuZWVkIHRoZSBzdW0gb2YgYWxsIHRoZSBub3JtYWxzXG4gICAgICAgIC8vIHRvIGZpbmQgd2hpY2ggd2F5IHRoZSBwbGFuZSBub3JtYWwgc2hvdWxkIHBvaW50IHNvIHRoYXQgdGhlIHBvaW50cyBmb3JtIGFuIGFudGljbG9ja3dpc2UgbGlzdC5cbiAgICAgICAgdGhldGEgPSBOLmFuZ2xlRnJvbShwcmV2Tik7XG4gICAgICAgIGlmICh0aGV0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoZXRhIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG90YWxOID0gdG90YWxOLmFkZChOKTtcbiAgICAgIHByZXZOID0gTjtcbiAgICB9XG4gIH1cbiAgLy8gV2UgbmVlZCB0byBhZGQgaW4gdGhlIG5vcm1hbHMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLCB3aGljaCB0aGUgYWJvdmUgbWlzc2VzIG91dFxuICBBID0gbGlzdFsxXS5lbGVtZW50czsgQiA9IGxpc3RbMF0uZWxlbWVudHM7IEMgPSBsaXN0W24tMV0uZWxlbWVudHM7IEQgPSBsaXN0W24tMl0uZWxlbWVudHM7XG4gIHRvdGFsTiA9IHRvdGFsTi5hZGQoVmVjdG9yLmNyZWF0ZShbXG4gICAgKEFbMV0gLSBCWzFdKSAqIChDWzJdIC0gQlsyXSkgLSAoQVsyXSAtIEJbMl0pICogKENbMV0gLSBCWzFdKSxcbiAgICAoQVsyXSAtIEJbMl0pICogKENbMF0gLSBCWzBdKSAtIChBWzBdIC0gQlswXSkgKiAoQ1syXSAtIEJbMl0pLFxuICAgIChBWzBdIC0gQlswXSkgKiAoQ1sxXSAtIEJbMV0pIC0gKEFbMV0gLSBCWzFdKSAqIChDWzBdIC0gQlswXSlcbiAgXSkudG9Vbml0VmVjdG9yKCkpLmFkZChWZWN0b3IuY3JlYXRlKFtcbiAgICAoQlsxXSAtIENbMV0pICogKERbMl0gLSBDWzJdKSAtIChCWzJdIC0gQ1syXSkgKiAoRFsxXSAtIENbMV0pLFxuICAgIChCWzJdIC0gQ1syXSkgKiAoRFswXSAtIENbMF0pIC0gKEJbMF0gLSBDWzBdKSAqIChEWzJdIC0gQ1syXSksXG4gICAgKEJbMF0gLSBDWzBdKSAqIChEWzFdIC0gQ1sxXSkgLSAoQlsxXSAtIENbMV0pICogKERbMF0gLSBDWzBdKVxuICBdKS50b1VuaXRWZWN0b3IoKSk7XG4gIHJldHVybiBQbGFuZS5jcmVhdGUobGlzdFswXSwgdG90YWxOKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbi8vIFRoaXMgZmlsZSBpcyByZXF1aXJlZCBpbiBvcmRlciBmb3IgYW55IG90aGVyIGNsYXNzZXMgdG8gd29yay4gU29tZSBWZWN0b3IgbWV0aG9kcyB3b3JrIHdpdGggdGhlXG4vLyBvdGhlciBTeWx2ZXN0ZXIgY2xhc3NlcyBhbmQgYXJlIHVzZWxlc3MgdW5sZXNzIHRoZXkgYXJlIGluY2x1ZGVkLiBPdGhlciBjbGFzc2VzIHN1Y2ggYXMgTGluZSBhbmRcbi8vIFBsYW5lIHdpbGwgbm90IGZ1bmN0aW9uIGF0IGFsbCB3aXRob3V0IFZlY3RvciBiZWluZyBsb2FkZWQgZmlyc3QuICAgICAgICAgICBcblxuTWF0aC5zaWduID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC0xOiAxO1xufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxudmFyIFN5bHZlc3RlciA9IHtcbiAgICBwcmVjaXNpb246IDFlLTYsXG4gICAgYXBwcm94UHJlY2lzaW9uOiAxZS01XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bHZlc3RlcjtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxuLy8gVGhpcyBmaWxlIGlzIHJlcXVpcmVkIGluIG9yZGVyIGZvciBhbnkgb3RoZXIgY2xhc3NlcyB0byB3b3JrLiBTb21lIFZlY3RvciBtZXRob2RzIHdvcmsgd2l0aCB0aGVcbi8vIG90aGVyIFN5bHZlc3RlciBjbGFzc2VzIGFuZCBhcmUgdXNlbGVzcyB1bmxlc3MgdGhleSBhcmUgaW5jbHVkZWQuIE90aGVyIGNsYXNzZXMgc3VjaCBhcyBMaW5lIGFuZFxuLy8gUGxhbmUgd2lsbCBub3QgZnVuY3Rpb24gYXQgYWxsIHdpdGhvdXQgVmVjdG9yIGJlaW5nIGxvYWRlZCBmaXJzdC5cblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyksXG5NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG5mdW5jdGlvbiBWZWN0b3IoKSB7fVxuVmVjdG9yLnByb3RvdHlwZSA9IHtcblxuICAgIG5vcm06IGZ1bmN0aW9uKCkge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgc3VtID0gMDtcblxuXHR3aGlsZSAobi0tKSB7XG5cdCAgICBzdW0gKz0gTWF0aC5wb3codGhpcy5lbGVtZW50c1tuXSwgMik7XG5cdH1cblxuXHRyZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZWxlbWVudCBpIG9mIHRoZSB2ZWN0b3JcbiAgICBlOiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKGkgPCAxIHx8IGkgPiB0aGlzLmVsZW1lbnRzLmxlbmd0aCkgPyBudWxsIDogdGhpcy5lbGVtZW50c1tpIC0gMV07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzL2NvbHVtbnMgdGhlIHZlY3RvciBoYXNcbiAgICBkaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7cm93czogMSwgY29sczogdGhpcy5lbGVtZW50cy5sZW5ndGh9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdmVjdG9yXG4gICAgcm93czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHZlY3RvclxuICAgIGNvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBtb2R1bHVzICgnbGVuZ3RoJykgb2YgdGhlIHZlY3RvclxuICAgIG1vZHVsdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBlcXVhbCB0byB0aGUgYXJndW1lbnRcbiAgICBlcWw6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIFx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBcdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICBcdGlmIChuICE9IFYubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0d2hpbGUgKG4tLSkge1xuICAgIFx0ICAgIGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW25dIC0gVltuXSkgPiBTeWx2ZXN0ZXIucHJlY2lzaW9uKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB2ZWN0b3JcbiAgICBkdXA6IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUodGhpcy5lbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIE1hcHMgdGhlIHZlY3RvciB0byBhbm90aGVyIHZlY3RvciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAgbWFwOiBmdW5jdGlvbihmbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblx0dGhpcy5lYWNoKGZ1bmN0aW9uKHgsIGkpIHtcblx0ICAgIGVsZW1lbnRzLnB1c2goZm4oeCwgaSkpO1xuXHR9KTtcblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxscyB0aGUgaXRlcmF0b3IgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGluIHR1cm5cbiAgICBlYWNoOiBmdW5jdGlvbihmbikge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgZm4odGhpcy5lbGVtZW50c1tpXSwgaSArIDEpO1xuXHR9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBuZXcgdmVjdG9yIGNyZWF0ZWQgYnkgbm9ybWFsaXppbmcgdGhlIHJlY2VpdmVyXG4gICAgdG9Vbml0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0dmFyIHIgPSB0aGlzLm1vZHVsdXMoKTtcblx0aWYgKHIgPT09IDApIHsgcmV0dXJuIHRoaXMuZHVwKCk7IH1cblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggLyByOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGFuZCB0aGUgYXJndW1lbnQgKGFsc28gYSB2ZWN0b3IpXG4gICAgYW5nbGVGcm9tOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBrID0gbiwgaTtcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIGRvdCA9IDAsIG1vZDEgPSAwLCBtb2QyID0gMDtcblx0Ly8gV29yayB0aGluZ3Mgb3V0IGluIHBhcmFsbGVsIHRvIHNhdmUgdGltZVxuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgZG90ICs9IHggKiBWW2kgLSAxXTtcblx0ICAgIG1vZDEgKz0geCAqIHg7XG5cdCAgICBtb2QyICs9IFZbaSAtIDFdICogVltpIC0gMV07XG5cdH0pO1xuXHRtb2QxID0gTWF0aC5zcXJ0KG1vZDEpOyBtb2QyID0gTWF0aC5zcXJ0KG1vZDIpO1xuXHRpZiAobW9kMSAqIG1vZDIgPT09IDApIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIHRoZXRhID0gZG90IC8gKG1vZDEgKiBtb2QyKTtcblx0aWYgKHRoZXRhIDwgLTEpIHsgdGhldGEgPSAtMTsgfVxuXHRpZiAodGhldGEgPiAxKSB7IHRoZXRhID0gMTsgfVxuXHRyZXR1cm4gTWF0aC5hY29zKHRoZXRhKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIHBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBhbmdsZSA9IHRoaXMuYW5nbGVGcm9tKHZlY3Rvcik7XG5cdHJldHVybiAoYW5nbGUgPT09IG51bGwpID8gbnVsbCA6IChhbmdsZSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGFudGlwYXJhbGxlbCB0byB0aGUgYXJndW1lbnRcbiAgICBpc0FudGlwYXJhbGxlbFRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGFuZ2xlID0gdGhpcy5hbmdsZUZyb20odmVjdG9yKTtcblx0cmV0dXJuIChhbmdsZSA9PT0gbnVsbCkgPyBudWxsIDogKE1hdGguYWJzKGFuZ2xlIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGVycGVuZGljdWxhclRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGRvdCA9IHRoaXMuZG90KHZlY3Rvcik7XG5cdHJldHVybiAoZG90ID09PSBudWxsKSA/IG51bGwgOiAoTWF0aC5hYnMoZG90KSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGluZyB0aGUgYXJndW1lbnQgdG8gdGhlIHZlY3RvclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcblx0dmFyIFYgPSB2YWx1ZS5lbGVtZW50cyB8fCB2YWx1ZTtcblxuXHRpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gVi5sZW5ndGgpIFxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgKyB2YWx1ZSB9KTtcblx0ZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGkpIHsgcmV0dXJuIHggKyBWW2kgLSAxXTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgYXJndW1lbnQgZnJvbSB0aGUgdmVjdG9yXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHR5cGVvZih2KSA9PSAnbnVtYmVyJylcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBrIC0gdjsgfSk7XG5cblx0dmFyIFYgPSB2LmVsZW1lbnRzIHx8IHY7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSBWLmxlbmd0aCkgeyByZXR1cm4gbnVsbDsgfVxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSkgeyByZXR1cm4geCAtIFZbaSAtIDFdOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGx5aW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yIGJ5IHRoZSBhcmd1bWVudFxuICAgIG11bHRpcGx5OiBmdW5jdGlvbihrKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4ICogazsgfSk7XG4gICAgfSxcblxuICAgIGVsZW1lbnRNdWx0aXBseTogZnVuY3Rpb24odikge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaywgaSkge1xuXHQgICAgcmV0dXJuIHYuZShpKSAqIGs7XG5cdH0pO1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VtID0gMDtcblx0dGhpcy5tYXAoZnVuY3Rpb24oeCkgeyBzdW0gKz0geDt9KTtcblx0cmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgY2hvbXA6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKHRoaXMuZWxlbWVudHNbaV0pO1xuXHR9XG5cblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICB0b3A6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGVsZW1lbnRzLnB1c2godGhpcy5lbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIGF1Z21lbnQ6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdHZhciBuZXdFbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShuZXdFbGVtZW50cyk7XG4gICAgfSxcblxuICAgIHg6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMubXVsdGlwbHkoayk7IH0sXG5cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gVmVjdG9yLmxvZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgZWxlbWVudERpdmlkZTogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2LCBpKSB7XG5cdCAgICByZXR1cm4gdiAvIHZlY3Rvci5lKGkpO1xuXHR9KTtcbiAgICB9LFxuXG4gICAgcHJvZHVjdDogZnVuY3Rpb24oKSB7XG5cdHZhciBwID0gMTtcblxuXHR0aGlzLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICBwICo9IHY7XG5cdH0pO1xuXG5cdHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBzY2FsYXIgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBlcXVhbCBkaW1lbnNpb25hbGl0eVxuICAgIGRvdDogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3Rvcjtcblx0dmFyIGksIHByb2R1Y3QgPSAwLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHRcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0d2hpbGUgKG4tLSkgeyBwcm9kdWN0ICs9IHRoaXMuZWxlbWVudHNbbl0gKiBWW25dOyB9XG5cdHJldHVybiBwcm9kdWN0O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBkaW1lbnNpb25hbGl0eSAzXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHZlY3Rvcikge1xuXHR2YXIgQiA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSAzIHx8IEIubGVuZ3RoICE9IDMpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIEEgPSB0aGlzLmVsZW1lbnRzO1xuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdCAgICAoQVsxXSAqIEJbMl0pIC0gKEFbMl0gKiBCWzFdKSxcblx0ICAgIChBWzJdICogQlswXSkgLSAoQVswXSAqIEJbMl0pLFxuXHQgICAgKEFbMF0gKiBCWzFdKSAtIChBWzFdICogQlswXSlcblx0XSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIChhYnNvbHV0ZSkgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3JcbiAgICBtYXg6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbSA9IDAsIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaWYgKE1hdGguYWJzKHRoaXMuZWxlbWVudHNbaV0pID4gTWF0aC5hYnMobSkpIHsgbSA9IHRoaXMuZWxlbWVudHNbaV07IH1cblx0fVxuXHRyZXR1cm4gbTtcbiAgICB9LFxuXG5cbiAgICBtYXhJbmRleDogZnVuY3Rpb24oKSB7XG5cdHZhciBtID0gMCwgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgbWF4SW5kZXggPSAtMTtcblxuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBpZiAoTWF0aC5hYnModGhpcy5lbGVtZW50c1tpXSkgPiBNYXRoLmFicyhtKSkgeyBcblx0XHRtID0gdGhpcy5lbGVtZW50c1tpXTsgXG5cdFx0bWF4SW5kZXggPSBpICsgMTtcblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiBtYXhJbmRleDtcbiAgICB9LFxuXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2ggZm91bmRcbiAgICBpbmRleE9mOiBmdW5jdGlvbih4KSB7XG5cdHZhciBpbmRleCA9IG51bGwsIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmIChpbmRleCA9PT0gbnVsbCAmJiB0aGlzLmVsZW1lbnRzW2ldID09IHgpIHtcblx0XHRpbmRleCA9IGkgKyAxO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSB2ZWN0b3IncyBlbGVtZW50cyBhcyBpdHMgZGlhZ29uYWwgZWxlbWVudHNcbiAgICB0b0RpYWdvbmFsTWF0cml4OiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdHJpeC5EaWFnb25hbCh0aGlzLmVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFRyYW5zcG9zZSBhIFZlY3RvciwgcmV0dXJuIGEgMXhuIE1hdHJpeFxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG5cdHZhciByb3dzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKFt0aGlzLmVsZW1lbnRzW2ldXSk7XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdmVjdG9yIHdpdGggZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZSBpZiB0aGV5XG4gICAgLy8gZGlmZmVyIGZyb20gaXQgYnkgbGVzcyB0aGFuIFN5bHZlc3Rlci5wcmVjaXNpb25cbiAgICBzbmFwVG86IGZ1bmN0aW9uKHgpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHkpIHtcblx0ICAgIHJldHVybiAoTWF0aC5hYnMoeSAtIHgpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pID8geCA6IHk7XG5cdH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IncyBkaXN0YW5jZSBmcm9tIHRoZSBhcmd1bWVudCwgd2hlbiBjb25zaWRlcmVkIGFzIGEgcG9pbnQgaW4gc3BhY2VcbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uKG9iaikge1xuXHRpZiAob2JqLmFuY2hvciB8fCAob2JqLnN0YXJ0ICYmIG9iai5lbmQpKSB7IHJldHVybiBvYmouZGlzdGFuY2VGcm9tKHRoaXMpOyB9XG5cdHZhciBWID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcblx0aWYgKFYubGVuZ3RoICE9IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBzdW0gPSAwLCBwYXJ0O1xuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgcGFydCA9IHggLSBWW2kgLSAxXTtcblx0ICAgIHN1bSArPSBwYXJ0ICogcGFydDtcblx0fSk7XG5cdHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB2ZWN0b3IgaXMgcG9pbnQgb24gdGhlIGdpdmVuIGxpbmVcbiAgICBsaWVzT246IGZ1bmN0aW9uKGxpbmUpIHtcblx0cmV0dXJuIGxpbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGEgcG9pbnQgaW4gdGhlIGdpdmVuIHBsYW5lXG4gICAgbGllc0luOiBmdW5jdGlvbihwbGFuZSkge1xuXHRyZXR1cm4gcGxhbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCB0aGUgZ2l2ZW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBiZSBhXG4gICAgLy8gcG9pbnQgaWYgdGhlIHZlY3RvciBpcyAyRCwgYW5kIGEgbGluZSBpZiBpdCBpcyAzRC4gQmUgY2FyZWZ1bCB3aXRoIGxpbmUgZGlyZWN0aW9ucyFcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHQsIG9iaikge1xuXHR2YXIgViwgUiA9IG51bGwsIHgsIHksIHo7XG5cdGlmICh0LmRldGVybWluYW50KSB7IFIgPSB0LmVsZW1lbnRzOyB9XG5cdHN3aXRjaCAodGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAyOlxuICAgICAgICAgICAgViA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICAgICAgICBpZiAoVi5sZW5ndGggIT0gMikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKCFSKSB7IFIgPSBNYXRyaXguUm90YXRpb24odCkuZWxlbWVudHM7IH1cbiAgICAgICAgICAgIHggPSB0aGlzLmVsZW1lbnRzWzBdIC0gVlswXTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmVsZW1lbnRzWzFdIC0gVlsxXTtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtcblx0XHRWWzBdICsgUlswXVswXSAqIHggKyBSWzBdWzFdICogeSxcblx0XHRWWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcblx0Y2FzZSAzOlxuICAgICAgICAgICAgaWYgKCFvYmouZGlyZWN0aW9uKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICB2YXIgQyA9IG9iai5wb2ludENsb3Nlc3RUbyh0aGlzKS5lbGVtZW50cztcbiAgICAgICAgICAgIGlmICghUikgeyBSID0gTWF0cml4LlJvdGF0aW9uKHQsIG9iai5kaXJlY3Rpb24pLmVsZW1lbnRzOyB9XG4gICAgICAgICAgICB4ID0gdGhpcy5lbGVtZW50c1swXSAtIENbMF07XG4gICAgICAgICAgICB5ID0gdGhpcy5lbGVtZW50c1sxXSAtIENbMV07XG4gICAgICAgICAgICB6ID0gdGhpcy5lbGVtZW50c1syXSAtIENbMl07XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdFx0Q1swXSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcblx0XHRDWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuXHRcdENbMl0gKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cdGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmVmbGVjdGluZyB0aGUgcG9pbnQgaW4gdGhlIGdpdmVuIHBvaW50LCBsaW5lIG9yIHBsYW5lXG4gICAgcmVmbGVjdGlvbkluOiBmdW5jdGlvbihvYmopIHtcblx0aWYgKG9iai5hbmNob3IpIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBsYW5lIG9yIGxpbmVcblx0ICAgIHZhciBQID0gdGhpcy5lbGVtZW50cy5zbGljZSgpO1xuXHQgICAgdmFyIEMgPSBvYmoucG9pbnRDbG9zZXN0VG8oUCkuZWxlbWVudHM7XG5cdCAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQ1swXSArIChDWzBdIC0gUFswXSksIENbMV0gKyAoQ1sxXSAtIFBbMV0pLCBDWzJdICsgKENbMl0gLSAoUFsyXSB8fCAwKSldKTtcblx0fSBlbHNlIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBvaW50XG5cdCAgICB2YXIgUSA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG5cdCAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gUS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpKSB7IHJldHVybiBRW2kgLSAxXSArIChRW2kgLSAxXSAtIHgpOyB9KTtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBVdGlsaXR5IHRvIG1ha2Ugc3VyZSB2ZWN0b3JzIGFyZSAzRC4gSWYgdGhleSBhcmUgMkQsIGEgemVybyB6LWNvbXBvbmVudCBpcyBhZGRlZFxuICAgIHRvM0Q6IGZ1bmN0aW9uKCkge1xuXHR2YXIgViA9IHRoaXMuZHVwKCk7XG5cdHN3aXRjaCAoVi5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAzOiBicmVhaztcblx0Y2FzZSAyOiBWLmVsZW1lbnRzLnB1c2goMCk7IGJyZWFrO1xuXHRkZWZhdWx0OiByZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gVjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiAnWycgKyB0aGlzLmVsZW1lbnRzLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSxcblxuICAgIC8vIFNldCB2ZWN0b3IncyBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gICAgc2V0RWxlbWVudHM6IGZ1bmN0aW9uKGVscykge1xuXHR0aGlzLmVsZW1lbnRzID0gKGVscy5lbGVtZW50cyB8fCBlbHMpLnNsaWNlKCk7XG5cdHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5WZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgViA9IG5ldyBWZWN0b3IoKTtcbiAgICByZXR1cm4gVi5zZXRFbGVtZW50cyhlbGVtZW50cyk7XG59O1xuXG4vLyBpLCBqLCBrIHVuaXQgdmVjdG9yc1xuVmVjdG9yLmkgPSBWZWN0b3IuY3JlYXRlKFsxLCAwLCAwXSk7XG5WZWN0b3IuaiA9IFZlY3Rvci5jcmVhdGUoWzAsIDEsIDBdKTtcblZlY3Rvci5rID0gVmVjdG9yLmNyZWF0ZShbMCwgMCwgMV0pO1xuXG4vLyBSYW5kb20gdmVjdG9yIG9mIHNpemUgblxuVmVjdG9yLlJhbmRvbSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2goTWF0aC5yYW5kb20oKSk7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG5WZWN0b3IuRmlsbCA9IGZ1bmN0aW9uKG4sIHYpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2godik7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG4vLyBWZWN0b3IgZmlsbGVkIHdpdGggemVyb3NcblZlY3Rvci5aZXJvID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBWZWN0b3IuRmlsbChuLCAwKTtcbn07XG5cblZlY3Rvci5PbmUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIFZlY3Rvci5GaWxsKG4sIDEpO1xufTtcblxuVmVjdG9yLmxvZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5tYXAoZnVuY3Rpb24oeCkge1xuXHRyZXR1cm4gTWF0aC5sb2coeCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHZlcmJzID0gL15JbXBsZW1lbnRzfEV4dGVuZHN8QmluZHMkL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgsIG9iail7XHJcbiAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZihrZXkubWF0Y2godmVyYnMpKSBjb250aW51ZTtcclxuICAgIGlmKCh0eXBlb2Ygb2JqW2tleV0gPT0gJ2Z1bmN0aW9uJykgJiYgb2JqW2tleV0uJHN0YXRpYylcclxuICAgICAgY3R4W2tleV0gPSBvYmpba2V5XTtcclxuICAgIGVsc2VcclxuICAgICAgY3R4LnByb3RvdHlwZVtrZXldID0gb2JqW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBjdHg7XHJcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc093biA9IHJlcXVpcmUoXCJtb3V0L29iamVjdC9oYXNPd25cIik7XG52YXIgY3JlYXRlID0gcmVxdWlyZShcIm1vdXQvbGFuZy9jcmVhdGVPYmplY3RcIik7XG52YXIgbWVyZ2UgID0gcmVxdWlyZShcIm1vdXQvb2JqZWN0L21lcmdlXCIpO1xudmFyIGtpbmRPZiA9IHJlcXVpcmUoXCJtb3V0L2xhbmcva2luZE9mXCIpO1xudmFyIG1peEluICA9IHJlcXVpcmUoXCJtb3V0L29iamVjdC9taXhJblwiKTtcblxudmFyIGltcGxlbWVudCA9IHJlcXVpcmUoJy4vaW1wbGVtZW50Jyk7XG52YXIgdmVyYnMgPSAvXkltcGxlbWVudHN8RXh0ZW5kc3xCaW5kcyQvXG5cblxuXG5cbnZhciB1Q2xhc3MgPSBmdW5jdGlvbihwcm90byl7XG5cbiAgaWYoa2luZE9mKHByb3RvKSA9PT0gXCJGdW5jdGlvblwiKSBwcm90byA9IHtpbml0aWFsaXplOiBwcm90b307XG5cbiAgdmFyIHN1cGVycHJpbWUgPSBwcm90by5FeHRlbmRzO1xuXG4gIHZhciBjb25zdHJ1Y3RvciA9IChoYXNPd24ocHJvdG8sIFwiaW5pdGlhbGl6ZVwiKSkgPyBwcm90by5pbml0aWFsaXplIDogc3VwZXJwcmltZSA/IHN1cGVycHJpbWUgOiBmdW5jdGlvbigpe307XG5cblxuXG4gIHZhciBvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvL2F1dG9iaW5kaW5nIHRha2VzIHBsYWNlIGhlcmVcbiAgICBpZihwcm90by5CaW5kcykgcHJvdG8uQmluZHMuZm9yRWFjaChmdW5jdGlvbihmKXtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGZbZl07XG4gICAgICBpZihvcmlnaW5hbClcbiAgICAgICAgc2VsZltmXSA9IG1peEluKHNlbGZbZl0uYmluZChzZWxmKSwgb3JpZ2luYWwpO1xuICAgIH0pO1xuXG4gICAgICAvL2Nsb25lIG5vbiBmdW5jdGlvbi9zdGF0aWMgcHJvcGVydGllcyB0byBjdXJyZW50IGluc3RhbmNlXG4gICAgZm9yKHZhciBrZXkgaW4gb3V0LnByb3RvdHlwZSkge1xuICAgICAgdmFyIHYgPSBvdXQucHJvdG90eXBlW2tleV0sIHQgPSBraW5kT2Yodik7XG5cbiAgICAgIGlmKGtleS5tYXRjaCh2ZXJicykgfHwgdCA9PT0gXCJGdW5jdGlvblwiIHx8IHQgPT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgaWYodCA9PSBcIk9iamVjdFwiKVxuICAgICAgICBzZWxmW2tleV0gPSBtZXJnZSh7fSwgc2VsZltrZXldKTsgLy9jcmVhdGUobnVsbCwgc2VsZltrZXldKTtcbiAgICAgIGVsc2UgaWYodCA9PSBcIkFycmF5XCIpXG4gICAgICAgIHNlbGZba2V5XSA9IHYuc2xpY2UoKTsgLy9jbG9uZSA/P1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmW2tleV0gPSB2O1xuICAgIH1cblxuICAgIGlmKHByb3RvLkltcGxlbWVudHMpXG4gICAgICBwcm90by5JbXBsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oTWl4aW4pe1xuICAgICAgICBNaXhpbi5jYWxsKHNlbGYpO1xuICAgICAgfSk7XG5cblxuXG5cbiAgICBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cblxuICBpZiAoc3VwZXJwcmltZSkge1xuICAgIC8vIGluaGVyaXQgZnJvbSBzdXBlcnByaW1lXG4gICAgICB2YXIgc3VwZXJwcm90byA9IHN1cGVycHJpbWUucHJvdG90eXBlO1xuICAgICAgaWYoc3VwZXJwcm90by5CaW5kcylcbiAgICAgICAgcHJvdG8uQmluZHMgPSAocHJvdG8uQmluZHMgfHwgW10pLmNvbmNhdChzdXBlcnByb3RvLkJpbmRzKTtcblxuICAgICAgaWYoc3VwZXJwcm90by5JbXBsZW1lbnRzKVxuICAgICAgICBwcm90by5JbXBsZW1lbnRzID0gKHByb3RvLkltcGxlbWVudHMgfHwgW10pLmNvbmNhdChzdXBlcnByb3RvLkltcGxlbWVudHMpO1xuXG4gICAgICB2YXIgY3Byb3RvID0gb3V0LnByb3RvdHlwZSA9IGNyZWF0ZShzdXBlcnByb3RvKTtcbiAgICAgIC8vIHNldHRpbmcgY29uc3RydWN0b3IucGFyZW50IHRvIHN1cGVycHJpbWUucHJvdG90eXBlXG4gICAgICAvLyBiZWNhdXNlIGl0J3MgdGhlIHNob3J0ZXN0IHBvc3NpYmxlIGFic29sdXRlIHJlZmVyZW5jZVxuICAgICAgb3V0LnBhcmVudCA9IHN1cGVycHJvdG87XG4gICAgICBjcHJvdG8uY29uc3RydWN0b3IgPSBvdXRcblxuICB9XG5cblxuIGlmKHByb3RvLkltcGxlbWVudHMpIHtcbiAgICBpZiAoa2luZE9mKHByb3RvLkltcGxlbWVudHMpICE9PSBcIkFycmF5XCIpXG4gICAgICBwcm90by5JbXBsZW1lbnRzID0gW3Byb3RvLkltcGxlbWVudHNdO1xuICAgIHByb3RvLkltcGxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihNaXhpbil7XG4gICAgICBpbXBsZW1lbnQob3V0LCBNaXhpbi5wcm90b3R5cGUpO1xuICAgIH0pO1xuICB9XG5cbiAgaW1wbGVtZW50KG91dCwgcHJvdG8pO1xuICBpZihwcm90by5CaW5kcylcbiAgICAgb3V0LnByb3RvdHlwZS5CaW5kcyA9IHByb3RvLkJpbmRzO1xuICBpZihwcm90by5JbXBsZW1lbnRzKVxuICAgICBvdXQucHJvdG90eXBlLkltcGxlbWVudHMgPSBwcm90by5JbXBsZW1lbnRzO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB1Q2xhc3M7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZmaVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZlwiKTsiXSwic291cmNlUm9vdCI6IiJ9